/* This file was generated by the Hex-Rays decompiler version 8.2.0.221215.
   Copyright (c) 2007-2021 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>

//-------------------------------------------------------------------------
// Function declarations

void __golang sync_atomic_LoadUint32();
uint32 __golang runtime_internal_atomic_Load(uint32 *ptr);
void *__golang runtime_internal_atomic_Loadp(void *ptr);
// void __golang runtime_internal_atomic_Cas();
void __golang runtime_internal_atomic_Xaddint64();
// void __golang runtime_internal_atomic_Xadd();
void __golang runtime_internal_atomic_StorepNoWB();
void __golang runtime_internal_atomic_Store();
// void __golang runtime_internal_atomic_Load64();
// void __golang runtime_internal_atomic_Store64();
// void __golang runtime_internal_atomic_Or8();
// void __golang runtime_internal_atomic_And8();
// uintptr __golang runtime_strhash(void *a, uintptr h);
uintptr __golang runtime_f32hash(void *p, uintptr h);
uintptr __golang runtime_f64hash(void *p, uintptr h);
bool __golang runtime_f32equal(void *p, void *q);
bool __golang runtime_f64equal(void *p, void *q);
bool __golang runtime_c64equal(void *p, void *q);
bool __golang runtime_c128equal(void *p, void *q);
// bool __golang runtime_ifaceeq(runtime_itab_0 *tab, void *x, void *y);
// bool __golang runtime_casp(void **ptr, void *old, void *new);
// string __golang runtime_typestring(interface_ x);
void __golang runtime_printany(interface_ i);
float64 __golang runtime_float64frombits(uint64 b);
// uintptr __golang runtime_memhash(void *p, uintptr seed, uintptr s);
// runtime_eface_0 __golang runtime_convT2E(runtime__type_0 *t, void *elem);
// runtime_eface_0 __golang runtime_convT2E32(runtime__type_0 *t, void *elem);
// runtime_eface_0 __golang runtime_convT2Estring(runtime__type_0 *t, void *elem);
// runtime_eface_0 __golang runtime_convT2Eslice(runtime__type_0 *t, void *elem);
// retval_8052920 __golang runtime_assertE2I2(runtime_interfacetype_0 *inter, runtime_eface_0 e);
// void __golang runtime_lock(runtime_mutex_0 *l);
// void __golang runtime_unlock(runtime_mutex_0 *l);
// void *__golang runtime_newobject(runtime__type_0 *typ);
// void *__golang reflect_unsafe_New(runtime__type_0 *typ);
int32 __golang runtime_fastexprand(__int32 mean);
// void __golang runtime_writebarrierptr(uintptr *dst, uintptr src);
// __int32 __golang runtime_typedslicecopy(runtime__type_0 *typ, runtime_slice_0 dst, runtime_slice_0 src);
void __golang runtime_gcinit();
// int32 __golang runtime_readgogc();
// int32 __golang runtime_debug_setGCPercent(int32 in);
// void __golang runtime_setGCPhase(uint32 x);
void __golang runtime__ptr_gcControllerState_startCycle(_ptr_runtime_gcControllerState);
void __golang runtime__ptr_gcControllerState_revise(_ptr_runtime_gcControllerState);
float64 __golang runtime__ptr_gcControllerState_endCycle(runtime_gcControllerState_0 *c);
runtime_g *__golang runtime__ptr_gcControllerState_findRunnableGCWorker(runtime_gcControllerState_0 *c, runtime_p *_p_);
bool __golang runtime_pollFractionalWorkerExit();
void __golang runtime_gcSetTriggerRatio(float64 triggerRatio);
void __golang runtime_gcMarkDone();
void __golang runtime_gcMarkTermination(float64 nextTriggerRatio);
// bool __golang runtime_gcMarkWorkAvailable(runtime_p *p);
void __golang runtime_gcSweep(runtime_gcMode mode);
// void __golang sync_runtime_registerPoolCleanup(func f);
// _slice_uint8 __golang runtime_itoaDiv(_slice_uint8 buf, uint64 val, __int32 dec);
// _slice_uint8 __golang runtime_fmtNSAsMS(_slice_uint8 buf, uint64 ns);
// void __golang runtime_gcMarkRootCheck();
// void __golang runtime_gcWakeAllAssists();
// uintptr __golang runtime_sweepone();
// uintptr __golang runtime_gosweepone();
void __golang runtime_deductSweepCredit(uintptr spanBytes, uintptr callerSweepPages);
// void __golang runtime_prepareFreeWorkbufs();
// bool __golang runtime_freeSomeWbufs(bool preemptible);
// void __golang runtime_mProf_NextCycle();
// void __golang runtime_mProf_Flush();
void __golang runtime_unminit();
// void __golang runtime_panicCheckMalloc(error_0 err);
void __golang __noreturn runtime_panicindex();
void __golang __noreturn runtime_panicslice();
void __golang __noreturn runtime_panicdivide();
void __golang __noreturn runtime_panicoverflow();
void __golang __noreturn runtime_panicfloat();
void __golang __noreturn runtime_panicmem();
void __golang __noreturn runtime_throwinit();
// void __golang runtime_gopanic(interface_ e);
uintptr __golang runtime_getargp(__int32 x);
// interface_ __golang runtime_gorecover(uintptr argp);
void __golang runtime_startpanic();
// void __golang runtime_throw(string s);
// void __golang runtime_printlock();
// void __golang runtime_printunlock();
// void __golang runtime_gwrite(_slice_uint8 b);
void __golang runtime_printsp();
void __golang runtime_printnl();
// void __golang runtime_printbool(bool v);
void __golang runtime_printfloat(float64 v);
// void __golang runtime_printcomplex(complex128 c);
// void __golang runtime_printuint(uint64 v);
// void __golang runtime_printint(int64 v);
// void __golang runtime_printstring(string s);
// void __golang runtime_printeface(runtime_eface_0 e);
void __golang runtime_Gosched();
void __golang __noreturn runtime_badmcall(func_ptr_runtime_g fn);
void __golang __noreturn runtime_badreflectcall();
// void __golang runtime_ready(runtime_g *gp, __int32 traceskip, bool next);
// void __golang runtime_casgstatus(runtime_g *gp, uint32 oldval, uint32 newval);
// void __golang runtime_forEachP(func_ptr_runtime_p fn);
// void __golang runtime_injectglist(runtime_g *glist);
// void __golang runtime_goexit1();
_slice_string __golang syscall_runtime_envs();
_slice_string __golang os_runtime_args();
// void __golang runtime_testAtomic64();
void __golang runtime_check();
// int32 __golang runtime_timediv(int64 v, int32 div, int32 *rem);
// void __golang runtime_semacquire(uint32 *addr);
// void __golang runtime_semrelease(uint32 *addr);
void __golang os_sigpipe();
// void __golang runtime_unminitSignals();
// runtime_slice_0 __golang runtime_growslice(runtime__type_0 *et, runtime_slice_0 old, __int32 cap);
// int32 __golang runtime_round2(int32 x);
void __golang runtime_morestackc();
// string __golang runtime_concatstring2(uint8 (*buf)[32], string a[2]);
// string __golang runtime_slicebytetostring(uint8 (*buf)[32], _slice_uint8 b);
// _slice_uint8 __golang runtime_stringtoslicebyte(uint8 (*buf)[32], string s);
// retval_8084670 __golang time_now();
// void __golang runtime_traceGCDone();
// void __golang runtime_traceGCSTWStart(__int32 kind);
// void __golang runtime_traceGCSweepStart();
// void __golang runtime_traceGCSweepDone();
// void __golang runtime_traceGoUnpark(runtime_g *gp, __int32 skip);
// void __golang runtime_traceNextGC();
// runtime__type_0 *__golang runtime_resolveTypeOff(void *ptrInModule, runtime_typeOff off);
runtime__type_0 *__golang runtime__ptr__type_typeOff(runtime__type_0 *t, runtime_typeOff off);
uint64 __golang runtime_float64toint64(float64 d);
uint64 __golang runtime_float64touint64(float64 d);
float64 __golang runtime_int64tofloat64(int64 y);
// float64 __golang runtime_uint64tofloat64(uint64 y);
void __golang runtime__d2v(uint64 *y, float64 d);
// uint64 __golang runtime_uint64div(uint64 n, uint64 d);
void __golang __noreturn runtime_cgoCheckTypedBlock_func2();
void __golang __noreturn runtime_cgoCheckBits_func1();
// bool __golang runtime__ptr_gcControllerState_findRunnableGCWorker_func1(int64 *ptr);
void __golang runtime_gcMarkDone_func1();
// void __golang runtime_gcMarkTermination_func1();
// void __golang runtime_gcMarkTermination_func2();
void __golang __noreturn runtime_morestackc_func1();
void __golang runtime_asminit();
// void __golang runtime_mcall();
// void __golang runtime_systemstack();
// void __golang runtime_morestack();
void __golang runtime_morestack_noctxt();
// void __golang runtime_checkASM();
// void __golang runtime_memequal();
void __golang runtime_return0();
void __golang runtime_goexit();
// void __golang runtime_uint32tofloat64();
// void __golang runtime_float64touint32();
// void __golang runtime_memmove();
// void __golang runtime_nanotime();
void __golang runtime_sigreturn();
void __golang runtime_osyield();
bool __golang type__eq_runtime_MemStats(runtime_MemStats_0 *p, runtime_MemStats_0 *q);
uintptr __golang type__hash_runtime_markBits(runtime_markBits_0 *p, uintptr h);
bool __golang type__eq_runtime_gcControllerState(runtime_gcControllerState_0 *p, runtime_gcControllerState_0 *q);
bool __golang type__eq_runtime_mstats(runtime_mstats_0 *p, runtime_mstats_0 *q);
uintptr __golang type__hash_runtime_symbol_key(runtime_symbol_key_0 *p, uintptr h);
bool __golang type__eq__33_float64(float64 (*p)[33], float64 (*q)[33]);
uintptr __golang type__hash_struct__runtime_enabled_bool_runtime_pad__3_uint8_runtime_needed_bool_runtime_cgo_bool_runtime_alignme_uint64_(struct__runtime_enabled_bool_runtime_pad__3_uint8_runtime_needed_bool_runtime_cgo_bool_runtime_alignme_uint64_ *p, uintptr h);
// void __golang math_Ldexp();
// bool __golang strconv_equalIgnoreCase(string s1, string s2);
retval_8094DD0 __golang strconv_special(string s);
// bool __golang strconv__ptr_decimal_set(_ptr_strconv_decimal, string_0);
// retval_80952F0 __golang strconv_readFloat(string s);
// retval_8095730 __golang strconv__ptr_decimal_floatBits(strconv_decimal *d, strconv_floatInfo_0 *flt);
retval_8095BA0 __golang strconv_atof64exact(uint64 mantissa, __int32 exp, bool neg);
retval_8095DC0 __golang strconv_atof32exact(uint64 mantissa, __int32 exp, bool neg);
retval_8096010 __golang strconv_atof32(string s);
retval_8096560 __golang strconv_atof64(string s);
// retval_8096AC0 __golang strconv_ParseFloat(string s, __int32 bitSize);
// retval_8097DF0 __golang strconv_Atoi(string s);
// retval_8098D70 __golang strconv__ptr_extFloat_floatBits(strconv_extFloat_0 *f, strconv_floatInfo_0 *flt);
// retval_8099170 __golang strconv__ptr_extFloat_AssignComputeBounds(strconv_extFloat_0 *f, uint64 mant, __int32 exp, bool neg, strconv_floatInfo_0 *flt);
// bool __golang strconv__ptr_extFloat_AssignDecimal(strconv_extFloat_0 *f, uint64 mantissa, __int32 exp10, bool neg, bool trunc, strconv_floatInfo_0 *flt);
// bool __golang strconv__ptr_extFloat_FixedDecimal(strconv_extFloat_0 *f, strconv_decimalSlice *d, __int32 n);
// bool __golang strconv__ptr_extFloat_ShortestDecimal(strconv_extFloat_0 *f, strconv_decimalSlice *d, strconv_extFloat_0 *lower, strconv_extFloat_0 *upper);
_slice_uint8 __golang strconv_AppendFloat(_slice_uint8 dst, float64 f, uint8 fmt, __int32 prec, __int32 bitSize);
_slice_uint8 __golang strconv_genericFtoa(_slice_uint8 dst, float64 val, uint8 fmt, __int32 prec, __int32 bitSize);
// _slice_uint8 __golang strconv_bigFtoa(_slice_uint8 dst, __int32 prec, uint8 fmt, bool neg, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt);
// _slice_uint8 __golang strconv_formatDigits(_slice_uint8 dst, bool shortest, bool neg, strconv_decimalSlice_0 digs, __int32 prec, uint8 fmt);
// _slice_uint8 __golang strconv_fmtB(_slice_uint8 dst, bool neg, uint64 mant, __int32 exp, strconv_floatInfo_0 *flt);
// void __golang strconv_init();
bool __golang type__eq__11_float32(float32 (*p)[11], float32 (*q)[11]);
bool __golang type__eq__23_float64(float64 (*p)[23], float64 (*q)[23]);
void __golang sync_init_0();
// void __golang sync_init();
// void __golang io_init();
// void __golang time_init();
uintptr __golang type__hash_time_zone(time_zone_0 *p, uintptr h);
// void __golang __noreturn os_Exit(__int32 code);
// void __golang os_init();
// void __golang unicode_init();
// _ptr_reflect_uncommonType __golang reflect__ptr_rtype_uncommon(_ptr_reflect_rtype);
// string_0 __golang reflect__ptr_rtype_String(_ptr_reflect_rtype);
// uintptr_0 __golang reflect__ptr_rtype_Size(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_Bits(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_Align(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_FieldAlign(_ptr_reflect_rtype);
// reflect_Kind_0 __golang reflect__ptr_rtype_Kind(_ptr_reflect_rtype);
// _ptr_reflect_rtype __golang reflect__ptr_rtype_common(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_NumMethod(_ptr_reflect_rtype);
// string_0 __golang reflect__ptr_rtype_PkgPath(_ptr_reflect_rtype);
// string_0 __golang reflect__ptr_rtype_Name(_ptr_reflect_rtype);
// reflect_ChanDir_0 __golang reflect__ptr_rtype_ChanDir(_ptr_reflect_rtype);
// bool __golang reflect__ptr_rtype_IsVariadic(_ptr_reflect_rtype);
// reflect_Type_1 __golang reflect__ptr_rtype_Elem(_ptr_reflect_rtype);
// reflect_Type_1 __golang reflect__ptr_rtype_In(_ptr_reflect_rtype, signed __int32);
// reflect_Type_1 __golang reflect__ptr_rtype_Key(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_Len(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_NumField(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_NumIn(_ptr_reflect_rtype);
// signed __int32 __golang reflect__ptr_rtype_NumOut(_ptr_reflect_rtype);
// reflect_Type_1 __golang reflect__ptr_rtype_Out(_ptr_reflect_rtype, signed __int32);
// bool __golang reflect__ptr_rtype_Implements(_ptr_reflect_rtype, reflect_Type_1);
// bool __golang reflect__ptr_rtype_ConvertibleTo(_ptr_reflect_rtype, reflect_Type_1);
// bool __golang reflect__ptr_rtype_Comparable(_ptr_reflect_rtype);
// void __golang reflect_flag_mustBeAssignable(reflect_flag_0);
complex128 __golang reflect_Value_Complex(reflect_Value_0 v);
// reflect_Value_0 __golang reflect_Value_Elem(reflect_Value_0 v);
float64 __golang reflect_Value_Float(reflect_Value_0 v);
// reflect_Value_0 __golang reflect_Value_Index(reflect_Value_0 v, __int32 i);
// bool __golang reflect_Value_CanInterface(reflect_Value_1);
// interface__1 __golang reflect_Value_Interface(reflect_Value_1);
// void __golang reflect_Value_Set(reflect_Value_0 v, reflect_Value_0 x);
// void __golang reflect_Value_SetBool(reflect_Value_0 v, bool x);
void __golang reflect_Value_SetComplex(reflect_Value_0 v, complex128 x);
void __golang reflect_Value_SetFloat(reflect_Value_0 v, float64 x);
// void __golang reflect_Value_SetInt(reflect_Value_0 v, int64 x);
// void __golang reflect_Value_SetUint(reflect_Value_0 v, uint64 x);
// void __golang reflect_Value_SetString(reflect_Value_1, string_0);
// reflect_Type_1 __golang reflect_Value_Type(reflect_Value_1);
// reflect_Value_0 __golang reflect_MakeSlice(reflect_Type_0 typ, __int32 len, __int32 cap);
// reflect_Value_0 __golang reflect_ValueOf(interface_ i);
// reflect_Value_0 __golang reflect_makeInt(reflect_flag f, uint64 bits, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeFloat(reflect_flag f, float64 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_makeComplex(reflect_flag f, complex128 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtFloatInt(reflect_Value_0 v, reflect_Type_0 t);
reflect_Value_0 __golang reflect_cvtFloatUint(reflect_Value_0 v, reflect_Type_0 t);
// void __golang reflect_init();
_ptr_reflect_uncommonType __golang reflect__ptr_structType_uncommon(_ptr_reflect_structType);
string_0 __golang reflect__ptr_structType_String(_ptr_reflect_structType);
uintptr_0 __golang reflect__ptr_structType_Size(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_Bits(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_Align(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_FieldAlign(_ptr_reflect_structType);
reflect_Kind_0 __golang reflect__ptr_structType_Kind(_ptr_reflect_structType);
_ptr_reflect_rtype __golang reflect__ptr_structType_common(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_NumMethod(_ptr_reflect_structType);
string_0 __golang reflect__ptr_structType_PkgPath(_ptr_reflect_structType);
string_0 __golang reflect__ptr_structType_Name(_ptr_reflect_structType);
reflect_ChanDir_0 __golang reflect__ptr_structType_ChanDir(_ptr_reflect_structType);
bool __golang reflect__ptr_structType_IsVariadic(_ptr_reflect_structType);
reflect_Type_1 __golang reflect__ptr_structType_Elem(_ptr_reflect_structType);
reflect_Type_1 __golang reflect__ptr_structType_In(_ptr_reflect_structType, signed __int32);
reflect_Type_1 __golang reflect__ptr_structType_Key(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_Len(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_NumField(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_NumIn(_ptr_reflect_structType);
signed __int32 __golang reflect__ptr_structType_NumOut(_ptr_reflect_structType);
reflect_Type_1 __golang reflect__ptr_structType_Out(_ptr_reflect_structType, signed __int32);
bool __golang reflect__ptr_structType_Implements(_ptr_reflect_structType, reflect_Type_1);
bool __golang reflect__ptr_structType_ConvertibleTo(_ptr_reflect_structType, reflect_Type_1);
bool __golang reflect__ptr_structType_Comparable(_ptr_reflect_structType);
_ptr_reflect_uncommonType __golang reflect__ptr_funcType_uncommon(_ptr_reflect_funcType);
string_0 __golang reflect__ptr_funcType_String(_ptr_reflect_funcType);
uintptr_0 __golang reflect__ptr_funcType_Size(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_Bits(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_Align(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_FieldAlign(_ptr_reflect_funcType);
reflect_Kind_0 __golang reflect__ptr_funcType_Kind(_ptr_reflect_funcType);
_ptr_reflect_rtype __golang reflect__ptr_funcType_common(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_NumMethod(_ptr_reflect_funcType);
string_0 __golang reflect__ptr_funcType_PkgPath(_ptr_reflect_funcType);
string_0 __golang reflect__ptr_funcType_Name(_ptr_reflect_funcType);
reflect_ChanDir_0 __golang reflect__ptr_funcType_ChanDir(_ptr_reflect_funcType);
bool __golang reflect__ptr_funcType_IsVariadic(_ptr_reflect_funcType);
reflect_Type_1 __golang reflect__ptr_funcType_Elem(_ptr_reflect_funcType);
reflect_Type_1 __golang reflect__ptr_funcType_In(_ptr_reflect_funcType, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcType_Key(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_Len(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_NumField(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_NumIn(_ptr_reflect_funcType);
signed __int32 __golang reflect__ptr_funcType_NumOut(_ptr_reflect_funcType);
reflect_Type_1 __golang reflect__ptr_funcType_Out(_ptr_reflect_funcType, signed __int32);
bool __golang reflect__ptr_funcType_Implements(_ptr_reflect_funcType, reflect_Type_1);
bool __golang reflect__ptr_funcType_ConvertibleTo(_ptr_reflect_funcType, reflect_Type_1);
bool __golang reflect__ptr_funcType_Comparable(_ptr_reflect_funcType);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed128_uncommon(_ptr_reflect_funcTypeFixed128);
string_0 __golang reflect__ptr_funcTypeFixed128_String(_ptr_reflect_funcTypeFixed128);
uintptr_0 __golang reflect__ptr_funcTypeFixed128_Size(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_Bits(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_Align(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_FieldAlign(_ptr_reflect_funcTypeFixed128);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed128_Kind(_ptr_reflect_funcTypeFixed128);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed128_common(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumMethod(_ptr_reflect_funcTypeFixed128);
string_0 __golang reflect__ptr_funcTypeFixed128_PkgPath(_ptr_reflect_funcTypeFixed128);
string_0 __golang reflect__ptr_funcTypeFixed128_Name(_ptr_reflect_funcTypeFixed128);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed128_ChanDir(_ptr_reflect_funcTypeFixed128);
bool __golang reflect__ptr_funcTypeFixed128_IsVariadic(_ptr_reflect_funcTypeFixed128);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Elem(_ptr_reflect_funcTypeFixed128);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_In(_ptr_reflect_funcTypeFixed128, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Key(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_Len(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumField(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumIn(_ptr_reflect_funcTypeFixed128);
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumOut(_ptr_reflect_funcTypeFixed128);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Out(_ptr_reflect_funcTypeFixed128, signed __int32);
bool __golang reflect__ptr_funcTypeFixed128_Implements(_ptr_reflect_funcTypeFixed128, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed128_ConvertibleTo(_ptr_reflect_funcTypeFixed128, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed128_Comparable(_ptr_reflect_funcTypeFixed128);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed16_uncommon(_ptr_reflect_funcTypeFixed16);
string_0 __golang reflect__ptr_funcTypeFixed16_String(_ptr_reflect_funcTypeFixed16);
uintptr_0 __golang reflect__ptr_funcTypeFixed16_Size(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_Bits(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_Align(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_FieldAlign(_ptr_reflect_funcTypeFixed16);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed16_Kind(_ptr_reflect_funcTypeFixed16);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed16_common(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumMethod(_ptr_reflect_funcTypeFixed16);
string_0 __golang reflect__ptr_funcTypeFixed16_PkgPath(_ptr_reflect_funcTypeFixed16);
string_0 __golang reflect__ptr_funcTypeFixed16_Name(_ptr_reflect_funcTypeFixed16);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed16_ChanDir(_ptr_reflect_funcTypeFixed16);
bool __golang reflect__ptr_funcTypeFixed16_IsVariadic(_ptr_reflect_funcTypeFixed16);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Elem(_ptr_reflect_funcTypeFixed16);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_In(_ptr_reflect_funcTypeFixed16, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Key(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_Len(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumField(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumIn(_ptr_reflect_funcTypeFixed16);
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumOut(_ptr_reflect_funcTypeFixed16);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Out(_ptr_reflect_funcTypeFixed16, signed __int32);
bool __golang reflect__ptr_funcTypeFixed16_Implements(_ptr_reflect_funcTypeFixed16, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed16_ConvertibleTo(_ptr_reflect_funcTypeFixed16, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed16_Comparable(_ptr_reflect_funcTypeFixed16);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed32_uncommon(_ptr_reflect_funcTypeFixed32);
string_0 __golang reflect__ptr_funcTypeFixed32_String(_ptr_reflect_funcTypeFixed32);
uintptr_0 __golang reflect__ptr_funcTypeFixed32_Size(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_Bits(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_Align(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_FieldAlign(_ptr_reflect_funcTypeFixed32);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed32_Kind(_ptr_reflect_funcTypeFixed32);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed32_common(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumMethod(_ptr_reflect_funcTypeFixed32);
string_0 __golang reflect__ptr_funcTypeFixed32_PkgPath(_ptr_reflect_funcTypeFixed32);
string_0 __golang reflect__ptr_funcTypeFixed32_Name(_ptr_reflect_funcTypeFixed32);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed32_ChanDir(_ptr_reflect_funcTypeFixed32);
bool __golang reflect__ptr_funcTypeFixed32_IsVariadic(_ptr_reflect_funcTypeFixed32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Elem(_ptr_reflect_funcTypeFixed32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_In(_ptr_reflect_funcTypeFixed32, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Key(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_Len(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumField(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumIn(_ptr_reflect_funcTypeFixed32);
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumOut(_ptr_reflect_funcTypeFixed32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Out(_ptr_reflect_funcTypeFixed32, signed __int32);
bool __golang reflect__ptr_funcTypeFixed32_Implements(_ptr_reflect_funcTypeFixed32, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed32_ConvertibleTo(_ptr_reflect_funcTypeFixed32, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed32_Comparable(_ptr_reflect_funcTypeFixed32);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed4_uncommon(_ptr_reflect_funcTypeFixed4);
string_0 __golang reflect__ptr_funcTypeFixed4_String(_ptr_reflect_funcTypeFixed4);
uintptr_0 __golang reflect__ptr_funcTypeFixed4_Size(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_Bits(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_Align(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_FieldAlign(_ptr_reflect_funcTypeFixed4);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed4_Kind(_ptr_reflect_funcTypeFixed4);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed4_common(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumMethod(_ptr_reflect_funcTypeFixed4);
string_0 __golang reflect__ptr_funcTypeFixed4_PkgPath(_ptr_reflect_funcTypeFixed4);
string_0 __golang reflect__ptr_funcTypeFixed4_Name(_ptr_reflect_funcTypeFixed4);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed4_ChanDir(_ptr_reflect_funcTypeFixed4);
bool __golang reflect__ptr_funcTypeFixed4_IsVariadic(_ptr_reflect_funcTypeFixed4);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Elem(_ptr_reflect_funcTypeFixed4);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_In(_ptr_reflect_funcTypeFixed4, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Key(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_Len(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumField(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumIn(_ptr_reflect_funcTypeFixed4);
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumOut(_ptr_reflect_funcTypeFixed4);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Out(_ptr_reflect_funcTypeFixed4, signed __int32);
bool __golang reflect__ptr_funcTypeFixed4_Implements(_ptr_reflect_funcTypeFixed4, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed4_ConvertibleTo(_ptr_reflect_funcTypeFixed4, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed4_Comparable(_ptr_reflect_funcTypeFixed4);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed64_uncommon(_ptr_reflect_funcTypeFixed64);
string_0 __golang reflect__ptr_funcTypeFixed64_String(_ptr_reflect_funcTypeFixed64);
uintptr_0 __golang reflect__ptr_funcTypeFixed64_Size(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_Bits(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_Align(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_FieldAlign(_ptr_reflect_funcTypeFixed64);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed64_Kind(_ptr_reflect_funcTypeFixed64);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed64_common(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumMethod(_ptr_reflect_funcTypeFixed64);
string_0 __golang reflect__ptr_funcTypeFixed64_PkgPath(_ptr_reflect_funcTypeFixed64);
string_0 __golang reflect__ptr_funcTypeFixed64_Name(_ptr_reflect_funcTypeFixed64);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed64_ChanDir(_ptr_reflect_funcTypeFixed64);
bool __golang reflect__ptr_funcTypeFixed64_IsVariadic(_ptr_reflect_funcTypeFixed64);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Elem(_ptr_reflect_funcTypeFixed64);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_In(_ptr_reflect_funcTypeFixed64, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Key(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_Len(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumField(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumIn(_ptr_reflect_funcTypeFixed64);
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumOut(_ptr_reflect_funcTypeFixed64);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Out(_ptr_reflect_funcTypeFixed64, signed __int32);
bool __golang reflect__ptr_funcTypeFixed64_Implements(_ptr_reflect_funcTypeFixed64, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed64_ConvertibleTo(_ptr_reflect_funcTypeFixed64, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed64_Comparable(_ptr_reflect_funcTypeFixed64);
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed8_uncommon(_ptr_reflect_funcTypeFixed8);
string_0 __golang reflect__ptr_funcTypeFixed8_String(_ptr_reflect_funcTypeFixed8);
uintptr_0 __golang reflect__ptr_funcTypeFixed8_Size(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_Bits(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_Align(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_FieldAlign(_ptr_reflect_funcTypeFixed8);
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed8_Kind(_ptr_reflect_funcTypeFixed8);
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed8_common(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumMethod(_ptr_reflect_funcTypeFixed8);
string_0 __golang reflect__ptr_funcTypeFixed8_PkgPath(_ptr_reflect_funcTypeFixed8);
string_0 __golang reflect__ptr_funcTypeFixed8_Name(_ptr_reflect_funcTypeFixed8);
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed8_ChanDir(_ptr_reflect_funcTypeFixed8);
bool __golang reflect__ptr_funcTypeFixed8_IsVariadic(_ptr_reflect_funcTypeFixed8);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Elem(_ptr_reflect_funcTypeFixed8);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_In(_ptr_reflect_funcTypeFixed8, signed __int32);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Key(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_Len(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumField(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumIn(_ptr_reflect_funcTypeFixed8);
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumOut(_ptr_reflect_funcTypeFixed8);
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Out(_ptr_reflect_funcTypeFixed8, signed __int32);
bool __golang reflect__ptr_funcTypeFixed8_Implements(_ptr_reflect_funcTypeFixed8, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed8_ConvertibleTo(_ptr_reflect_funcTypeFixed8, reflect_Type_1);
bool __golang reflect__ptr_funcTypeFixed8_Comparable(_ptr_reflect_funcTypeFixed8);
_ptr_reflect_uncommonType __golang reflect__ptr_interfaceType_uncommon(_ptr_reflect_interfaceType);
string_0 __golang reflect__ptr_interfaceType_String(_ptr_reflect_interfaceType);
uintptr_0 __golang reflect__ptr_interfaceType_Size(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_Bits(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_Align(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_FieldAlign(_ptr_reflect_interfaceType);
reflect_Kind_0 __golang reflect__ptr_interfaceType_Kind(_ptr_reflect_interfaceType);
_ptr_reflect_rtype __golang reflect__ptr_interfaceType_common(_ptr_reflect_interfaceType);
string_0 __golang reflect__ptr_interfaceType_PkgPath(_ptr_reflect_interfaceType);
string_0 __golang reflect__ptr_interfaceType_Name(_ptr_reflect_interfaceType);
reflect_ChanDir_0 __golang reflect__ptr_interfaceType_ChanDir(_ptr_reflect_interfaceType);
bool __golang reflect__ptr_interfaceType_IsVariadic(_ptr_reflect_interfaceType);
reflect_Type_1 __golang reflect__ptr_interfaceType_Elem(_ptr_reflect_interfaceType);
reflect_Type_1 __golang reflect__ptr_interfaceType_In(_ptr_reflect_interfaceType, signed __int32);
reflect_Type_1 __golang reflect__ptr_interfaceType_Key(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_Len(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_NumField(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_NumIn(_ptr_reflect_interfaceType);
signed __int32 __golang reflect__ptr_interfaceType_NumOut(_ptr_reflect_interfaceType);
reflect_Type_1 __golang reflect__ptr_interfaceType_Out(_ptr_reflect_interfaceType, signed __int32);
bool __golang reflect__ptr_interfaceType_Implements(_ptr_reflect_interfaceType, reflect_Type_1);
bool __golang reflect__ptr_interfaceType_ConvertibleTo(_ptr_reflect_interfaceType, reflect_Type_1);
bool __golang reflect__ptr_interfaceType_Comparable(_ptr_reflect_interfaceType);
_ptr_reflect_uncommonType __golang reflect__ptr_ptrType_uncommon(_ptr_reflect_ptrType);
string_0 __golang reflect__ptr_ptrType_String(_ptr_reflect_ptrType);
uintptr_0 __golang reflect__ptr_ptrType_Size(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_Bits(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_Align(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_FieldAlign(_ptr_reflect_ptrType);
reflect_Kind_0 __golang reflect__ptr_ptrType_Kind(_ptr_reflect_ptrType);
_ptr_reflect_rtype __golang reflect__ptr_ptrType_common(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_NumMethod(_ptr_reflect_ptrType);
string_0 __golang reflect__ptr_ptrType_PkgPath(_ptr_reflect_ptrType);
string_0 __golang reflect__ptr_ptrType_Name(_ptr_reflect_ptrType);
reflect_ChanDir_0 __golang reflect__ptr_ptrType_ChanDir(_ptr_reflect_ptrType);
bool __golang reflect__ptr_ptrType_IsVariadic(_ptr_reflect_ptrType);
reflect_Type_1 __golang reflect__ptr_ptrType_Elem(_ptr_reflect_ptrType);
reflect_Type_1 __golang reflect__ptr_ptrType_In(_ptr_reflect_ptrType, signed __int32);
reflect_Type_1 __golang reflect__ptr_ptrType_Key(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_Len(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_NumField(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_NumIn(_ptr_reflect_ptrType);
signed __int32 __golang reflect__ptr_ptrType_NumOut(_ptr_reflect_ptrType);
reflect_Type_1 __golang reflect__ptr_ptrType_Out(_ptr_reflect_ptrType, signed __int32);
bool __golang reflect__ptr_ptrType_Implements(_ptr_reflect_ptrType, reflect_Type_1);
bool __golang reflect__ptr_ptrType_ConvertibleTo(_ptr_reflect_ptrType, reflect_Type_1);
bool __golang reflect__ptr_ptrType_Comparable(_ptr_reflect_ptrType);
_ptr_reflect_uncommonType __golang reflect__ptr_sliceType_uncommon(_ptr_reflect_sliceType);
string_0 __golang reflect__ptr_sliceType_String(_ptr_reflect_sliceType);
uintptr_0 __golang reflect__ptr_sliceType_Size(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_Bits(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_Align(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_FieldAlign(_ptr_reflect_sliceType);
reflect_Kind_0 __golang reflect__ptr_sliceType_Kind(_ptr_reflect_sliceType);
_ptr_reflect_rtype __golang reflect__ptr_sliceType_common(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_NumMethod(_ptr_reflect_sliceType);
string_0 __golang reflect__ptr_sliceType_PkgPath(_ptr_reflect_sliceType);
string_0 __golang reflect__ptr_sliceType_Name(_ptr_reflect_sliceType);
reflect_ChanDir_0 __golang reflect__ptr_sliceType_ChanDir(_ptr_reflect_sliceType);
bool __golang reflect__ptr_sliceType_IsVariadic(_ptr_reflect_sliceType);
reflect_Type_1 __golang reflect__ptr_sliceType_Elem(_ptr_reflect_sliceType);
reflect_Type_1 __golang reflect__ptr_sliceType_In(_ptr_reflect_sliceType, signed __int32);
reflect_Type_1 __golang reflect__ptr_sliceType_Key(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_Len(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_NumField(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_NumIn(_ptr_reflect_sliceType);
signed __int32 __golang reflect__ptr_sliceType_NumOut(_ptr_reflect_sliceType);
reflect_Type_1 __golang reflect__ptr_sliceType_Out(_ptr_reflect_sliceType, signed __int32);
bool __golang reflect__ptr_sliceType_Implements(_ptr_reflect_sliceType, reflect_Type_1);
bool __golang reflect__ptr_sliceType_ConvertibleTo(_ptr_reflect_sliceType, reflect_Type_1);
bool __golang reflect__ptr_sliceType_Comparable(_ptr_reflect_sliceType);
// void __golang fmt__ptr_fmt_writePadding(fmt_fmt *f, __int32 n);
// void __golang fmt__ptr_fmt_pad(fmt_fmt *f, _slice_uint8 b);
// void __golang fmt__ptr_fmt_padString(_ptr_fmt_fmt, string_0);
// void __golang fmt__ptr_fmt_fmt_s(_ptr_fmt_fmt, string_0);
void __golang fmt__ptr_fmt_fmt_float(fmt_fmt *f, float64 v, __int32 size, int32 verb, __int32 prec);
// retval_80C6600 __golang fmt_Printf(string format, _slice_interface_ a);
// retval_80C6740 __golang fmt_Println(_slice_interface_ a);
// void __golang fmt__ptr_pp_badVerb(fmt_pp *p, int32 verb);
// void __golang fmt__ptr_pp_fmtBool(fmt_pp *p, bool v, int32 verb);
// void __golang fmt__ptr_pp_fmtInteger(fmt_pp *p, uint64 v, bool isSigned, int32 verb);
void __golang fmt__ptr_pp_fmtFloat(fmt_pp *p, float64 v, __int32 size, int32 verb);
void __golang fmt__ptr_pp_fmtComplex(fmt_pp *p, complex128 v, __int32 size, int32 verb);
// void __golang fmt__ptr_pp_fmtString(fmt_pp *p, string v, int32 verb);
// void __golang fmt__ptr_pp_fmtBytes(fmt_pp *p, _slice_uint8 v, int32 verb, string typeString);
// void __golang fmt__ptr_pp_fmtPointer(fmt_pp *p, reflect_Value_0 value, int32 verb);
// bool __golang fmt__ptr_pp_handleMethods(_ptr_fmt_pp, int32_0);
void __golang fmt__ptr_pp_printArg(fmt_pp *p, interface_ arg, int32 verb);
// void __golang fmt__ptr_pp_printValue(fmt_pp *p, reflect_Value_0 value, int32 verb, __int32 depth);
// retval_80CD630 __golang fmt_Scanf(string format, _slice_interface_ a);
void __golang __noreturn fmt__ptr_ss_error(fmt_ss *s, error_0 err);
// void __golang fmt__ptr_ss_errorString(_ptr_fmt_ss, string_0);
// void __golang fmt__ptr_ss_SkipSpace(_ptr_fmt_ss);
// __int32 __golang fmt_indexRune(string s, int32 r);
// void __golang fmt__ptr_ss_notEOF(_ptr_fmt_ss);
// bool __golang fmt__ptr_ss_okVerb(fmt_ss *s, int32 verb, string okVerbs, string typ);
// bool __golang fmt__ptr_ss_scanBool(_ptr_fmt_ss, int32_0);
// int64 __golang fmt__ptr_ss_scanInt(fmt_ss *s, int32 verb, __int32 bitSize);
// uint64 __golang fmt__ptr_ss_scanUint(fmt_ss *s, int32 verb, __int32 bitSize);
// string_0 __golang fmt__ptr_ss_floatToken(_ptr_fmt_ss);
// retval_80CF980 __golang fmt__ptr_ss_complexTokens(fmt_ss *s);
float64 __golang fmt__ptr_ss_convertFloat(fmt_ss *s, string str, __int32 n);
complex128 __golang fmt__ptr_ss_scanComplex(fmt_ss *s, int32 verb, __int32 n);
// string __golang fmt__ptr_ss_convertString(fmt_ss *s, int32 verb);
void __golang fmt__ptr_ss_scanOne(fmt_ss *s, int32 verb, interface_ arg);
interface_ __golang fmt_glob__func1();
interface_ __golang fmt_glob__func2();
void __golang fmt__ptr_ss_Token_func1(error_0 *&err);
// void __golang fmt_init();
// void __golang bytes_init();
void __golang sort_init();
void __golang strings_init();
// void __golang path_filepath_init();
// retval_80D3040 __golang io_ioutil_ReadFile(string filename);
void __golang io_ioutil_init();
void __cdecl main_main();
void __golang __noreturn main_openShop();
retval_80D3530 __golang main_stockUp();
retval_80D3960 __golang main_menu(_slice_main_item inv, _slice_main_item user, __int32 wallet);
retval_80D3F90 __golang main_sell(_slice_main_item user, __int32 wallet);
void __golang __noreturn main_get_flag();
void __golang main_check(error_0 e);
void __golang main_init();
void off_810450C(runtime_p *); // idb
void f(void);                  // idb

//-------------------------------------------------------------------------
// Data declarations

// extern _UNKNOWN loc_8090B16; weak
// extern _UNKNOWN loc_8090B18; weak
// extern _UNKNOWN loc_8090B1A; weak
// extern _UNKNOWN loc_8090FF4; weak
RTYPE RTYPE__ptr__slice_uint8 =
    {
        4,
        4,
        1775275685,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x2C24,
        NULL}; // weak
RTYPE RTYPE__ptr_bool =
    {
        4,
        4,
        1846407377,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1988,
        NULL}; // weak
RTYPE RTYPE__ptr_complex128 =
    {
        4,
        4,
        597961687,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x4480,
        NULL}; // weak
RTYPE RTYPE__ptr_complex64 =
    {
        4,
        4,
        2059495953,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x3C32,
        NULL}; // weak
RTYPE RTYPE__ptr_float32 =
    {
        4,
        4,
        536798801,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x2C2F,
        NULL}; // weak
RTYPE RTYPE__ptr_float64 =
    {
        4,
        4,
        -1168724717,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x2C3A,
        NULL}; // weak
RTYPE RTYPE__ptr_int =
    {
        4,
        4,
        623045607,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x62B,
        NULL}; // weak
RTYPE RTYPE__ptr_int16 =
    {
        4,
        4,
        -1603877355,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1EEB,
        NULL}; // weak
RTYPE RTYPE__ptr_int32 =
    {
        4,
        4,
        1800935206,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1EF4,
        NULL}; // weak
RTYPE RTYPE__ptr_int64 =
    {
        4,
        4,
        649594647,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1EFD,
        NULL}; // weak
RTYPE RTYPE__ptr_int8 =
    {
        4,
        4,
        1607131119,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1990,
        NULL}; // weak
RTYPE RTYPE__ptr_string =
    {
        4,
        4,
        1511480045,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x24D6,
        NULL}; // weak
RTYPE RTYPE__ptr_uint =
    {
        4,
        4,
        282851704,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1998,
        NULL}; // weak
RTYPE RTYPE__ptr_uint16 =
    {
        4,
        4,
        -292359122,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x24E0,
        NULL}; // weak
RTYPE RTYPE__ptr_uint32 =
    {
        4,
        4,
        13003987,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x24EA,
        NULL}; // weak
RTYPE RTYPE__ptr_uint64 =
    {
        4,
        4,
        506426616,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x24F4,
        NULL}; // weak
RTYPE RTYPE__ptr_uint8 =
    {
        4,
        4,
        -1697044824,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1F06,
        (void *)0x8CA0}; // weak
RTYPE RTYPE__ptr_uintptr =
    {
        4,
        4,
        -1769224866,
        0,
        '\x04',
        '\x04',
        KIND_DIRECTIFACE | KIND_PTR,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x2C71,
        NULL}; // weak
const runtime__type_0 RTYPE__slice_uint8_0 =
    {
        12u,
        4u,
        942571231u,
        2u,
        4u,
        4u,
        23u,
        &runtime_algarray,
        &runtime_gcbits__ptr_,
        11300,
        39008}; // idb
const runtime__type_0 RTYPE__0_main_item =
    {
        0u,
        0u,
        1171441650u,
        2u,
        4u,
        4u,
        145u,
        (runtime_typeAlg *)0x816BC08,
        &runtime_gcbits__ptr_,
        20208,
        0}; // idb
const runtime__type_0 RTYPE__0_string =
    {
        0u,
        0u,
        1236613318u,
        2u,
        4u,
        4u,
        145u,
        (runtime_typeAlg *)0x816BC08,
        &runtime_gcbits__ptr_,
        14903,
        0}; // idb
RTYPE RTYPE_bool =
    {
        1,
        0,
        335480517,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x01',
        '\x01',
        -127,
        (void *)0x816BC10,
        &runtime_gcbits__ptr_,
        (void *)0x1988,
        (void *)0x98E0}; // weak
RTYPE RTYPE_complex128_0 =
    {
        16,
        0,
        -1290120083,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        -112,
        (void *)0x816BC68,
        &runtime_gcbits__ptr_,
        (void *)0x4480,
        (void *)0x9960}; // weak
RTYPE RTYPE_complex64_0 =
    {
        8,
        0,
        2032468620,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_COMPLEX64 | 0x80,
        (void *)0x816BC60,
        &runtime_gcbits__ptr_,
        (void *)0x3C32,
        (void *)0x99A0}; // weak
RTYPE RTYPE_float32_0 =
    {
        4,
        0,
        -1329447213,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_FLOAT32 | 0x80,
        (void *)0x816BC50,
        &runtime_gcbits__ptr_,
        (void *)0x2C2F,
        (void *)0x9A20}; // weak
RTYPE RTYPE_float64_0 =
    {
        8,
        0,
        782401531,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_FLOAT64 | 0x80,
        (void *)0x816BC58,
        &runtime_gcbits__ptr_,
        (void *)0x2C3A,
        (void *)0x9A60}; // weak
const runtime__type_0 RTYPE_int =
    {
        4u,
        0u,
        4149441018u,
        7u,
        4u,
        4u,
        130u,
        (runtime_typeAlg *)0x816BC20,
        &runtime_gcbits__ptr_,
        1579,
        40288}; // idb
RTYPE RTYPE_int16_0 =
    {
        2,
        0,
        -321552178,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x02',
        '\x02',
        -124,
        (void *)0x816BC18,
        &runtime_gcbits__ptr_,
        (void *)0x1EEB,
        (void *)0x9DA0}; // weak
RTYPE RTYPE_int32_0 =
    {
        4,
        0,
        -1146273534,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_INT32 | 0x80,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1EF4,
        (void *)0x9DE0}; // weak
RTYPE RTYPE_int64_0 =
    {
        8,
        0,
        -1774216193,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_INT64 | 0x80,
        (void *)0x816BC28,
        &runtime_gcbits__ptr_,
        (void *)0x1EFD,
        (void *)0x9E20}; // weak
RTYPE RTYPE_int8_0 =
    {
        1,
        0,
        -871972825,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x01',
        '\x01',
        KIND_INT8 | 0x80,
        (void *)0x816BC10,
        &runtime_gcbits__ptr_,
        (void *)0x1990,
        (void *)0x9E60};                                             // weak
const interface_ RTYPE_string_0 = {(runtime__type_0 *)8, (void *)4}; // idb
RTYPE RTYPE_uint_0 =
    {
        4,
        0,
        -709331182,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_UINT | 0x80,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x1998,
        (void *)0xC6A0}; // weak
RTYPE RTYPE_uint16_0 =
    {
        2,
        0,
        -269349216,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x02',
        '\x02',
        KIND_UINT16 | 0x80,
        (void *)0x816BC18,
        &runtime_gcbits__ptr_,
        (void *)0x24E0,
        (void *)0xC6E0}; // weak
const runtime__type_0 RTYPE_uint32_0 =
    {
        4u,
        0u,
        3494570045u,
        7u,
        4u,
        4u,
        138u,
        (runtime_typeAlg *)0x816BC20,
        &runtime_gcbits__ptr_,
        9450,
        50976}; // idb
RTYPE RTYPE_uint64_0 =
    {
        8,
        0,
        -2043572946,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_UINT64 | 0x80,
        (void *)0x816BC28,
        &runtime_gcbits__ptr_,
        (void *)0x24F4,
        (void *)0xC760}; // weak
const runtime__type_0 RTYPE_uint8_0 =
    {
        1u,
        0u,
        1715356255u,
        7u,
        1u,
        1u,
        136u,
        (runtime_typeAlg *)0x816BC10,
        &runtime_gcbits__ptr_,
        7942,
        51104}; // idb
RTYPE RTYPE_uintptr_0 =
    {
        4,
        0,
        -1119168622,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_UINTPTR | 0x80,
        (void *)0x816BC20,
        &runtime_gcbits__ptr_,
        (void *)0x2C71,
        (void *)0xC7E0};                                                            // weak
const interface_ RTYPE__ptr_reflect_ValueError = {(runtime__type_0 *)4, (void *)4}; // idb
RTYPE RTYPE_fmt_Scanner =
    {
        8,
        8,
        -708060864,
        TFLAG_NAMED | TFLAG_EXTRASTAR | TFLAG_UNCOMMON,
        '\x04',
        '\x04',
        KIND_INTERFACE,
        (void *)0x816BC40,
        &unk_810DF36,
        (void *)0x4B02,
        (void *)0x9B60}; // weak
const runtime__type_0 RTYPE_fmt_scanError_1 =
    {
        8u,
        8u,
        1857951244u,
        7u,
        4u,
        4u,
        25u,
        (runtime_typeAlg *)0x816BC40,
        &unk_810DF36,
        21433,
        40032};                                                                  // idb
const interface_ RTYPE_runtime_plainError_0 = {(runtime__type_0 *)8, (void *)4}; // idb
const runtime__type_0 RTYPE_reflect_ValueError_1 =
    {
        12u,
        4u,
        2446902162u,
        7u,
        4u,
        4u,
        25u,
        &off_80D5B78,
        &runtime_gcbits__ptr_,
        27849,
        85920}; // idb
const runtime__type_0 RTYPE_main_item_1 =
    {
        16u,
        4u,
        1240724441u,
        7u,
        4u,
        4u,
        25u,
        &off_80D5B50,
        &runtime_gcbits__ptr_,
        15475,
        40928}; // idb
const runtime__type_0 RTYPE_strconv_NumError_1 =
    {
        24u,
        24u,
        2949425870u,
        7u,
        4u,
        4u,
        25u,
        &off_80D5C50,
        &unk_810DF50,
        25487,
        87456}; // idb
const runtime__type_0 RTYPE_fmt_ss_1 =
    {
        44u,
        12u,
        131439712u,
        7u,
        4u,
        4u,
        25u,
        &runtime_algarray,
        &unk_810DF3A,
        9410,
        147744}; // idb
const runtime__type_0 RTYPE_fmt_pp_1 =
    {
        128u,
        36u,
        777436576u,
        7u,
        4u,
        4u,
        25u,
        &runtime_algarray,
        &unk_810DF80,
        9400,
        141824}; // idb
const runtime__type_0 RTYPE__ptr_fmt_pp =
    {
        4u,
        4u,
        2274331072u,
        1u,
        4u,
        4u,
        54u,
        (runtime_typeAlg *)0x816BC20,
        &runtime_gcbits__ptr_,
        9400,
        0}; // idb
const runtime__type_0 RTYPE__ptr_fmt_ss =
    {
        4u,
        4u,
        2512240372u,
        1u,
        4u,
        4u,
        54u,
        (runtime_typeAlg *)0x816BC20,
        &runtime_gcbits__ptr_,
        9410,
        0}; // idb
const runtime__type_0 RTYPE_reflect_Value_1 =
    {
        12u,
        8u,
        1342970556u,
        7u,
        4u,
        4u,
        25u,
        &off_80D5CF8,
        &unk_810DF36,
        21484,
        160864};                                                                                                        // idb
int(__golang *off_8104500)() = &runtime_freeStackSpans;                                                                 // weak
string main_statictmp_0 = {&aWelcomeToTheMa, 22};                                                                       // idb
string main_statictmp_1 = {&asc_80FF75E, 21};                                                                           // idb
string main_statictmp_10 = {&aWhatDoYouWantT, 26};                                                                      // idb
string main_statictmp_11 = {&aHowMany, 9};                                                                              // idb
string main_statictmp_12 = {&aHeyYouDonTHave, 69};                                                                      // idb
string main_statictmp_13 = {&aInvalidInput, 14};                                                                        // idb
string main_statictmp_14 = {&aFlagIs, 9};                                                                               // idb
string main_statictmp_2 = {&aItemPriceCount, 18};                                                                       // idb
string main_statictmp_3 = {&a3SellAnItem, 16};                                                                          // idb
string main_statictmp_4 = {&a4Exit, 8};                                                                                 // idb
string main_statictmp_5 = {&aChooseAnOption, 18};                                                                       // idb
string main_statictmp_6 = {&aHowManyDoYouWa, 28};                                                                       // idb
string main_statictmp_7 = {&aNotEnoughMoney, 17};                                                                       // idb
string main_statictmp_8 = {&aYourInventory, 14};                                                                        // idb
string main_statictmp_9 = {&aEmpty, 5};                                                                                 // idb
runtime_plainError runtime_statictmp_21 = {&aArgSizeToRefle, 38};                                                       // idb
string strconv_statictmp_5 = {&aStrconvIllegal, 48};                                                                    // idb
runtime__type_0 *go_itab__ptr_strconv_NumError_comma_error[2] = {&RTYPE_error_1, &RTYPE__ptr_strconv_NumError};         // weak
RTYPE *go_itab__ptr_fmt_ss_comma_fmt_ScanState = &RTYPE_fmt_ScanState;                                                  // weak
runtime__type_0 *go_itab__ptr_reflect_rtype_comma_reflect_Type[2] = {&RTYPE_reflect_Type_1, &RTYPE__ptr_reflect_rtype}; // weak
bool strconv_optimize = true;                                                                                           // idb
uint32 runtime_worldsema = 1u;                                                                                          // idb
uint64 runtime_heapminimum = 4194304uLL;                                                                                // idb
strconv_floatInfo_0 strconv_float32info = {23u, 8u, -127};                                                              // idb
strconv_floatInfo strconv_float64info = {52u, 11u, -1023};                                                              // idb
float64 runtime_fastlog2Table[33] =
    {
        0.0,
        0.0443941193584535,
        0.08746284125033943,
        0.1292830169449665,
        0.1699250014423125,
        0.2094533656289499,
        0.2479275134435855,
        0.2854022188622484,
        0.3219280948873623,
        0.3575520046180837,
        0.3923174227787604,
        0.4262647547020979,
        0.4594316186372973,
        0.4918530963296748,
        0.5235619560570128,
        0.5545888516776374,
        0.5849625007211563,
        0.6147098441152082,
        0.6438561897747247,
        0.6724253419714956,
        0.7004397181410922,
        0.7279204545631992,
        0.7548875021634686,
        0.7813597135246596,
        0.8073549220576042,
        0.8328900141647417,
        0.8579809951275721,
        0.8826430493618412,
        0.9068905956085185,
        0.9307373375628862,
        0.9541963103868752,
        0.9772799234999164,
        1.0};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // idb
error_0 runtime_divideError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_44};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb
error_0 runtime_floatError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_46};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
error runtime_indexError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_47};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // idb
error_0 runtime_memoryError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_43};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb
error_0 runtime_overflowError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_45};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // idb
error_0 runtime_sliceError = {&go_itab_runtime_errorString_comma_error, &runtime_statictmp_48};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
_slice_float32 strconv_float32pow10 = {&strconv_statictmp_9, 11, 11};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // idb
_slice_float64 strconv_float64pow10 = {&strconv_statictmp_8, 23, 23};                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // idb
error_0 io_EOF;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
error_0 io_ErrUnexpectedEOF;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       // idb
error_0 strconv_ErrRange;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // idb
error_0 strconv_ErrSyntax;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // idb
_slice__ptr_runtime_p runtime_allp;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // idb
_slice_string runtime_argslice;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
_slice_string runtime_envs;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // idb
runtime_sweepdata runtime_sweep;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb
runtime_schedt runtime_sched;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // idb
struct__runtime_full_runtime_lfstack_runtime_empty_runtime_lfstack_runtime_pad0__64_uint8_runtime_wbufSpans_struct__runtime_lock_runtime_mutex_runtime_free_runtime_mSpanList_runtime_busy_runtime_mSpanList____uint32_runtime_bytesMarked_uint64_runtime_markrootNext_uint32_runtime_markrootJobs_uint32_runtime_nproc_uint32_runtime_tstart_int64_runtime_nwait_uint32_runtime_ndone_uint32_runtime_alldone_runtime_note_runtime_helperDrainBlock_bool_runtime_nFlushCacheRoots_int_runtime_nDataRoots_int_runtime_nBSSRoots_int_runtime_nSpanRoots_int_runtime_nStackRoots_int_runtime_markrootDone_bool_runtime_startSema_uint32_runtime_markDoneSema_uint32_runtime_bgMarkReady_runtime_note_runtime_bgMarkDone_uint32_runtime_mode_runtime_gcMode_runtime_userForced_bool_runtime_totaltime_int64_runtime_initialHeapLive_uint64_runtime_assistQueue_struct__runtime_lock_runtime_mutex_runtime_head_runtime_guintptr_runtime_tail_runtime_guintptr__runtime_sweepWaiters_struct__runtime_lock_runtime_mutex_runtime_head_runtime_guintptr__runtime_cycles_uint32_runtime_stwprocs_int32_runtime_maxprocs_int32_runtime_tSweepTerm_int64_runtime_tMark_int64_runtime_tMarkTerm_int64_runtime_tEnd_int64_runtime_pauseNS_int64_runtime_pauseStart_int64_runtime_heap0_uint64_runtime_heap1_uint64_runtime_heap2_uint64_runtime_heapGoal_uint64_ runtime_work; // idb
runtime_mheap runtime_mheap_;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      // idb
int dword_8170270;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // weak
uint32 ptr;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        // idb
_DWORD dword_8170294[11];                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // weak
__int64 qword_81702C0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             // weak
uint64 qword_81702C8;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // idb
int dword_81702D8;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // weak
int dword_81702DC;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 // weak
double dbl_81702E0;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                // weak
struct__runtime_lock_runtime_mutex_runtime_lockOwner__ptr_runtime_g_runtime_enabled_bool_runtime_shutdown_bool_runtime_headerWritten_bool_runtime_footerWritten_bool_runtime_shutdownSema_uint32_runtime_seqStart_uint64_runtime_ticksStart_int64_runtime_ticksEnd_int64_runtime_timeStart_int64_runtime_timeEnd_int64_runtime_seqGC_uint64_runtime_reading_runtime_traceBufPtr_runtime_empty_runtime_traceBufPtr_runtime_fullHead_runtime_traceBufPtr_runtime_fullTail_runtime_traceBufPtr_runtime_reader_runtime_guintptr_runtime_stackTab_runtime_traceStackTable_runtime_strings_map_string_uint64_runtime_stringSeq_uint64_runtime_markWorkerLabels__3_uint64_runtime_bufLock_runtime_mutex_runtime_buf_runtime_traceBufPtr_ runtime_trace;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb
uint8 io_ioutil_initdone_;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // idb
uint8 main_initdone_;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // idb
bool runtime_gcBlackenPromptly;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
uint8 sort_initdone_;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              // idb
uint8 strings_initdone_;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // idb
uint32 runtime_gcBlackenEnabled;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb
int32 runtime_gcpercent;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           // idb
uint32 runtime_gcphase;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            // idb
int32 runtime_gomaxprocs;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          // idb
int64 runtime_runtimeInitTime;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     // idb
struct__runtime_enabled_bool_runtime_pad__3_uint8_runtime_needed_bool_runtime_cgo_bool_runtime_alignme_uint64_ runtime_writeBarrier;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               // idb
struct__runtime_allocfreetrace_int32_runtime_cgocheck_int32_runtime_efence_int32_runtime_gccheckmark_int32_runtime_gcpacertrace_int32_runtime_gcshrinkstackoff_int32_runtime_gcrescanstacks_int32_runtime_gcstoptheworld_int32_runtime_gctrace_int32_runtime_invalidptr_int32_runtime_sbrk_int32_runtime_scavenge_int32_runtime_scheddetail_int32_runtime_schedtrace_int32_ runtime_debug;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         // idb
runtime_gcControllerState runtime_gcController;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    // idb
runtime_mstats runtime_memstats;                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   // idb

//----- (08049240) --------------------------------------------------------
// sync/atomic.LoadUint32
void __golang sync_atomic_LoadUint32()
{
  ;
}

//----- (080492E0) --------------------------------------------------------
// runtime/internal/atomic.Load
uint32 __golang runtime_internal_atomic_Load(uint32 *ptr)
{
  return *ptr;
}

//----- (080492F0) --------------------------------------------------------
// runtime/internal/atomic.Loadp
void *__golang runtime_internal_atomic_Loadp(void *ptr)
{
  return *(void **)ptr;
}

//----- (080494E0) --------------------------------------------------------
// runtime/internal/atomic.StorepNoWB
void __golang runtime_internal_atomic_StorepNoWB()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1;           // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (080494F0) --------------------------------------------------------
// runtime/internal/atomic.Store
void __golang runtime_internal_atomic_Store()
{
  volatile __int32 *v0; // [esp+4h] [ebp+4h]
  __int32 v1;           // [esp+8h] [ebp+8h]

  _InterlockedExchange(v0, v1);
}

//----- (08049710) --------------------------------------------------------
// runtime.f32hash
uintptr __golang runtime_f32hash(void *p, uintptr h)
{
  if (*(float *)p == 0.0)
    return -1027967283 * (h ^ 0xAA7F8EA9);
  else
    return runtime_memhash(p, h, 4u);
}

//----- (08049810) --------------------------------------------------------
// runtime.f64hash
uintptr __golang runtime_f64hash(void *p, uintptr h)
{
  if (*(double *)p == 0.0)
    return -1027967283 * (h ^ 0xAA7F8EA9);
  else
    return runtime_memhash(p, h, 8u);
}

//----- (08049D70) --------------------------------------------------------
// runtime.f32equal
bool __golang runtime_f32equal(void *p, void *q)
{
  return *(float *)p == *(float *)q;
}

//----- (08049DC0) --------------------------------------------------------
// runtime.f64equal
bool __golang runtime_f64equal(void *p, void *q)
{
  return *(double *)p == *(double *)q;
}

//----- (08049E10) --------------------------------------------------------
// runtime.c64equal
bool __golang runtime_c64equal(void *p, void *q)
{
  return *((float *)p + 1) == *((float *)q + 1) && *(float *)p == *(float *)q;
}

//----- (08049E80) --------------------------------------------------------
// runtime.c128equal
bool __golang runtime_c128equal(void *p, void *q)
{
  return *((double *)p + 1) == *((double *)q + 1) && *(double *)p == *(double *)q;
}

//----- (0804CCB0) --------------------------------------------------------
// runtime.printany
void __golang runtime_printany(interface_ i)
{
  uint32 hash;          // ecx
  __int16 *data;        // edx
  char v3;              // bl
  bool v4;              // zf
  unsigned __int8 v5;   // bl
  bool v6;              // zf
  unsigned int v7;      // ebx
  unsigned int v8;      // ebp
  bool v9;              // zf
  uint32 v10;           // ecx
  unsigned int v11;     // ebx
  bool v12;             // zf
  int v13;              // ebx
  bool v14;             // zf
  uintptr v15;          // ecx
  char v16;             // bl
  bool v17;             // zf
  uint32 v18;           // ecx
  unsigned int v19;     // ebx
  bool v20;             // zf
  __int32 v21;          // ecx
  unsigned int v22;     // ebx
  __int16 v23;          // bx
  unsigned __int16 v24; // bx
  __int32 v25;          // ecx
  string x;             // [esp+0h] [ebp-88h]
  string xa;            // [esp+0h] [ebp-88h]
  complex128 xb;        // [esp+0h] [ebp-88h]
  complex128 xc;        // [esp+0h] [ebp-88h]
  string xd;            // [esp+0h] [ebp-88h]
  string v31;           // [esp+8h] [ebp-80h]
  float v_real_0;       // [esp+18h] [ebp-70h]
  uint32 v_lo_0;        // [esp+20h] [ebp-68h]
  __int32 v_len;        // [esp+24h] [ebp-64h]
  float v_imag;         // [esp+28h] [ebp-60h]
  float v_8;            // [esp+38h] [ebp-50h]
  uintptr v_7;          // [esp+3Ch] [ebp-4Ch]
  uint32 v_5;           // [esp+44h] [ebp-44h]
  __int32 v_4;          // [esp+48h] [ebp-40h]
  double v_real;        // [esp+58h] [ebp-30h]
  double v_imag_0;      // [esp+60h] [ebp-28h]
  double v_9;           // [esp+68h] [ebp-20h]

  if (i._type)
  {
    hash = i._type->hash;
    if (hash > 0xB31A546D)
    {
      if (hash > 0xD04AE83D)
      {
        if (hash > 0xE0FF5CB4)
        {
          if (hash == -321552178)
          {
            data = (__int16 *)i.data;
            if (&RTYPE_int16_0 == (RTYPE *)i._type)
              v23 = *(_WORD *)i.data;
            else
              v23 = 0;
            if (&RTYPE_int16_0 == (RTYPE *)i._type)
            {
              runtime_printlock();
              runtime_printint(v23);
              runtime_printunlock();
              return;
            }
          }
          else
          {
            data = (__int16 *)i.data;
          }
          if (hash == -269349216 && (&RTYPE_uint16_0 != (RTYPE *)i._type ? (v24 = 0) : (v24 = *data), &RTYPE_uint16_0 == (RTYPE *)i._type))
          {
            runtime_printlock();
            runtime_printuint(v24);
            runtime_printunlock();
          }
          else
          {
            if (hash != -145526278)
              goto LABEL_14;
            v25 = &RTYPE_int == i._type ? *(_DWORD *)data : 0;
            if (&RTYPE_int != i._type)
              goto LABEL_14;
            v_4 = v25;
            runtime_printlock();
            runtime_printint(v_4);
            runtime_printunlock();
          }
        }
        else
        {
          if (hash == -709331182)
          {
            data = (__int16 *)i.data;
            if (&RTYPE_uint_0 == (RTYPE *)i._type)
              v19 = *(_DWORD *)i.data;
            else
              v19 = 0;
            if (&RTYPE_uint_0 == (RTYPE *)i._type)
            {
              runtime_printlock();
              runtime_printuint(v19);
              runtime_printunlock();
              return;
            }
            v20 = 0;
          }
          else
          {
            v20 = hash == -520135500;
            data = (__int16 *)i.data;
          }
          if (!v20)
            goto LABEL_14;
          if (&RTYPE_string_0 == (const interface_ *)i._type)
          {
            v21 = *((_DWORD *)data + 1);
            v22 = *(_DWORD *)data;
          }
          else
          {
            v22 = 0;
            v21 = 0;
          }
          if (&RTYPE_string_0 != (const interface_ *)i._type)
            goto LABEL_14;
          v_len = v21;
          runtime_printlock();
          runtime_printstring((string)__PAIR64__(v_len, v22));
          runtime_printunlock();
        }
      }
      else if (hash > 0xBD4AD792)
      {
        if (hash == -871972825)
        {
          data = (__int16 *)i.data;
          if (&RTYPE_int8_0 == (RTYPE *)i._type)
            v16 = *(_BYTE *)i.data;
          else
            v16 = 0;
          if (&RTYPE_int8_0 == (RTYPE *)i._type)
          {
            runtime_printlock();
            runtime_printint(v16);
            runtime_printunlock();
            return;
          }
          v17 = 0;
        }
        else
        {
          v17 = hash == -800397251;
          data = (__int16 *)i.data;
        }
        if (!v17)
          goto LABEL_14;
        v18 = &RTYPE_uint32_0 == i._type ? *(_DWORD *)data : 0;
        if (&RTYPE_uint32_0 != i._type)
          goto LABEL_14;
        v_5 = v18;
        runtime_printlock();
        runtime_printuint(v_5);
        runtime_printunlock();
      }
      else
      {
        if (hash == -1146273534)
        {
          data = (__int16 *)i.data;
          if (&RTYPE_int32_0 == (RTYPE *)i._type)
            v13 = *(_DWORD *)i.data;
          else
            v13 = 0;
          if (&RTYPE_int32_0 == (RTYPE *)i._type)
          {
            runtime_printlock();
            runtime_printint(v13);
            runtime_printunlock();
            return;
          }
          v14 = 0;
        }
        else
        {
          v14 = hash == -1119168622;
          data = (__int16 *)i.data;
        }
        if (!v14)
          goto LABEL_14;
        v15 = &RTYPE_uintptr_0 == (RTYPE *)i._type ? *(_DWORD *)data : 0;
        if (&RTYPE_uintptr_0 != (RTYPE *)i._type)
          goto LABEL_14;
        v_7 = v15;
        runtime_printlock();
        runtime_printuint(v_7);
        runtime_printunlock();
      }
    }
    else if (hash > 0x7925028C)
    {
      if (hash > 0x963F9BFF)
      {
        if (hash == -1329447213)
        {
          data = (__int16 *)i.data;
          if (&RTYPE_float32_0 == (RTYPE *)i._type)
            v_8 = *(float *)i.data;
          else
            v_8 = 0.0;
          if (&RTYPE_float32_0 == (RTYPE *)i._type)
          {
            runtime_printlock();
            runtime_printfloat(v_8);
            runtime_printunlock();
            return;
          }
          v12 = 0;
        }
        else
        {
          v12 = hash == -1290120083;
          data = (__int16 *)i.data;
        }
        if (!v12)
          goto LABEL_14;
        if (&RTYPE_complex128_0 == (RTYPE *)i._type)
        {
          v_imag_0 = *((double *)data + 1);
          v_real = *(double *)data;
        }
        else
        {
          v_imag_0 = 0.0;
          v_real = 0.0;
        }
        if (&RTYPE_complex128_0 != (RTYPE *)i._type)
          goto LABEL_14;
        runtime_printlock();
        xc.real = v_real;
        xc.imag = v_imag_0;
        runtime_printcomplex(xc);
        runtime_printunlock();
      }
      else
      {
        if (hash == -2043572946)
        {
          data = (__int16 *)i.data;
          if (&RTYPE_uint64_0 == (RTYPE *)i._type)
          {
            v7 = *((_DWORD *)i.data + 1);
            v8 = *(_DWORD *)i.data;
          }
          else
          {
            v7 = 0;
            v8 = 0;
          }
          if (&RTYPE_uint64_0 == (RTYPE *)i._type)
          {
            runtime_printlock();
            runtime_printuint(__PAIR64__(v7, v8));
            runtime_printunlock();
            return;
          }
          v9 = 0;
        }
        else
        {
          v9 = hash == -1774216193;
          data = (__int16 *)i.data;
        }
        if (!v9)
          goto LABEL_14;
        if (&RTYPE_int64_0 == (RTYPE *)i._type)
        {
          v10 = *(_DWORD *)data;
          v11 = *((_DWORD *)data + 1);
        }
        else
        {
          v11 = 0;
          v10 = 0;
        }
        if (&RTYPE_int64_0 != (RTYPE *)i._type)
          goto LABEL_14;
        v_lo_0 = v10;
        runtime_printlock();
        runtime_printint(__SPAIR64__(v11, v_lo_0));
        runtime_printunlock();
      }
    }
    else if (hash > 0x2EA27FFB)
    {
      if (hash == 1715356255)
      {
        data = (__int16 *)i.data;
        if (&RTYPE_uint8_0 == i._type)
          v5 = *(_BYTE *)i.data;
        else
          v5 = 0;
        if (&RTYPE_uint8_0 == i._type)
        {
          runtime_printlock();
          runtime_printuint(v5);
          runtime_printunlock();
          return;
        }
        v6 = 0;
      }
      else
      {
        v6 = hash == 2032468620;
        data = (__int16 *)i.data;
      }
      if (!v6)
        goto LABEL_14;
      if (&RTYPE_complex64_0 == (RTYPE *)i._type)
      {
        v_real_0 = *(float *)data;
        v_imag = *((float *)data + 1);
      }
      else
      {
        v_real_0 = 0.0;
        v_imag = 0.0;
      }
      if (&RTYPE_complex64_0 != (RTYPE *)i._type)
        goto LABEL_14;
      runtime_printlock();
      xb.real = v_real_0;
      xb.imag = v_imag;
      runtime_printcomplex(xb);
      runtime_printunlock();
    }
    else
    {
      if (hash == 335480517)
      {
        data = (__int16 *)i.data;
        if (&RTYPE_bool == (RTYPE *)i._type)
          v3 = *(_BYTE *)i.data;
        else
          v3 = 0;
        if (&RTYPE_bool == (RTYPE *)i._type)
        {
          runtime_printlock();
          runtime_printbool(v3);
          runtime_printunlock();
          return;
        }
        v4 = 0;
      }
      else
      {
        v4 = hash == 782401531;
        data = (__int16 *)i.data;
      }
      if (!v4 || (&RTYPE_float64_0 != (RTYPE *)i._type ? (v_9 = 0.0) : (v_9 = *(double *)data),
                  &RTYPE_float64_0 != (RTYPE *)i._type))
      {
      LABEL_14:
        v31 = runtime_typestring((interface_)__PAIR64__((unsigned int)data, (unsigned int)i._type));
        runtime_printlock();
        x.str = (uint8 *)"(";
        x.len = 1;
        runtime_printstring(x);
        runtime_printstring(v31);
        xa.str = (uint8 *)") ";
        xa.len = 2;
        runtime_printstring(xa);
        runtime_printeface(i);
        runtime_printunlock();
        return;
      }
      runtime_printlock();
      runtime_printfloat(v_9);
      runtime_printunlock();
    }
  }
  else
  {
    runtime_printlock();
    xd.str = (uint8 *)"nil";
    xd.len = 3;
    runtime_printstring(xd);
    runtime_printunlock();
  }
}
// 80E7C40: using guessed type RTYPE RTYPE_bool;
// 80E7CC0: using guessed type RTYPE RTYPE_complex128_0;
// 80E7D00: using guessed type RTYPE RTYPE_complex64_0;
// 80E7D40: using guessed type RTYPE RTYPE_float32_0;
// 80E7D80: using guessed type RTYPE RTYPE_float64_0;
// 80E8140: using guessed type RTYPE RTYPE_int16_0;
// 80E8180: using guessed type RTYPE RTYPE_int32_0;
// 80E81C0: using guessed type RTYPE RTYPE_int64_0;
// 80E8200: using guessed type RTYPE RTYPE_int8_0;
// 80E8840: using guessed type RTYPE RTYPE_uint_0;
// 80E8880: using guessed type RTYPE RTYPE_uint16_0;
// 80E8900: using guessed type RTYPE RTYPE_uint64_0;
// 80E8980: using guessed type RTYPE RTYPE_uintptr_0;
// 80FCDF6: using guessed type char asc_80FCDF6;

//----- (0804DAD0) --------------------------------------------------------
// runtime.float64frombits
float64 __golang runtime_float64frombits(uint64 b)
{
  return *(double *)&b;
}

//----- (08054A30) --------------------------------------------------------
// runtime.fastexprand
int32 __golang runtime_fastexprand(__int32 mean)
{
  __int32 v1;          // eax
  int v2;              // ecx
  int v3;              // edx
  unsigned int v4;     // ebx
  int v5;              // edx
  unsigned __int64 v6; // kr00_8
  int v7;              // ebx
  long double v8;      // fst7
  int64 y;             // [esp+0h] [ebp-44h]
  double y_4;          // [esp+4h] [ebp-40h]
  int v11;             // [esp+10h] [ebp-34h]
  double qlog;         // [esp+14h] [ebp-30h]
  float64 v13;         // [esp+1Ch] [ebp-28h]
  float64 v14;         // [esp+24h] [ebp-20h]
  double v15;          // [esp+2Ch] [ebp-18h]
  float64 v16;         // [esp+3Ch] [ebp-8h]
  __int32 meana;       // [esp+48h] [ebp+4h]

  v1 = mean;
  if (mean <= 117440512)
  {
    if (!mean)
      return 0;
  }
  else
  {
    v1 = 117440512;
  }
  meana = v1;
  v2 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  v3 = *(_DWORD *)(v2 + 176);
  v4 = *(_DWORD *)(v2 + 180);
  *(_DWORD *)(v2 + 176) = v4;
  *(_DWORD *)(v2 + 180) = v3 ^ (v3 << 17) ^ v4 ^ ((v3 ^ (unsigned int)(v3 << 17)) >> 7) ^ HIWORD(v4);
  runtime_uint32tofloat64();
  v15 = y_4;
  v5 = (HIDWORD(v15) >> 20) & 0x7FF;
  v7 = (HIDWORD(v15) >> 15) & 0x1F;
  v6 = (unsigned int)v7 + 1LL;
  if (v6 >= 0x21)
    runtime_panicindex();
  v11 = *(__int64 *)&y_4 >> 27;
  v13 = runtime_fastlog2Table[v7];
  v14 = runtime_fastlog2Table[(_DWORD)v6];
  LODWORD(y) = v5 - 1023;
  HIDWORD(y) = __CFADD__(v5, -1023) - 1;
  v16 = runtime_int64tofloat64(y);
  v8 = v16 + v13 + 0.00000095367431640625 * ((v14 - v13) * runtime_uint64tofloat64(v11 & 0xFFFFFLL)) - 26.0;
  qlog = v8;
  if (v8 > 0.0)
    qlog = 0.0;
  return (int)(qlog * ((long double)meana * -0.6931471805599453)) + 1;
}
// 8054AB9: variable 'y_4' is possibly undefined

//----- (08059B30) --------------------------------------------------------
// runtime.gcinit
void __golang runtime_gcinit()
{
  int32 y;    // [esp+0h] [ebp-10h]
  float64 v1; // [esp+8h] [ebp-8h]

  ptr = 1;
  runtime_memstats.triggerRatio = 0.875;
  v1 = runtime_uint64tofloat64(runtime_heapminimum);
  runtime_memstats.heap_marked = runtime_float64touint64(v1 / (runtime_memstats.triggerRatio + 1.0));
  y = runtime_readgogc();
  runtime_debug_setGCPercent(y);
  runtime_work.startSema = 1;
  runtime_work.markDoneSema = 1;
}

//----- (08059EA0) --------------------------------------------------------
// runtime.(*gcControllerState).startCycle
void __golang runtime__ptr_gcControllerState_startCycle(_ptr_runtime_gcControllerState c)
{
  uint64 heap_marked;                  // kr00_8
  long double v2;                      // fst7
  long double v3;                      // fst7
  runtime_gcControllerState_1 *v4;     // eax
  runtime_p **array;                   // ecx
  __int32 len;                         // edx
  __int32 i;                           // ebx
  runtime_p *v8;                       // ebp
  int dedicatedMarkWorkersNeeded;      // ecx
  int dedicatedMarkWorkersNeeded_high; // edx
  string n;                            // [esp+0h] [ebp-60h]
  string na;                           // [esp+0h] [ebp-60h]
  string nb;                           // [esp+0h] [ebp-60h]
  string nc;                           // [esp+0h] [ebp-60h]
  string nd;                           // [esp+0h] [ebp-60h]
  string ne;                           // [esp+0h] [ebp-60h]
  int64_0 da;                          // [esp+8h] [ebp-58h]
  float64 db;                          // [esp+8h] [ebp-58h]
  float64 d;                           // [esp+8h] [ebp-58h]
  int64_0 v;                           // [esp+18h] [ebp-48h]
  uint64 next_gc;                      // [esp+20h] [ebp-40h]
  uint64 initialHeapLive;              // [esp+28h] [ebp-38h]
  uint64 heap_scan;                    // [esp+30h] [ebp-30h]
  double totalUtilizationGoal;         // [esp+40h] [ebp-20h]
  float64 fractionalUtilizationGoal;   // [esp+50h] [ebp-10h]
  float64 assistWorkPerByte;           // [esp+58h] [ebp-8h]

  c->scanWork = 0LL;
  c->bgScanCredit = 0LL;
  c->assistTime = 0LL;
  c->dedicatedMarkTime = 0LL;
  c->fractionalMarkTime = 0LL;
  c->idleMarkTime = 0LL;
  if (HIDWORD(runtime_memstats.gc_trigger) < HIDWORD(runtime_heapminimum) || HIDWORD(runtime_memstats.gc_trigger) == HIDWORD(runtime_heapminimum) && LODWORD(runtime_memstats.gc_trigger) <= (unsigned int)runtime_heapminimum)
  {
    d = runtime_uint64tofloat64(runtime_memstats.gc_trigger);
    runtime_memstats.heap_marked = runtime_float64touint64(d / (runtime_memstats.triggerRatio + 1.0));
  }
  heap_marked = runtime_memstats.heap_marked;
  runtime_memstats.next_gc = heap_marked + runtime_uint64div(runtime_gcpercent * runtime_memstats.heap_marked, 0x64uLL);
  if (runtime_gcpercent < 0)
    runtime_memstats.next_gc = -1LL;
  if (HIDWORD(runtime_memstats.next_gc) < (runtime_memstats.heap_live + 0x100000) >> 32 || LODWORD(runtime_memstats.next_gc) < LODWORD(runtime_memstats.heap_live) + 0x100000 && HIDWORD(runtime_memstats.next_gc) == (runtime_memstats.heap_live + 0x100000) >> 32)
  {
    runtime_memstats.next_gc = runtime_memstats.heap_live + 0x100000;
  }
  v2 = (long double)runtime_gomaxprocs * 0.25;
  totalUtilizationGoal = v2;
  da = runtime_float64toint64(v2 + 0.5);
  c->dedicatedMarkWorkersNeeded = da;
  v3 = runtime_int64tofloat64(da) / (double)v2 - 1.0;
  if (v3 < -0.3 || (double)v3 > 0.3)
  {
    if (runtime_int64tofloat64(c->dedicatedMarkWorkersNeeded) > (long double)totalUtilizationGoal)
    {
      dedicatedMarkWorkersNeeded = c->dedicatedMarkWorkersNeeded;
      dedicatedMarkWorkersNeeded_high = HIDWORD(c->dedicatedMarkWorkersNeeded);
      LODWORD(c->dedicatedMarkWorkersNeeded) = dedicatedMarkWorkersNeeded - 1;
      HIDWORD(c->dedicatedMarkWorkersNeeded) = (dedicatedMarkWorkersNeeded != 0) + dedicatedMarkWorkersNeeded_high - 1;
    }
    db = runtime_int64tofloat64(c->dedicatedMarkWorkersNeeded);
    v4 = c;
    c->fractionalUtilizationGoal = (totalUtilizationGoal - db) / (long double)runtime_gomaxprocs;
  }
  else
  {
    v4 = c;
    c->fractionalUtilizationGoal = 0.0;
  }
  array = runtime_allp.array;
  len = runtime_allp.len;
  for (i = 0; i < len; ++i)
  {
    v8 = array[i];
    LODWORD(v8->gcAssistTime) = 0;
    HIDWORD(v8->gcAssistTime) = 0;
    LODWORD(v8->gcFractionalMarkTime) = 0;
    HIDWORD(v8->gcFractionalMarkTime) = 0;
  }
  runtime__ptr_gcControllerState_revise(v4);
  if (runtime_debug.gcpacertrace > 0)
  {
    assistWorkPerByte = c->assistWorkPerByte;
    heap_scan = runtime_memstats.heap_scan;
    initialHeapLive = runtime_work.initialHeapLive;
    next_gc = runtime_memstats.next_gc;
    v = c->dedicatedMarkWorkersNeeded;
    fractionalUtilizationGoal = c->fractionalUtilizationGoal;
    runtime_printlock();
    n.str = (uint8 *)"pacer: assist ratio=";
    n.len = 20;
    runtime_printstring(n);
    runtime_printfloat(assistWorkPerByte);
    na.str = (uint8 *)" (scan ";
    na.len = 7;
    runtime_printstring(na);
    runtime_printuint(heap_scan >> 20);
    nb.str = (uint8 *)" MB in ";
    nb.len = 7;
    runtime_printstring(nb);
    runtime_printuint(initialHeapLive >> 20);
    nc.str = (uint8 *)"->";
    nc.len = 2;
    runtime_printstring(nc);
    runtime_printuint(next_gc >> 20);
    nd.str = (uint8 *)" MB) workers=";
    nd.len = 13;
    runtime_printstring(nd);
    runtime_printint(v);
    ne.str = (uint8 *)"+";
    ne.len = 1;
    runtime_printstring(ne);
    runtime_printfloat(fractionalUtilizationGoal);
    runtime_printnl();
    runtime_printunlock();
  }
}
// 80FCDF9: using guessed type char asc_80FCDF9;

//----- (0805A3C0) --------------------------------------------------------
// runtime.(*gcControllerState).revise
void __golang runtime__ptr_gcControllerState_revise(_ptr_runtime_gcControllerState c)
{
  int32 v1;                    // eax
  unsigned int heap_scan_high; // eax
  unsigned int heap_scan;      // ecx
  unsigned int v4;             // edx
  unsigned int v5;             // ebx
  int v6;                      // eax
  unsigned int v7;             // ecx
  int v8;                      // edx
  int v9;                      // ebx
  unsigned __int64 v10;        // kr10_8
  unsigned __int64 v11;        // kr00_8
  uint64 y_4;                  // [esp+4h] [ebp-40h]
  float64 v13;                 // [esp+8h] [ebp-3Ch]
  uint64 v14;                  // [esp+8h] [ebp-3Ch]
  float64 v15;                 // [esp+8h] [ebp-3Ch]
  uint64 v16;                  // [esp+8h] [ebp-3Ch]
  int64 scanWorkRemaining_lo;  // [esp+10h] [ebp-34h]
  uint64 live_lo;              // [esp+18h] [ebp-2Ch]
  int64 heapRemaining_lo;      // [esp+20h] [ebp-24h]
  int32 gcpercent;             // [esp+28h] [ebp-1Ch]
  uint64 next_gc;              // [esp+2Ch] [ebp-18h]
  float64 v22;                 // [esp+3Ch] [ebp-8h]
  float64 v23;                 // [esp+3Ch] [ebp-8h]

  v1 = runtime_gcpercent;
  if (runtime_gcpercent < 0)
    v1 = 100000;
  gcpercent = v1;
  runtime_internal_atomic_Load64();
  live_lo = y_4;
  if (HIDWORD(y_4) == HIDWORD(runtime_memstats.next_gc) && (unsigned int)y_4 <= LODWORD(runtime_memstats.next_gc) || HIDWORD(y_4) < HIDWORD(runtime_memstats.next_gc))
  {
    next_gc = runtime_memstats.next_gc;
    v13 = runtime_uint64tofloat64(runtime_memstats.heap_scan);
    v14 = runtime_float64toint64(100.0 * v13 / (long double)(gcpercent + 100));
    heap_scan_high = HIDWORD(v14);
    heap_scan = v14;
    v5 = HIDWORD(next_gc);
    v4 = next_gc;
  }
  else
  {
    v15 = runtime_uint64tofloat64(runtime_memstats.next_gc);
    v16 = runtime_float64toint64(1.1 * v15);
    v5 = HIDWORD(v16);
    v4 = v16;
    heap_scan_high = HIDWORD(runtime_memstats.heap_scan);
    heap_scan = runtime_memstats.heap_scan;
  }
  if (((((__PAIR64__(heap_scan_high, heap_scan) - c->scanWork) >> 32) & 0x80000000) != 0LL) | (heap_scan - LODWORD(c->scanWork) < 0x3E8) & ((__PAIR64__(heap_scan_high, heap_scan) - c->scanWork) >> 32 == 0))
  {
    v6 = 1000;
    v7 = 0;
  }
  else
  {
    v11 = __PAIR64__(heap_scan_high, heap_scan) - c->scanWork;
    v7 = HIDWORD(v11);
    v6 = v11;
  }
  v10 = __PAIR64__(v5, v4) - live_lo;
  v9 = (__PAIR64__(v5, v4) - live_lo) >> 32;
  v8 = v10;
  if (v9 == 0 && (_DWORD)v10 == 0 || v9 < 0)
  {
    v8 = 1;
    v9 = 0;
  }
  heapRemaining_lo = __PAIR64__(v9, v8);
  scanWorkRemaining_lo = __PAIR64__(v7, v6);
  v22 = runtime_int64tofloat64(__SPAIR64__(v7, v6));
  c->assistWorkPerByte = v22 / runtime_int64tofloat64(heapRemaining_lo);
  v23 = runtime_int64tofloat64(heapRemaining_lo);
  c->assistBytesPerWork = v23 / runtime_int64tofloat64(scanWorkRemaining_lo);
}
// 805A406: variable 'y_4' is possibly undefined

//----- (0805A610) --------------------------------------------------------
// runtime.(*gcControllerState).endCycle
float64 __golang runtime__ptr_gcControllerState_endCycle(runtime_gcControllerState_0 *c)
{
  long double v1;           // fst6
  long double v2;           // fst5
  long double v3;           // fst3
  uint64 y;                 // [esp+0h] [ebp-94h]
  string ya;                // [esp+0h] [ebp-94h]
  string yb;                // [esp+0h] [ebp-94h]
  string yc;                // [esp+0h] [ebp-94h]
  string yd;                // [esp+0h] [ebp-94h]
  string ye;                // [esp+0h] [ebp-94h]
  string yf;                // [esp+0h] [ebp-94h]
  string yg;                // [esp+0h] [ebp-94h]
  string yh;                // [esp+0h] [ebp-94h]
  string yi;                // [esp+0h] [ebp-94h]
  string yj;                // [esp+0h] [ebp-94h]
  string yk;                // [esp+0h] [ebp-94h]
  string yl;                // [esp+0h] [ebp-94h]
  string ym;                // [esp+0h] [ebp-94h]
  float64 v18;              // [esp+8h] [ebp-8Ch]
  uint64 assistDuration_lo; // [esp+10h] [ebp-84h]
  int64 W_a_lo;             // [esp+18h] [ebp-7Ch]
  uint64 H_m_prev_lo;       // [esp+20h] [ebp-74h]
  uint64 H_g_lo;            // [esp+28h] [ebp-6Ch]
  uint64 H_a_lo;            // [esp+30h] [ebp-64h]
  uint64 H_T_lo;            // [esp+38h] [ebp-5Ch]
  int v25;                  // [esp+40h] [ebp-54h]
  double u_a;               // [esp+4Ch] [ebp-48h]
  double triggerRatio;      // [esp+54h] [ebp-40h]
  double h_g;               // [esp+5Ch] [ebp-38h]
  double h_a;               // [esp+64h] [ebp-30h]
  float64 v30;              // [esp+84h] [ebp-10h]
  float64 v31;              // [esp+8Ch] [ebp-8h]
  double v32;               // [esp+8Ch] [ebp-8h]
  float64 v33;              // [esp+8Ch] [ebp-8h]

  if (runtime_work.userForced)
    return runtime_memstats.triggerRatio;
  v25 = runtime_gcpercent;
  v31 = runtime_uint64tofloat64(runtime_memstats.heap_live);
  v30 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
  runtime_nanotime();
  h_g = (long double)v25 / 100.0;
  h_a = v31 / v30 - 1.0;
  if ((_DWORD)y != LODWORD(c->markStartTime) && (y - c->markStartTime) >> 32 == 0 || (int)((y - c->markStartTime) >> 32) > 0)
  {
    assistDuration_lo = y - c->markStartTime;
    v33 = runtime_int64tofloat64(c->assistTime);
    u_a = v33 / runtime_int64tofloat64(runtime_gomaxprocs * assistDuration_lo) + 0.25;
  }
  else
  {
    u_a = 0.25;
  }
  v32 = runtime_memstats.triggerRatio;
  v1 = h_g - runtime_memstats.triggerRatio;
  v2 = u_a / 0.3;
  v3 = h_a - runtime_memstats.triggerRatio;
  triggerRatio = 0.5 * (v1 - v3 * v2) + runtime_memstats.triggerRatio;
  if (runtime_debug.gcpacertrace > 0)
  {
    H_m_prev_lo = runtime_memstats.heap_marked;
    H_T_lo = runtime_memstats.gc_trigger;
    H_a_lo = runtime_memstats.heap_live;
    v18 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
    H_g_lo = runtime_float64toint64((h_g + 1.0) * v18);
    W_a_lo = c->scanWork;
    runtime_printlock();
    ya.str = (uint8 *)"pacer: H_m_prev=";
    ya.len = 16;
    runtime_printstring(ya);
    runtime_printuint(H_m_prev_lo);
    yb.str = (uint8 *)" h_t=";
    yb.len = 5;
    runtime_printstring(yb);
    runtime_printfloat(v32);
    yc.str = (uint8 *)" H_T=";
    yc.len = 5;
    runtime_printstring(yc);
    runtime_printuint(H_T_lo);
    yd.str = (uint8 *)" h_a=";
    yd.len = 5;
    runtime_printstring(yd);
    runtime_printfloat(h_a);
    ye.str = (uint8 *)" H_a=";
    ye.len = 5;
    runtime_printstring(ye);
    runtime_printuint(H_a_lo);
    yf.str = (uint8 *)" h_g=";
    yf.len = 5;
    runtime_printstring(yf);
    runtime_printfloat(h_g);
    yg.str = (uint8 *)" H_g=";
    yg.len = 5;
    runtime_printstring(yg);
    runtime_printint(H_g_lo);
    yh.str = (uint8 *)" u_a=";
    yh.len = 5;
    runtime_printstring(yh);
    runtime_printfloat(u_a);
    yi.str = (uint8 *)" u_g=";
    yi.len = 5;
    runtime_printstring(yi);
    runtime_printfloat(0.3);
    yj.str = (uint8 *)" W_a=";
    yj.len = 5;
    runtime_printstring(yj);
    runtime_printint(W_a_lo);
    yk.str = (uint8 *)" goalΔ=";
    yk.len = 8;
    runtime_printstring(yk);
    runtime_printfloat(v1);
    yl.str = (uint8 *)" actualΔ=";
    yl.len = 10;
    runtime_printstring(yl);
    runtime_printfloat(v3);
    ym.str = (uint8 *)" u_a/u_g=";
    ym.len = 9;
    runtime_printstring(ym);
    runtime_printfloat(v2);
    runtime_printnl();
    runtime_printunlock();
  }
  return triggerRatio;
}
// 805A6FF: variable 'y' is possibly undefined

//----- (0805ACB0) --------------------------------------------------------
// runtime.(*gcControllerState).findRunnableGCWorker
runtime_g *__golang runtime__ptr_gcControllerState_findRunnableGCWorker(runtime_gcControllerState_0 *c, runtime_p *_p_)
{
  runtime_p *v2; // eax
  int64 v3;      // kr00_8
  __int64 p;     // [esp+0h] [ebp-2Ch]
  string pa;     // [esp+0h] [ebp-2Ch]
  float64 v6;    // [esp+20h] [ebp-Ch]
  runtime_g *gp; // [esp+28h] [ebp-4h]

  if (!runtime_gcBlackenEnabled)
  {
    pa.str = (uint8 *)"gcControllerState.findRunnable: blackening not enabled";
    pa.len = 54;
    runtime_throw(pa);
    BUG();
  }
  if (!_p_->gcBgMarkWorker)
    return 0;
  if (!runtime_gcMarkWorkAvailable(_p_))
    return 0;
  BYTE4(p) = runtime__ptr_gcControllerState_findRunnableGCWorker_func1(&c->dedicatedMarkWorkersNeeded);
  if (BYTE4(p))
  {
    v2 = _p_;
    _p_->gcMarkWorkerMode = 0;
  }
  else
  {
    if (c->fractionalUtilizationGoal == 0.0)
      return 0;
    runtime_nanotime();
    v3 = p - runtime_gcController.markStartTime;
    if ((_DWORD)p != LODWORD(runtime_gcController.markStartTime) && (unsigned __int64)(p - runtime_gcController.markStartTime) >> 32 == 0 || (int)((unsigned __int64)(p - runtime_gcController.markStartTime) >> 32) > 0)
    {
      v6 = runtime_int64tofloat64(_p_->gcFractionalMarkTime);
      if (v6 / runtime_int64tofloat64(v3) > (long double)c->fractionalUtilizationGoal)
        return 0;
    }
    v2 = _p_;
    _p_->gcMarkWorkerMode = 1;
  }
  gp = (runtime_g *)v2->gcBgMarkWorker;
  runtime_casgstatus(gp, 4u, 1u);
  if (runtime_trace.enabled)
    runtime_traceGoUnpark(gp, 0);
  return gp;
}
// 805ADB4: variable 'p' is possibly undefined

//----- (0805AEB0) --------------------------------------------------------
// runtime.pollFractionalWorkerExit
bool __golang runtime_pollFractionalWorkerExit()
{
  _DWORD *v0;     // eax
  __int64 v1;     // rdi
  int64 y;        // [esp+0h] [ebp-2Ch]
  int64 delta_lo; // [esp+10h] [ebp-1Ch]
  float64 v4;     // [esp+24h] [ebp-8h]

  runtime_nanotime();
  if ((_DWORD)y == LODWORD(runtime_gcController.markStartTime) && (unsigned __int64)(y - runtime_gcController.markStartTime) >> 32 == 0 || (((unsigned __int64)(y - runtime_gcController.markStartTime) >> 32) & 0x80000000) != 0LL)
  {
    return 1;
  }
  delta_lo = y - runtime_gcController.markStartTime;
  v0 = *(_DWORD **)(*(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24) + 112);
  LODWORD(v1) = y - v0[598];
  HIDWORD(v1) = v0[595];
  v4 = runtime_int64tofloat64(__PAIR64__((unsigned __int64)(y - *((_QWORD *)v0 + 299)) >> 32, v0[594]) + v1);
  return v4 / runtime_int64tofloat64(delta_lo) > 1.2 * runtime_gcController.fractionalUtilizationGoal;
}
// 805AEF2: variable 'y' is possibly undefined

//----- (0805AFE0) --------------------------------------------------------
// runtime.gcSetTriggerRatio
void __golang runtime_gcSetTriggerRatio(float64 triggerRatio)
{
  int v1;                   // eax
  int v2;                   // ecx
  int v3;                   // edx
  int v4;                   // ebx
  unsigned int v5;          // ecx
  int v6;                   // edx
  unsigned __int64 v7;      // kr00_8
  uint64 v8;                // kr08_8
  int v9;                   // esi
  uint64 v10;               // kr10_8
  signed __int64 v11;       // rax
  uint32 v12;               // ecx
  unsigned int v13;         // ebx
  unsigned int v14;         // ecx
  int v15;                  // ebp
  long double v16;          // fst7
  string y;                 // [esp+0h] [ebp-88h]
  string ya;                // [esp+0h] [ebp-88h]
  string yb;                // [esp+0h] [ebp-88h]
  string yc;                // [esp+0h] [ebp-88h]
  string yd;                // [esp+0h] [ebp-88h]
  string ye;                // [esp+0h] [ebp-88h]
  string yf;                // [esp+0h] [ebp-88h]
  long double y_4;          // [esp+4h] [ebp-84h]
  float64 y_8;              // [esp+8h] [ebp-80h]
  uint64 v26;               // [esp+10h] [ebp-78h]
  uint64 v27;               // [esp+10h] [ebp-78h]
  uint32 trigger_lo;        // [esp+18h] [ebp-70h]
  uint32 trigger_hi;        // [esp+1Ch] [ebp-6Ch]
  uint64 minTrigger_lo;     // [esp+28h] [ebp-60h]
  uint32 heapLiveBasis_lo;  // [esp+30h] [ebp-58h]
  int64 heapDistance_lo;    // [esp+38h] [ebp-50h]
  unsigned __int64 goal_lo; // [esp+40h] [ebp-48h]
  uint64 initialHeapLive;   // [esp+48h] [ebp-40h]
  uint64 heap_live;         // [esp+50h] [ebp-38h]
  uint64 heap_marked;       // [esp+58h] [ebp-30h]
  uint64 v;                 // [esp+60h] [ebp-28h]
  uint64 v38;               // [esp+68h] [ebp-20h]
  unsigned __int64 v39;     // [esp+68h] [ebp-20h]
  float64 v40;              // [esp+80h] [ebp-8h]

  if (triggerRatio >= 0.0)
  {
    if (runtime_gcpercent >= 0)
    {
      v16 = (long double)runtime_gcpercent * 0.95 / 100.0;
      if (triggerRatio > v16)
        triggerRatio = v16;
    }
  }
  else
  {
    triggerRatio = 0.0;
  }
  runtime_memstats.triggerRatio = triggerRatio;
  if (runtime_gcpercent >= 0)
  {
    y_8 = runtime_uint64tofloat64(runtime_memstats.heap_marked);
    *(_QWORD *)((char *)&y_4 + 4) = runtime_float64touint64((triggerRatio + 1.0) * y_8);
    v11 = __PAIR64__(HIDWORD(runtime_heapminimum), HIDWORD(y_4));
    v12 = DWORD1(y_4);
    v13 = runtime_heapminimum;
    if (!ptr)
    {
      trigger_hi = HIDWORD(y_4);
      trigger_lo = DWORD1(y_4);
      minTrigger_lo = runtime_heapminimum;
      runtime_internal_atomic_Load64();
      v38 = *(_QWORD *)&y_4;
      v27 = runtime_uint64div((__int64)runtime_gcpercent << 20, 0x64uLL);
      v11 = v38 + v27;
      if ((v38 + v27) >> 32 <= HIDWORD(minTrigger_lo) && ((int)v38 + (int)v27 <= (unsigned int)minTrigger_lo || (v38 + v27) >> 32 != HIDWORD(minTrigger_lo)))
      {
        v11 = minTrigger_lo;
      }
      v12 = trigger_lo;
      v13 = v11;
      LODWORD(v11) = trigger_hi;
    }
    if ((unsigned int)v11 < HIDWORD(v11) || (_DWORD)v11 == HIDWORD(v11) && v12 < v13)
    {
      LODWORD(v11) = v13;
      v14 = HIDWORD(v11);
    }
    else
    {
      v15 = v11;
      LODWORD(v11) = v13;
      v13 = v12;
      v14 = HIDWORD(v11);
      HIDWORD(v11) = v15;
    }
    if (v11 < 0)
    {
      v39 = __PAIR64__(v14, v11);
      v = runtime_memstats.next_gc;
      heap_marked = runtime_memstats.heap_marked;
      heap_live = runtime_memstats.heap_live;
      initialHeapLive = runtime_work.initialHeapLive;
      runtime_printlock();
      y.str = (uint8 *)"runtime: next_gc=";
      y.len = 17;
      runtime_printstring(y);
      runtime_printuint(v);
      ya.str = (uint8 *)" heap_marked=";
      ya.len = 13;
      runtime_printstring(ya);
      runtime_printuint(heap_marked);
      yb.str = (uint8 *)" heap_live=";
      yb.len = 11;
      runtime_printstring(yb);
      runtime_printuint(heap_live);
      yc.str = (uint8 *)" initialHeapLive=";
      yc.len = 17;
      runtime_printstring(yc);
      runtime_printuint(initialHeapLive);
      yd.str = (uint8 *)"triggerRatio=";
      yd.len = 13;
      runtime_printstring(yd);
      runtime_printfloat(triggerRatio);
      ye.str = (uint8 *)" minTrigger=";
      ye.len = 12;
      runtime_printstring(ye);
      runtime_printuint(v39);
      runtime_printnl();
      runtime_printunlock();
      yf.str = (uint8 *)"gc_trigger underflow";
      yf.len = 20;
      runtime_throw(yf);
      BUG();
    }
    v1 = v13;
    v2 = HIDWORD(v11);
  }
  else
  {
    v1 = -1;
    v2 = -1;
  }
  goal_lo = __PAIR64__(v2, v1);
  LODWORD(runtime_memstats.gc_trigger) = v1;
  HIDWORD(runtime_memstats.gc_trigger) = v2;
  if (runtime_gcpercent >= 0)
  {
    v8 = runtime_memstats.heap_marked;
    v26 = runtime_uint64div(runtime_gcpercent * runtime_memstats.heap_marked, 0x64uLL);
    v4 = HIDWORD(goal_lo);
    v9 = goal_lo;
    if ((v8 + v26) >> 32 >= HIDWORD(goal_lo) && ((v8 + v26) >> 32 != HIDWORD(goal_lo) || (int)v8 + (int)v26 >= (unsigned int)goal_lo))
    {
      v10 = v8 + v26;
      v4 = HIDWORD(v10);
      v9 = v10;
    }
    v3 = v9;
  }
  else
  {
    v3 = -1;
    v4 = -1;
  }
  LODWORD(runtime_memstats.next_gc) = v3;
  HIDWORD(runtime_memstats.next_gc) = v4;
  if (runtime_trace.enabled)
    runtime_traceNextGC();
  if (runtime_gcphase)
    runtime__ptr_gcControllerState_revise((_ptr_runtime_gcControllerState)&runtime_gcController);
  if (ptr)
  {
    dbl_81702E0 = 0.0;
  }
  else
  {
    runtime_internal_atomic_Load64();
    heapLiveBasis_lo = LODWORD(y_4);
    if ((goal_lo - *(_QWORD *)&y_4 - 0x100000) >> 32 == 0 && (unsigned int)(goal_lo - LODWORD(y_4) - 0x100000) < 0x2000 || (((goal_lo - *(_QWORD *)&y_4 - 0x100000) >> 32) & 0x80000000) != 0LL)
    {
      v5 = 0;
      v6 = 0x2000;
    }
    else
    {
      v7 = goal_lo - *(_QWORD *)&y_4 - 0x100000;
      v5 = HIDWORD(v7);
      v6 = v7;
    }
    heapDistance_lo = __PAIR64__(v5, v6);
    runtime_internal_atomic_Load64();
    if ((((unsigned __int64)(qword_81702C0 - *(_QWORD *)&y_4) >> 32) & 0x80000000) != 0LL || (unsigned __int64)(qword_81702C0 - *(_QWORD *)&y_4) >> 32 == 0 && (_DWORD)qword_81702C0 == LODWORD(y_4))
    {
      dbl_81702E0 = 0.0;
    }
    else
    {
      v40 = runtime_int64tofloat64(qword_81702C0 - *(_QWORD *)&y_4);
      dbl_81702E0 = v40 / runtime_int64tofloat64(heapDistance_lo);
      dword_81702D8 = heapLiveBasis_lo;
      dword_81702DC = DWORD1(y_4);
      runtime_internal_atomic_Store64();
    }
  }
}
// 805B0E5: variable 'y_4' is possibly undefined
// 81702C0: using guessed type __int64 qword_81702C0;
// 81702D8: using guessed type int dword_81702D8;
// 81702DC: using guessed type int dword_81702DC;
// 81702E0: using guessed type double dbl_81702E0;

//----- (0805BC20) --------------------------------------------------------
// runtime.gcMarkDone
void __golang runtime_gcMarkDone()
{
  int v0;                    // eax
  int64 addr;                // [esp+0h] [ebp-1Ch]
  float64 addr_4;            // [esp+4h] [ebp-18h]
  double prevFractionalGoal; // [esp+14h] [ebp-8h]

  while (1)
  {
    runtime_semacquire(&runtime_work.markDoneSema);
    if (runtime_gcphase != 1 || runtime_work.nproc != runtime_work.nwait || runtime_gcMarkWorkAvailable(0))
    {
      runtime_semrelease(&runtime_work.markDoneSema);
      return;
    }
    LODWORD(addr) = &runtime_gcController.dedicatedMarkWorkersNeeded;
    HIDWORD(addr) = 1;
    runtime_internal_atomic_Xaddint64();
    prevFractionalGoal = runtime_gcController.fractionalUtilizationGoal;
    runtime_gcController.fractionalUtilizationGoal = 0.0;
    if (runtime_gcBlackenPromptly)
      break;
    runtime_gcBlackenPromptly = 1;
    runtime_internal_atomic_Xadd();
    runtime_semrelease(&runtime_work.markDoneSema);
    runtime_systemstack();
    runtime_gcMarkRootCheck();
    runtime_internal_atomic_Xaddint64();
    runtime_gcController.fractionalUtilizationGoal = prevFractionalGoal;
    runtime_internal_atomic_Xadd();
    if (runtime_work.nproc || runtime_gcMarkWorkAvailable(0))
      return;
  }
  runtime_nanotime();
  runtime_work.tMarkTerm = addr;
  runtime_work.pauseStart = addr;
  v0 = *(_DWORD *)(*(_DWORD *)(__readgsdword(0) - 4) + 24);
  *(_DWORD *)(v0 + 140) = 5;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
    runtime_writebarrierptr((uintptr *)(v0 + 136), (uintptr) "gcing");
  else
    *(_DWORD *)(v0 + 136) = "gcing";
  if (runtime_trace.enabled)
    runtime_traceGCSTWStart(0);
  runtime_systemstack();
  runtime_work.markrootDone = 1;
  runtime_internal_atomic_Store();
  runtime_gcWakeAllAssists();
  runtime_semrelease(&runtime_work.markDoneSema);
  addr_4 = runtime__ptr_gcControllerState_endCycle(&runtime_gcController);
  runtime_gcMarkTermination(addr_4);
}

//----- (0805BE90) --------------------------------------------------------
// runtime.gcMarkTermination
void __golang runtime_gcMarkTermination(float64 nextTriggerRatio)
{
  int v1;                           // eax
  int v2;                           // ecx
  runtime_g *v3;                    // eax
  runtime_g *v4;                    // eax
  int v5;                           // eax
  uint64 *v6;                       // eax
  int pauseNS_high;                 // ecx
  unsigned __int64 v8;              // kr10_8
  int v9;                           // ebx
  uint32 v10;                       // edx
  int v11;                          // ecx
  int32 v12;                        // ebx
  int32 v13;                        // esi
  uint32 v14;                       // ebp
  int j;                            // eax
  int *v16;                         // ecx
  int v17;                          // eax
  int v18;                          // edx
  unsigned int x;                   // [esp+0h] [ebp-1B4h]
  int64 xa;                         // [esp+0h] [ebp-1B4h]
  retval_8084670 xb;                // [esp+0h] [ebp-1B4h]
  _slice_uint8 xc;                  // [esp+0h] [ebp-1B4h]
  string xd;                        // [esp+0h] [ebp-1B4h]
  string xe;                        // [esp+0h] [ebp-1B4h]
  string xf;                        // [esp+0h] [ebp-1B4h]
  string xg;                        // [esp+0h] [ebp-1B4h]
  _slice_uint8 xh;                  // [esp+0h] [ebp-1B4h]
  string xi;                        // [esp+0h] [ebp-1B4h]
  string xj;                        // [esp+0h] [ebp-1B4h]
  _slice_uint8 xk;                  // [esp+0h] [ebp-1B4h]
  string xl;                        // [esp+0h] [ebp-1B4h]
  string xm;                        // [esp+0h] [ebp-1B4h]
  string xn;                        // [esp+0h] [ebp-1B4h]
  string xo;                        // [esp+0h] [ebp-1B4h]
  string xp;                        // [esp+0h] [ebp-1B4h]
  string xq;                        // [esp+0h] [ebp-1B4h]
  string xr;                        // [esp+0h] [ebp-1B4h]
  string xs;                        // [esp+0h] [ebp-1B4h]
  string xt;                        // [esp+0h] [ebp-1B4h]
  string xu;                        // [esp+0h] [ebp-1B4h]
  uint64 v41;                       // [esp+10h] [ebp-1A4h]
  string v42;                       // [esp+10h] [ebp-1A4h]
  __int128 v43;                     // [esp+10h] [ebp-1A4h]
  __int128 v44;                     // [esp+10h] [ebp-1A4h]
  _slice_uint8 b;                   // [esp+18h] [ebp-19Ch]
  uint32 totalCpu_lo;               // [esp+2Ch] [ebp-188h]
  uint32 sweepTermCpu_lo;           // [esp+30h] [ebp-184h]
  uint32 prev_lo;                   // [esp+38h] [ebp-17Ch]
  int32 prev_hi;                    // [esp+3Ch] [ebp-178h]
  uint32 ns_lo_0;                   // [esp+44h] [ebp-170h]
  int32 ns_hi_0;                    // [esp+4Ch] [ebp-168h]
  int64 now_lo;                     // [esp+54h] [ebp-160h]
  uint32 markTermCpu_lo;            // [esp+5Ch] [ebp-158h]
  __int32 i_0;                      // [esp+64h] [ebp-150h]
  __int32 i;                        // [esp+68h] [ebp-14Ch]
  unsigned int procresizetime_high; // [esp+80h] [ebp-134h]
  int totaltime_high;               // [esp+84h] [ebp-130h]
  unsigned int y_4;                 // [esp+8Ch] [ebp-128h]
  uint64 heapGoal;                  // [esp+9Ch] [ebp-118h]
  int totaltime;                    // [esp+A0h] [ebp-114h]
  unsigned __int64 v61;             // [esp+A4h] [ebp-110h]
  uint64 heap2;                     // [esp+A4h] [ebp-110h]
  int v63;                          // [esp+ACh] [ebp-108h]
  unsigned int heap1;               // [esp+ACh] [ebp-108h]
  int v;                            // [esp+B0h] [ebp-104h]
  int32 va;                         // [esp+B0h] [ebp-104h]
  unsigned int v_4;                 // [esp+B4h] [ebp-100h]
  uint32 v_4a;                      // [esp+B4h] [ebp-100h]
  int v69;                          // [esp+B8h] [ebp-FCh]
  uint64 heap0;                     // [esp+B8h] [ebp-FCh]
  int v71;                          // [esp+BCh] [ebp-F8h]
  int64 startTime;                  // [esp+C0h] [ebp-F4h] BYREF
  int64 v73;                        // [esp+C8h] [ebp-ECh]
  float64 gc_cpu_fraction;          // [esp+D0h] [ebp-E4h]
  uint8 sbuf[24];                   // [esp+D8h] [ebp-DCh] BYREF
  __int64 v76[3];                   // [esp+F0h] [ebp-C4h] BYREF
  uint8 v77[32];                    // [esp+108h] [ebp-ACh] BYREF
  uint8 v78[32];                    // [esp+128h] [ebp-8Ch] BYREF
  uint8 buf[32];                    // [esp+148h] [ebp-6Ch] BYREF
  int v80[2];                       // [esp+168h] [ebp-4Ch] BYREF
  int64 assistTime;                 // [esp+170h] [ebp-44h]
  int64 v82;                        // [esp+178h] [ebp-3Ch]
  int64 idleMarkTime;               // [esp+180h] [ebp-34h]
  uint32 v84;                       // [esp+188h] [ebp-2Ch]
  int v85;                          // [esp+18Ch] [ebp-28h]
  int v86;                          // [esp+190h] [ebp-24h]
  runtime_g *gp;                    // [esp+194h] [ebp-20h]
  runtime_g *_g_;                   // [esp+198h] [ebp-1Ch]
  string s;                         // [esp+19Ch] [ebp-18h]
  void(__golang * v90)();           // [esp+1A4h] [ebp-10h]
  int64 *v91;                       // [esp+1A8h] [ebp-Ch]
  void(__golang * v92)();           // [esp+1ACh] [ebp-8h]
  int64 *p_startTime;               // [esp+1B0h] [ebp-4h]

  runtime_internal_atomic_Store();
  runtime_gcBlackenPromptly = 0;
  runtime_setGCPhase(2u);
  runtime_work.heap1 = runtime_memstats.heap_live;
  runtime_nanotime();
  startTime = x;
  v1 = *(_DWORD *)(__readgsdword(0) - 4);
  ++*(_DWORD *)(*(_DWORD *)(v1 + 24) + 144);
  v2 = *(_DWORD *)(v1 + 24);
  v86 = v2;
  *(_DWORD *)(v2 + 140) = 5;
  s.len = v2 + 136;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
    runtime_writebarrierptr((uintptr *)(v2 + 136), (uintptr) "gcing");
  else
    *(_DWORD *)(v2 + 136) = "gcing";
  v3 = *(runtime_g **)(__readgsdword(0) - 4);
  _g_ = v3;
  v3->m->traceback = 2;
  gp = v3->m->curg;
  runtime_casgstatus(gp, 2u, 4u);
  v4 = gp;
  gp->waitreason.len = 18;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
    runtime_writebarrierptr((uintptr *)&v4->waitreason, (uintptr) "garbage collection");
  else
    v4->waitreason.str = (uint8 *)"garbage collection";
  v92 = runtime_gcMarkTermination_func1;
  p_startTime = &startTime;
  runtime_systemstack();
  v90 = runtime_gcMarkTermination_func2;
  v91 = &startTime;
  runtime_systemstack();
  _g_->m->traceback = 0;
  runtime_casgstatus(gp, 4u, 2u);
  if (runtime_trace.enabled)
    runtime_traceGCDone();
  v5 = v86;
  *(_DWORD *)(v86 + 140) = 0;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
    runtime_writebarrierptr((uintptr *)s.len, 0);
  else
    *(_DWORD *)(v5 + 136) = 0;
  if (runtime_gcphase)
  {
    xu.str = (uint8 *)"gc done but gcphase != _GCoff";
    xu.len = 29;
    runtime_throw(xu);
    BUG();
  }
  runtime_gcSetTriggerRatio(nextTriggerRatio);
  runtime_nanotime();
  now_lo = xa;
  xb = time_now();
  runtime_work.pauseNS += now_lo - runtime_work.pauseStart;
  runtime_work.tEnd = now_lo;
  runtime_internal_atomic_Store64();
  runtime_internal_atomic_Store64();
  v6 = &runtime_memstats.pause_ns[LOBYTE(runtime_memstats.numgc)];
  pauseNS_high = HIDWORD(runtime_work.pauseNS);
  *(_DWORD *)v6 = runtime_work.pauseNS;
  *((_DWORD *)v6 + 1) = pauseNS_high;
  runtime_memstats.pause_end[LOBYTE(runtime_memstats.numgc)] = xb.nsec + 1000000000 * xb.sec;
  runtime_memstats.pause_total_ns += runtime_work.pauseNS;
  sweepTermCpu_lo = runtime_work.stwprocs * (LODWORD(runtime_work.tMark) - LODWORD(runtime_work.tSweepTerm));
  markTermCpu_lo = runtime_work.stwprocs * (LODWORD(runtime_work.tEnd) - LODWORD(runtime_work.tMarkTerm));
  y_4 = runtime_work.totaltime;
  LODWORD(runtime_work.totaltime) += markTermCpu_lo + sweepTermCpu_lo + LODWORD(runtime_gcController.assistTime) + LODWORD(runtime_gcController.dedicatedMarkTime) + LODWORD(runtime_gcController.fractionalMarkTime);
  v71 = (unsigned __int64)(runtime_work.stwprocs * (runtime_work.tMark - runtime_work.tSweepTerm)) >> 32;
  v69 = (unsigned __int64)(runtime_work.stwprocs * (runtime_work.tEnd - runtime_work.tMarkTerm)) >> 32;
  v8 = runtime_work.stwprocs * (runtime_work.tEnd - runtime_work.tMarkTerm) + runtime_work.stwprocs * (runtime_work.tMark - runtime_work.tSweepTerm) + runtime_gcController.assistTime + runtime_gcController.dedicatedMarkTime + runtime_gcController.fractionalMarkTime + __PAIR64__(HIDWORD(runtime_work.totaltime), y_4);
  HIDWORD(runtime_work.totaltime) = HIDWORD(v8);
  v9 = v8;
  v_4 = runtime_sched.procresizetime;
  v63 = now_lo - LODWORD(runtime_sched.procresizetime);
  v = runtime_gomaxprocs;
  v61 = (unsigned int)runtime_gomaxprocs * (unsigned __int64)(unsigned int)(now_lo - LODWORD(runtime_sched.procresizetime));
  totaltime = runtime_sched.totaltime;
  totalCpu_lo = LODWORD(runtime_sched.totaltime) + v61;
  totaltime_high = HIDWORD(runtime_sched.totaltime);
  procresizetime_high = HIDWORD(runtime_sched.procresizetime);
  gc_cpu_fraction = runtime_int64tofloat64(__SPAIR64__(HIDWORD(v8), runtime_work.totaltime));
  LODWORD(xb.sec) = totalCpu_lo;
  HIDWORD(xb.sec) = HIDWORD(v61) + v63 * (v >> 31) + v * ((now_lo - __PAIR64__(procresizetime_high, v_4)) >> 32) + __CFADD__(totaltime, (_DWORD)v61) + totaltime_high;
  runtime_memstats.gc_cpu_fraction = gc_cpu_fraction / runtime_int64tofloat64(xb.sec);
  runtime_sweep.nbgsweep = 0;
  runtime_sweep.npausesweep = 0;
  if (runtime_work.userForced)
    ++runtime_memstats.numforcedgc;
  runtime_lock(&runtime_work.sweepWaiters.lock);
  ++runtime_memstats.numgc;
  runtime_injectglist((runtime_g *)runtime_work.sweepWaiters.head);
  runtime_work.sweepWaiters.head = 0;
  runtime_unlock(&runtime_work.sweepWaiters.lock);
  runtime_mProf_NextCycle();
  runtime_systemstack();
  runtime_mProf_Flush();
  runtime_prepareFreeWorkbufs();
  runtime_systemstack();
  if (runtime_debug.gctrace > 0)
  {
    gc_cpu_fraction = runtime_memstats.gc_cpu_fraction;
    ((void(__golang *)(int(__golang **)()))loc_8090B1A)(&off_8104500);
    runtime_printlock();
    v41 = runtime_uint64div(runtime_work.tSweepTerm - runtime_runtimeInitTime, 0xF4240uLL);
    xc.array = sbuf;
    *(_QWORD *)&xc.len = 0x1800000018LL;
    b = runtime_itoaDiv(xc, v41, 3);
    v_4a = runtime_memstats.numgc;
    v42 = runtime_slicebytetostring((uint8(*)[32])buf, b);
    s.str = v42.str;
    runtime_printlock();
    xd.str = (uint8 *)"gc ";
    xd.len = 3;
    runtime_printstring(xd);
    runtime_printuint(v_4a);
    xe.str = (uint8 *)" @";
    xe.len = 2;
    runtime_printstring(xe);
    runtime_printstring((string)__PAIR64__(v42.len, (unsigned int)s.str));
    xf.str = (uint8 *)"s ";
    xf.len = 2;
    runtime_printstring(xf);
    LODWORD(v73) = (int)(gc_cpu_fraction * 100.0);
    runtime_printint((int)v73);
    xg.str = (uint8 *)"%: ";
    xg.len = 3;
    runtime_printstring(xg);
    runtime_printunlock();
    prev_hi = HIDWORD(runtime_work.tSweepTerm);
    ((void (*)(void))loc_8090B1A)();
    v76[0] = runtime_work.tMark;
    v76[1] = runtime_work.tMarkTerm;
    v76[2] = runtime_work.tEnd;
    v11 = 0;
    v12 = prev_hi;
    while (v11 < 3)
    {
      i = v11;
      v13 = HIDWORD(v76[v11]);
      v14 = v76[v11];
      if (v11)
      {
        prev_lo = v10;
        runtime_printlock();
        xi.str = (uint8 *)"+";
        xi.len = 1;
        runtime_printstring(xi);
        runtime_printunlock();
        v10 = prev_lo;
      }
      xh.array = sbuf;
      *(_QWORD *)&xh.len = 0x1800000018LL;
      *(_slice_uint8 *)((char *)&v43 + 4) = runtime_fmtNSAsMS(xh, __PAIR64__(v13, v14) - __PAIR64__(v12, v10));
      *(string *)&v43 = runtime_slicebytetostring((uint8(*)[32])v78, *(_slice_uint8 *)((char *)&v43 + 4));
      s.str = (uint8 *)v43;
      runtime_printlock();
      runtime_printstring((string)__PAIR64__(DWORD1(v43), (unsigned int)s.str));
      runtime_printunlock();
      v11 = i + 1;
      v10 = v14;
      v12 = v13;
    }
    runtime_printlock();
    xj.str = (uint8 *)" ms clock, ";
    xj.len = 11;
    runtime_printstring(xj);
    runtime_printunlock();
    ((void (*)(void))loc_8090B16)();
    v80[0] = sweepTermCpu_lo;
    v80[1] = v71;
    assistTime = runtime_gcController.assistTime;
    v82 = runtime_gcController.dedicatedMarkTime + runtime_gcController.fractionalMarkTime;
    idleMarkTime = runtime_gcController.idleMarkTime;
    v84 = markTermCpu_lo;
    v85 = v69;
    for (j = 0; j < 5; j = i_0 + 1)
    {
      i_0 = j;
      v16 = &v80[2 * j];
      ns_hi_0 = v16[1];
      ns_lo_0 = *v16;
      if (j == 2 || j == 3)
      {
        runtime_printlock();
        xl.str = (uint8 *)"/";
        xl.len = 1;
        runtime_printstring(xl);
        runtime_printunlock();
      }
      else if (j)
      {
        runtime_printlock();
        xm.str = (uint8 *)"+";
        xm.len = 1;
        runtime_printstring(xm);
        runtime_printunlock();
      }
      xk.array = sbuf;
      *(_QWORD *)&xk.len = 0x1800000018LL;
      *(_slice_uint8 *)((char *)&v44 + 4) = runtime_fmtNSAsMS(xk, __PAIR64__(ns_hi_0, ns_lo_0));
      *(string *)&v44 = runtime_slicebytetostring((uint8(*)[32])v77, *(_slice_uint8 *)((char *)&v44 + 4));
      s.str = (uint8 *)v44;
      runtime_printlock();
      runtime_printstring((string)__PAIR64__(DWORD1(v44), (unsigned int)s.str));
      runtime_printunlock();
    }
    heap0 = runtime_work.heap0;
    heap1 = runtime_work.heap1;
    heap2 = runtime_work.heap2;
    heapGoal = runtime_work.heapGoal;
    va = runtime_work.maxprocs;
    runtime_printlock();
    xn.str = (uint8 *)" ms cpu, ";
    xn.len = 9;
    runtime_printstring(xn);
    runtime_printuint(heap0 >> 20);
    xo.str = (uint8 *)"->";
    xo.len = 2;
    runtime_printstring(xo);
    runtime_printuint(__PAIR64__(HIDWORD(runtime_work.heap1), heap1) >> 20);
    xp.str = (uint8 *)"->";
    xp.len = 2;
    runtime_printstring(xp);
    runtime_printuint(heap2 >> 20);
    xq.str = (uint8 *)" MB, ";
    xq.len = 5;
    runtime_printstring(xq);
    runtime_printuint(heapGoal >> 20);
    xr.str = (uint8 *)" MB goal, ";
    xr.len = 10;
    runtime_printstring(xr);
    runtime_printint(va);
    xs.str = (uint8 *)" P";
    xs.len = 2;
    runtime_printstring(xs);
    runtime_printunlock();
    if (runtime_work.userForced)
    {
      runtime_printlock();
      xt.str = (uint8 *)" (forced)";
      xt.len = 9;
      runtime_printstring(xt);
      runtime_printunlock();
    }
    runtime_printlock();
    runtime_printnl();
    runtime_printunlock();
    runtime_printunlock();
  }
  runtime_semrelease(&runtime_worldsema);
  v17 = *(_DWORD *)(__readgsdword(0) - 4);
  v18 = *(_DWORD *)(v86 + 144);
  *(_DWORD *)(v86 + 144) = v18 - 1;
  if (v18 == 1 && *(_BYTE *)(v17 + 108))
    *(_DWORD *)(v17 + 8) = -1314;
}
// 805BF00: variable 'x' is possibly undefined
// 805C0B8: variable 'xa' is possibly undefined
// 805C7F1: variable 'v10' is possibly undefined
// 80FCDF9: using guessed type char asc_80FCDF9;
// 80FCDFD: using guessed type char asc_80FCDFD;
// 8104500: using guessed type int (__golang *off_8104500)();

//----- (0805D750) --------------------------------------------------------
// runtime.gcSweep
void __golang runtime_gcSweep(runtime_gcMode mode)
{
  string l;  // [esp+0h] [ebp-Ch]
  string la; // [esp+0h] [ebp-Ch]

  if (runtime_gcphase)
  {
    la.str = (uint8 *)"gcSweep being done but phase is not GCoff";
    la.len = 41;
    runtime_throw(la);
    BUG();
  }
  runtime_lock(&runtime_mheap_.lock);
  dword_8170270 += 2;
  ptr = 0;
  if (dword_8170294[5 * (((unsigned int)dword_8170270 >> 1) & 1) + 4])
  {
    l.str = (uint8 *)"non-empty swept list";
    l.len = 20;
    runtime_throw(l);
    BUG();
  }
  qword_81702C8 = 0LL;
  runtime_unlock(&runtime_mheap_.lock);
  if (mode == 2)
  {
    runtime_lock(&runtime_mheap_.lock);
    dbl_81702E0 = 0.0;
    runtime_unlock(&runtime_mheap_.lock);
    while (runtime_sweepone() != -1)
      ++runtime_sweep.npausesweep;
    runtime_prepareFreeWorkbufs();
    while (runtime_freeSomeWbufs(0))
      ;
    runtime_mProf_NextCycle();
    runtime_mProf_Flush();
  }
  else
  {
    runtime_lock(&runtime_sweep.lock);
    if (runtime_sweep.parked)
    {
      runtime_sweep.parked = 0;
      runtime_ready(runtime_sweep.g, 0, 1);
    }
    runtime_unlock(&runtime_sweep.lock);
  }
}
// 8170270: using guessed type int dword_8170270;
// 8170294: using guessed type _DWORD dword_8170294[11];
// 81702E0: using guessed type double dbl_81702E0;

//----- (08063110) --------------------------------------------------------
// runtime.deductSweepCredit
void __golang runtime_deductSweepCredit(uintptr spanBytes, uintptr callerSweepPages)
{
  int v2;                 // esi
  __int64 v3;             // rax
  int v4;                 // ebx
  int v5;                 // esi
  long double d_4;        // [esp+4h] [ebp-2Ch]
  __int64 sweptBasis_lo;  // [esp+10h] [ebp-20h]
  __int64 pagesTarget_lo; // [esp+18h] [ebp-18h]
  double v9;              // [esp+28h] [ebp-8h]

  if (dbl_81702E0 != 0.0)
  {
    if (runtime_trace.enabled)
      runtime_traceGCSweepStart();
  LABEL_7:
    runtime_internal_atomic_Load64();
    sweptBasis_lo = *(_QWORD *)&d_4;
    runtime_internal_atomic_Load64();
    v9 = dbl_81702E0;
    runtime_uint32tofloat64();
    *(_QWORD *)((char *)&d_4 + 4) = runtime_float64toint64(v9 * *(double *)&d_4);
    pagesTarget_lo = *(_QWORD *)((char *)&d_4 + 4) - callerSweepPages;
    while (1)
    {
      runtime_internal_atomic_Load64();
      v3 = *(_QWORD *)&d_4 - sweptBasis_lo;
      v4 = v2;
      LOBYTE(v4) = HIDWORD(pagesTarget_lo) == (unsigned __int64)(*(_QWORD *)&d_4 - sweptBasis_lo) >> 32;
      LOBYTE(v3) = (unsigned int)pagesTarget_lo > LODWORD(d_4) - (int)sweptBasis_lo;
      v5 = v3 & v4;
      LOBYTE(v3) = SHIDWORD(pagesTarget_lo) > (int)((unsigned __int64)(*(_QWORD *)&d_4 - sweptBasis_lo) >> 32);
      v2 = v3 | v5;
      if (!(_BYTE)v2)
        break;
      if (runtime_gosweepone() == -1)
      {
        dbl_81702E0 = 0.0;
        break;
      }
      runtime_internal_atomic_Load64();
      if (LODWORD(d_4) != (_DWORD)sweptBasis_lo || DWORD1(d_4) != HIDWORD(sweptBasis_lo))
        goto LABEL_7;
    }
    if (runtime_trace.enabled)
      runtime_traceGCSweepDone();
  }
}
// 8063110: could not find valid save-restore pair for ebx
// 8063110: could not find valid save-restore pair for ebp
// 8063110: could not find valid save-restore pair for edi
// 806317A: variable 'd_4' is possibly undefined
// 806318C: variable 'v2' is possibly undefined
// 81702D8: using guessed type int dword_81702D8;
// 81702E0: using guessed type double dbl_81702E0;

//----- (0806A7E0) --------------------------------------------------------
// runtime.unminit
// attributes: thunk
void __golang runtime_unminit()
{
  runtime_unminitSignals();
}

//----- (0806AAA0) --------------------------------------------------------
// runtime.panicindex
void __golang __noreturn runtime_panicindex()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_indexError);
  tab = runtime_indexError.tab;
  if (runtime_indexError.tab)
    tab = runtime_indexError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_indexError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AB00) --------------------------------------------------------
// runtime.panicslice
void __golang __noreturn runtime_panicslice()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_sliceError);
  tab = runtime_sliceError.tab;
  if (runtime_sliceError.tab)
    tab = runtime_sliceError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_sliceError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AB60) --------------------------------------------------------
// runtime.panicdivide
void __golang __noreturn runtime_panicdivide()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_divideError);
  tab = runtime_divideError.tab;
  if (runtime_divideError.tab)
    tab = runtime_divideError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_divideError.data, (unsigned int)tab));
  BUG();
}

//----- (0806ABC0) --------------------------------------------------------
// runtime.panicoverflow
void __golang __noreturn runtime_panicoverflow()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_overflowError);
  tab = runtime_overflowError.tab;
  if (runtime_overflowError.tab)
    tab = runtime_overflowError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_overflowError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AC20) --------------------------------------------------------
// runtime.panicfloat
void __golang __noreturn runtime_panicfloat()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_floatError);
  tab = runtime_floatError.tab;
  if (runtime_floatError.tab)
    tab = runtime_floatError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_floatError.data, (unsigned int)tab));
  BUG();
}

//----- (0806AC80) --------------------------------------------------------
// runtime.panicmem
void __golang __noreturn runtime_panicmem()
{
  void *tab; // eax

  runtime_panicCheckMalloc(runtime_memoryError);
  tab = runtime_memoryError.tab;
  if (runtime_memoryError.tab)
    tab = runtime_memoryError.tab->_type;
  runtime_gopanic((interface_)__PAIR64__((unsigned int)runtime_memoryError.data, (unsigned int)tab));
  BUG();
}

//----- (0806ACE0) --------------------------------------------------------
// runtime.throwinit
void __golang __noreturn runtime_throwinit()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"recursive call during initialization - linker skew";
  s.len = 50;
  runtime_throw(s);
  BUG();
}

//----- (0806BF10) --------------------------------------------------------
// runtime.getargp
uintptr __golang runtime_getargp(__int32 x)
{
  return (uintptr)&x;
}
// 806BF14: returning address of temporary local variable '%x'

//----- (0806BF70) --------------------------------------------------------
// runtime.startpanic
void __golang runtime_startpanic()
{
  runtime_systemstack();
}

//----- (0806CA60) --------------------------------------------------------
// runtime.printsp
void __golang runtime_printsp()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)" ";
  s.len = 1;
  runtime_printstring(s);
}
// 80FCDF4: using guessed type char go_string__ptr_;

//----- (0806CAA0) --------------------------------------------------------
// runtime.printnl
void __golang runtime_printnl()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"\n";
  s.len = 1;
  runtime_printstring(s);
}
// 80FCE0D: using guessed type char asc_80FCE0D;

//----- (0806CB40) --------------------------------------------------------
// runtime.printfloat
void __golang runtime_printfloat(float64 v)
{
  long double v1; // fst7
  bool v2;        // zf
  int v3;         // eax
  int i;          // ecx
  int v5;         // edx
  int v6;         // ebp
  int v7;         // eax
  int v8;         // ecx
  long double v9; // fst7
  int v10;        // ecx
  _slice_uint8 b; // [esp+0h] [ebp-38h]
  string ba;      // [esp+0h] [ebp-38h]
  string bb;      // [esp+0h] [ebp-38h]
  double h;       // [esp+10h] [ebp-28h]
  uint8 buf[14];  // [esp+2Ah] [ebp-Eh] BYREF

  v1 = v + v;
  v2 = v == v1;
  if (v == v1)
  {
    if (v > 0.0)
    {
      bb.str = (uint8 *)"+Inf";
      bb.len = 4;
      runtime_printstring(bb);
      return;
    }
    v2 = v == (double)v1;
  }
  if (v2 && v < 0.0)
  {
    ba.str = (uint8 *)"-Inf";
    ba.len = 4;
    runtime_printstring(ba);
  }
  else
  {
    strcpy((char *)buf, "+");
    memset(&buf[2], 0, 12);
    if (0.0 == v)
    {
      if (1.0 / v < 0.0)
        buf[0] = 45;
      v3 = 0;
    }
    else
    {
      if (v < 0.0)
      {
        buf[0] = 45;
        v = -v;
      }
      v7 = 0;
      while (v >= 10.0)
      {
        ++v7;
        v = v / 10.0;
      }
      while (v < 1.0)
      {
        --v7;
        v = v * 10.0;
      }
      v8 = 0;
      h = 5.0;
      while (v8 < 7)
      {
        ++v8;
        h = h / 10.0;
      }
      v9 = h + v;
      v = v9;
      if (v9 < 10.0)
      {
        v10 = v7;
      }
      else
      {
        v10 = v7 + 1;
        v = v / 10.0;
      }
      v3 = v10;
    }
    for (i = 0; i < 7; ++i)
    {
      if ((unsigned int)(i + 2) >= 0xE)
        runtime_panicindex();
      v5 = (int)v;
      buf[i + 2] = v5 + 48;
      v = (v - (long double)v5) * 10.0;
    }
    buf[1] = buf[2];
    buf[2] = 46;
    *(_WORD *)&buf[9] = 11109;
    if (v3 < 0)
    {
      buf[10] = 45;
      v3 = -v3;
    }
    buf[11] = (char)v3 / 100 + 48;
    v6 = ((int)((unsigned __int64)(3435973837LL * v3) >> 32) >> 3) - (v3 >> 31);
    buf[12] = v6 - 10 * ((410 * (unsigned int)(unsigned __int8)v6) >> 12) + 48;
    buf[13] = v3 - 10 * v6 + 48;
    b.array = buf;
    *(_QWORD *)&b.len = 0xE0000000ELL;
    runtime_gwrite(b);
  }
}

//----- (0806DB60) --------------------------------------------------------
// runtime.Gosched
void __golang runtime_Gosched()
{
  runtime_mcall();
}

//----- (0806E520) --------------------------------------------------------
// runtime.badmcall
void __golang __noreturn runtime_badmcall(func_ptr_runtime_g fn)
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"runtime: mcall called on m->g0 stack";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0806E5A0) --------------------------------------------------------
// runtime.badreflectcall
void __golang __noreturn runtime_badreflectcall()
{
  interface_ e; // [esp+0h] [ebp-8h]

  e._type = (runtime__type_0 *)&RTYPE_runtime_plainError_0;
  e.data = &runtime_statictmp_21;
  runtime_gopanic(e);
  BUG();
}

//----- (08078E10) --------------------------------------------------------
// syscall.runtime_envs
_slice_string __golang syscall_runtime_envs()
{
  string *array;         // eax
  unsigned __int32 len;  // ecx
  unsigned __int32 cap;  // edx
  runtime_slice_0 dst;   // [esp+4h] [ebp-28h]
  runtime_slice_0 dsta;  // [esp+4h] [ebp-28h]
  runtime_slice_0 src_4; // [esp+14h] [ebp-18h]
  __int32 v6;            // [esp+20h] [ebp-Ch]
  __int32 v7;            // [esp+24h] [ebp-8h]
  string *v8;            // [esp+28h] [ebp-4h]
  _slice_string _r0;     // [esp+30h] [ebp+4h]

  dst.array = runtime_newobject((runtime__type_0 *)&RTYPE__0_string);
  array = (string *)dst.array;
  len = runtime_envs.len;
  v7 = runtime_envs.len;
  if (runtime_envs.len)
  {
    *(_QWORD *)&dst.len = 0LL;
    src_4 = runtime_growslice((runtime__type_0 *)&RTYPE_string_0, dst, runtime_envs.len);
    cap = src_4.cap;
    array = (string *)src_4.array;
    len = v7;
  }
  else
  {
    cap = 0;
  }
  if (len > cap)
    runtime_panicslice();
  v6 = cap;
  v8 = array;
  dsta.array = array;
  *(_QWORD *)&dsta.len = __PAIR64__(cap, len);
  runtime_typedslicecopy((runtime__type_0 *)&RTYPE_string_0, dsta, (runtime_slice_0)runtime_envs);
  _r0.array = v8;
  _r0.len = v7;
  _r0.cap = v6;
  return _r0;
}

//----- (08078F00) --------------------------------------------------------
// os.runtime_args
_slice_string __golang os_runtime_args()
{
  string *array;         // eax
  unsigned __int32 len;  // ecx
  unsigned __int32 cap;  // edx
  runtime_slice_0 dst;   // [esp+4h] [ebp-28h]
  runtime_slice_0 dsta;  // [esp+4h] [ebp-28h]
  runtime_slice_0 src_4; // [esp+14h] [ebp-18h]
  __int32 v6;            // [esp+20h] [ebp-Ch]
  __int32 v7;            // [esp+24h] [ebp-8h]
  string *v8;            // [esp+28h] [ebp-4h]
  _slice_string _r0;     // [esp+30h] [ebp+4h]

  dst.array = runtime_newobject((runtime__type_0 *)&RTYPE__0_string);
  array = (string *)dst.array;
  len = runtime_argslice.len;
  v7 = runtime_argslice.len;
  if (runtime_argslice.len)
  {
    *(_QWORD *)&dst.len = 0LL;
    src_4 = runtime_growslice((runtime__type_0 *)&RTYPE_string_0, dst, runtime_argslice.len);
    cap = src_4.cap;
    array = (string *)src_4.array;
    len = v7;
  }
  else
  {
    cap = 0;
  }
  if (len > cap)
    runtime_panicslice();
  v6 = cap;
  v8 = array;
  dsta.array = array;
  *(_QWORD *)&dsta.len = __PAIR64__(cap, len);
  runtime_typedslicecopy((runtime__type_0 *)&RTYPE_string_0, dsta, (runtime_slice_0)runtime_argslice);
  _r0.array = v8;
  _r0.len = v7;
  _r0.cap = v6;
  return _r0;
}

//----- (080796A0) --------------------------------------------------------
// runtime.check
void __golang runtime_check()
{
  string v;  // [esp+0h] [ebp-3Ch]
  string va; // [esp+0h] [ebp-3Ch]
  string vb; // [esp+0h] [ebp-3Ch]
  char rem;  // [esp+Ch] [ebp-30h]
  int32 e;   // [esp+20h] [ebp-1Ch] BYREF
  float64 j; // [esp+24h] [ebp-18h]
  void *k;   // [esp+38h] [ebp-4h]

  e = 0;
  j = 0.0;
  k = 0;
  if (runtime_timediv(0xB3A4B57CE31LL, 1000000000, &e) == 12345 && e == 54321)
  {
    runtime_internal_atomic_Cas();
    if (rem)
    {
      v.str = (uint8 *)"cas2";
      v.len = 4;
      runtime_throw(v);
      BUG();
    }
    va.str = (uint8 *)"cas1";
    va.len = 4;
    runtime_throw(va);
    BUG();
  }
  vb.str = (uint8 *)"bad timediv";
  vb.len = 11;
  runtime_throw(vb);
  BUG();
}
// 8079798: conditional instruction was optimized away because %rem.1!=0
// 807975A: variable 'rem' is possibly undefined

//----- (0807CB10) --------------------------------------------------------
// os.sigpipe
void __golang os_sigpipe()
{
  runtime_systemstack();
}

//----- (08080D60) --------------------------------------------------------
// runtime.morestackc
void __golang runtime_morestackc()
{
  runtime_systemstack();
}

//----- (08089980) --------------------------------------------------------
// runtime.(*_type).typeOff
runtime__type_0 *__golang runtime__ptr__type_typeOff(runtime__type_0 *t, runtime_typeOff off)
{
  return runtime_resolveTypeOff(t, off);
}

//----- (0808BD30) --------------------------------------------------------
// runtime.float64toint64
uint64 __golang runtime_float64toint64(float64 d)
{
  uint64 y; // [esp+18h] [ebp+Ch] BYREF

  y = 0LL;
  runtime__d2v(&y, d);
  return y;
}

//----- (0808BD80) --------------------------------------------------------
// runtime.float64touint64
uint64 __golang runtime_float64touint64(float64 d)
{
  uint64 y; // [esp+18h] [ebp+Ch] BYREF

  y = 0LL;
  runtime__d2v(&y, d);
  return y;
}

//----- (0808BDD0) --------------------------------------------------------
// runtime.int64tofloat64
float64 __golang runtime_int64tofloat64(int64 y)
{
  double v1; // [esp+4h] [ebp-1Ch]

  runtime_uint32tofloat64();
  runtime_uint32tofloat64();
  if (y >= 0)
    return v1 + v1 * 4294967296.0;
  else
    return -(v1 + 4294967296.0 * v1);
}
// 808BE37: variable 'v1' is possibly undefined

//----- (0808BF30) --------------------------------------------------------
// runtime._d2v
void __golang runtime__d2v(uint64 *y, float64 d)
{
  uint64 v2;       // rax
  unsigned int v3; // ebp
  int v4;          // ebx
  unsigned int v5; // esi
  unsigned int v6; // ecx
  int v7;          // ebp
  int v8;          // [esp+8h] [ebp-Ch]

  LODWORD(v2) = LODWORD(d);
  HIDWORD(v2) = HIDWORD(d) & 0xFFFFF | 0x100000;
  v3 = HIDWORD(d);
  v4 = (HIDWORD(d) >> 20) & 0x7FF;
  v5 = v4 - 1075;
  v6 = 1075 - v4;
  if (1075 - v4 < 0)
  {
    if (v5 > 0xB)
    {
      runtime_float64touint32();
      HIDWORD(v2) = v8;
      LODWORD(v2) = 0;
    }
    else
    {
      v7 = -(v5 < 0x20);
      LODWORD(v2) = v7 & (LODWORD(d) << v5);
      HIDWORD(v2) = ((unsigned int)(1107 - v4) < 0x20 ? LODWORD(d) >> (83 - (HIDWORD(d) >> 20)) : 0) | v7 & (HIDWORD(v2) << v5);
    }
    v3 = HIDWORD(d);
  }
  else if (v6 >= 0x20)
  {
    if (v6 != 32)
    {
      if (v6 >= 0x40)
        HIDWORD(v2) = 0;
      else
        HIDWORD(v2) = v6 - 32 < 0x20 ? HIDWORD(v2) >> (v6 - 32) : 0;
    }
    v2 = HIDWORD(v2);
  }
  else if (v6)
  {
    LODWORD(v2) = (32 - v6 < 0x20 ? HIDWORD(v2) << (32 - v6) : 0) | (v6 < 0x20 ? LODWORD(d) >> v6 : 0);
    HIDWORD(v2) = (((unsigned __int64)v6 - 32) >> 32) & (HIDWORD(v2) >> v6);
  }
  if (v3 >> 31 << 31)
  {
    if ((_DWORD)v2)
    {
      LODWORD(v2) = -(int)v2;
      HIDWORD(v2) = ~HIDWORD(v2);
    }
    else
    {
      HIDWORD(v2) = -HIDWORD(v2);
    }
  }
  *y = v2;
}
// 808C03A: variable 'v8' is possibly undefined

//----- (0808C8E0) --------------------------------------------------------
// runtime.cgoCheckTypedBlock.func2
void __golang __noreturn runtime_cgoCheckTypedBlock_func2()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"Go pointer stored into non-Go memory";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0808C920) --------------------------------------------------------
// runtime.cgoCheckBits.func1
void __golang __noreturn runtime_cgoCheckBits_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"Go pointer stored into non-Go memory";
  s.len = 36;
  runtime_throw(s);
  BUG();
}

//----- (0808CF10) --------------------------------------------------------
// runtime.gcMarkDone.func1
void __golang runtime_gcMarkDone_func1()
{
  runtime_forEachP(off_810450C);
}

//----- (0808E860) --------------------------------------------------------
// runtime.morestackc.func1
void __golang __noreturn runtime_morestackc_func1()
{
  string s; // [esp+0h] [ebp-8h]

  s.str = (uint8 *)"attempt to execute system stack code on user stack";
  s.len = 50;
  runtime_throw(s);
  BUG();
}

//----- (0808EF20) --------------------------------------------------------
// runtime.asminit
void __golang runtime_asminit()
{
  ;
}

//----- (0808F0F0) --------------------------------------------------------
// runtime.morestack_noctxt
void __golang runtime_morestack_noctxt()
{
  runtime_morestack();
}

//----- (08090A30) --------------------------------------------------------
// runtime.return0
void __golang runtime_return0()
{
  ;
}

//----- (08090A40) --------------------------------------------------------
// runtime.goexit
void __golang __noreturn runtime_goexit()
{
  runtime_goexit1();
}

//----- (08091780) --------------------------------------------------------
// runtime.sigreturn
void __golang runtime_sigreturn()
{
  __asm
  {
    int     80h; LINUX - sys_rt_sigreturn
    int     3; - software interrupt to invoke the debugger
  }
}

//----- (08091990) --------------------------------------------------------
// runtime.osyield
void __golang runtime_osyield()
{
  __asm { int     80h; LINUX - sys_sched_yield }
}

//----- (08091FF0) --------------------------------------------------------
// type..eq.runtime.MemStats
bool __golang type__eq_runtime_MemStats(runtime_MemStats_0 *p, runtime_MemStats_0 *q)
{
  bool v3; // [esp+Ch] [ebp-Ch]

  runtime_memequal();
  if (!v3)
    return 0;
  if (p->GCCPUFraction != q->GCCPUFraction)
    return 0;
  if (p->EnableGC != q->EnableGC)
    return 0;
  if (p->DebugGC != q->DebugGC)
    return 0;
  runtime_memequal();
  return v3;
}
// 809202C: variable 'v3' is possibly undefined

//----- (08092520) --------------------------------------------------------
// type..hash.runtime.markBits
uintptr __golang type__hash_runtime_markBits(runtime_markBits_0 *p, uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 5u);
  return runtime_memhash(&p->index, seed, 4u);
}

//----- (08092B60) --------------------------------------------------------
// type..eq.runtime.gcControllerState
bool __golang type__eq_runtime_gcControllerState(runtime_gcControllerState_0 *p, runtime_gcControllerState_0 *q)
{
  char v3; // [esp+Ch] [ebp-Ch]

  runtime_memequal();
  if (!v3)
    return 0;
  if (p->assistWorkPerByte == q->assistWorkPerByte)
    return p->assistBytesPerWork == q->assistBytesPerWork && q->fractionalUtilizationGoal == p->fractionalUtilizationGoal;
  return 0;
}
// 8092B9C: variable 'v3' is possibly undefined

//----- (080930A0) --------------------------------------------------------
// type..eq.runtime.mstats
bool __golang type__eq_runtime_mstats(runtime_mstats_0 *p, runtime_mstats_0 *q)
{
  runtime_mstats_0 *v2; // ecx
  runtime_mstats_0 *v3; // eax
  bool v4;              // dl
  bool v6;              // [esp+Ch] [ebp-Ch]

  runtime_memequal();
  if (v6)
  {
    v2 = q;
    v3 = p;
    if (p->gc_cpu_fraction == q->gc_cpu_fraction)
    {
      if (q->enablegc == p->enablegc)
      {
        if (q->debuggc == p->debuggc)
        {
          runtime_memequal();
          v4 = v6;
          v3 = p;
          v2 = q;
        }
        else
        {
          v4 = 0;
        }
      }
      else
      {
        v4 = 0;
      }
    }
    else
    {
      v4 = 0;
    }
  }
  else
  {
    v3 = p;
    v2 = q;
    v4 = 0;
  }
  if (!v4)
    return 0;
  if (v3->triggerRatio != v2->triggerRatio)
    return 0;
  runtime_memequal();
  return v6;
}
// 80930DC: variable 'v6' is possibly undefined

//----- (080934A0) --------------------------------------------------------
// type..hash.runtime.symbol_key
uintptr __golang type__hash_runtime_symbol_key(runtime_symbol_key_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  return runtime_memhash(&p->sym_hash, s, 0xCu);
}

//----- (08093A50) --------------------------------------------------------
// type..eq.[33]float64
bool __golang type__eq__33_float64(float64 (*p)[33], float64 (*q)[33])
{
  int i; // edx

  for (i = 0; i < 33; ++i)
  {
    if ((*p)[i] != (*q)[i])
      return 0;
  }
  return 1;
}

//----- (08094090) --------------------------------------------------------
// type..hash.struct { runtime.enabled bool; runtime.pad [3]uint8; runtime.needed bool; runtime.cgo bool; runtime.alignme uint64 }
uintptr __golang type__hash_struct__runtime_enabled_bool_runtime_pad__3_uint8_runtime_needed_bool_runtime_cgo_bool_runtime_alignme_uint64_(
    struct__runtime_enabled_bool_runtime_pad__3_uint8_runtime_needed_bool_runtime_cgo_bool_runtime_alignme_uint64_ *p,
    uintptr h)
{
  uintptr seed; // [esp+Ch] [ebp-4h]

  seed = runtime_memhash(p, h, 6u);
  return runtime_memhash(&p->alignme, seed, 8u);
}

//----- (08094DD0) --------------------------------------------------------
// strconv.special
retval_8094DD0 __golang strconv_special(string s)
{
  uint8 v1;         // dl
  string s2;        // [esp+8h] [ebp-24h]
  string s2a;       // [esp+8h] [ebp-24h]
  string s2b;       // [esp+8h] [ebp-24h]
  string s2c;       // [esp+8h] [ebp-24h]
  string s2d;       // [esp+8h] [ebp-24h]
  string s2e;       // [esp+8h] [ebp-24h]
  string s2f;       // [esp+8h] [ebp-24h]
  retval_8094DD0 f; // [esp+38h] [ebp+Ch]

  if (s.len)
  {
    v1 = *s.str;
    if (*s.str > 0x49u)
    {
      if (v1 != 78)
      {
        if (v1 == 105)
          goto LABEL_6;
        if (v1 != 110)
          goto LABEL_10;
      }
      s2f.str = (uint8 *)"nan";
      s2f.len = 3;
      if (!strconv_equalIgnoreCase(s, s2f))
        goto LABEL_9;
      f.f = NAN;
      f.ok = 1;
    }
    else
    {
      switch (v1)
      {
      case '+':
        s2d.str = (uint8 *)"+inf";
        s2d.len = 4;
        if (!strconv_equalIgnoreCase(s, s2d))
        {
          s2e.str = (uint8 *)"+infinity";
          s2e.len = 9;
          if (!strconv_equalIgnoreCase(s, s2e))
            goto LABEL_9;
        }
        f.f = INFINITY;
        f.ok = 1;
        break;
      case '-':
        s2b.str = (uint8 *)"-inf";
        s2b.len = 4;
        if (!strconv_equalIgnoreCase(s, s2b))
        {
          s2c.str = (uint8 *)"-infinity";
          s2c.len = 9;
          if (!strconv_equalIgnoreCase(s, s2c))
          {
          LABEL_9:
            f.f = 0.0;
            f.ok = 0;
            return f;
          }
        }
        f.f = -INFINITY;
        f.ok = 1;
        break;
      case 'I':
      LABEL_6:
        s2.str = (uint8 *)"inf";
        s2.len = 3;
        if (strconv_equalIgnoreCase(s, s2) || (s2a.str = (uint8 *)"infinity", s2a.len = 8, strconv_equalIgnoreCase(s, s2a)))
        {
          f.f = INFINITY;
          f.ok = 1;
          return f;
        }
        goto LABEL_9;
      default:
      LABEL_10:
        f.f = 0.0;
        f.ok = 0;
        return f;
      }
    }
  }
  else
  {
    f.f = 0.0;
    f.ok = 0;
  }
  return f;
}

//----- (08095BA0) --------------------------------------------------------
// strconv.atof64exact
retval_8095BA0 __golang strconv_atof64exact(uint64 mantissa, __int32 exp, bool neg)
{
  unsigned __int32 v3; // eax
  double v4;           // [esp+18h] [ebp-8h]
  retval_8095BA0 f;    // [esp+34h] [ebp+14h]

  if (((strconv_float64info.mantbits - 32 < 0x20 ? HIDWORD(mantissa) >> (LOBYTE(strconv_float64info.mantbits) - 32) : 0) | (strconv_float64info.mantbits < 0x20 ? (unsigned int)mantissa >> SLOBYTE(strconv_float64info.mantbits) : 0) | (32 - strconv_float64info.mantbits < 0x20 ? HIDWORD(mantissa) << (32 - LOBYTE(strconv_float64info.mantbits)) : 0)) != 0 || (strconv_float64info.mantbits < 0x20 ? HIDWORD(mantissa) >> SLOBYTE(strconv_float64info.mantbits) : 0) != 0)
  {
    f.f = 0.0;
    f.ok = 0;
  }
  else
  {
    v4 = runtime_uint64tofloat64(mantissa);
    if (neg)
      v4 = -v4;
    v3 = exp;
    if (exp)
    {
      if ((unsigned int)(exp - 1) > 0x24)
      {
        if ((unsigned int)exp < 0xFFFFFFEA)
        {
          f.f = v4;
          f.ok = 0;
        }
        else
        {
          if ((unsigned int)-exp >= strconv_float64pow10.len)
            runtime_panicindex();
          f.f = v4 / strconv_float64pow10.array[-exp];
          f.ok = 1;
        }
      }
      else
      {
        if (exp > 22)
        {
          if ((unsigned int)(exp - 22) >= strconv_float64pow10.len)
            runtime_panicindex();
          v4 = v4 * strconv_float64pow10.array[exp - 22];
          v3 = 22;
        }
        if (v4 > 1.0e15 || v4 < -1.0e15)
        {
          f.f = v4;
          f.ok = 0;
        }
        else
        {
          if (v3 >= strconv_float64pow10.len)
            runtime_panicindex();
          f.f = v4 * strconv_float64pow10.array[v3];
          f.ok = 1;
        }
      }
    }
    else
    {
      f.f = v4;
      f.ok = 1;
    }
  }
  return f;
}

//----- (08095DC0) --------------------------------------------------------
// strconv.atof32exact
retval_8095DC0 __golang strconv_atof32exact(uint64 mantissa, __int32 exp, bool neg)
{
  unsigned __int32 v3; // eax
  float v4;            // [esp+10h] [ebp-Ch]
  float v5;            // [esp+14h] [ebp-8h]
  retval_8095DC0 f;    // [esp+30h] [ebp+14h]

  if (((strconv_float32info.mantbits - 32 < 0x20 ? HIDWORD(mantissa) >> (LOBYTE(strconv_float32info.mantbits) - 32) : 0) | (strconv_float32info.mantbits < 0x20 ? (unsigned int)mantissa >> SLOBYTE(strconv_float32info.mantbits) : 0) | (32 - strconv_float32info.mantbits < 0x20 ? HIDWORD(mantissa) << (32 - LOBYTE(strconv_float32info.mantbits)) : 0)) != 0 || (strconv_float32info.mantbits < 0x20 ? HIDWORD(mantissa) >> SLOBYTE(strconv_float32info.mantbits) : 0) != 0)
  {
    f.f = 0.0;
    f.ok = 0;
  }
  else
  {
    v5 = runtime_uint64tofloat64(mantissa);
    v4 = v5;
    if (neg)
      v4 = -v5;
    v3 = exp;
    if (exp)
    {
      if ((unsigned int)(exp - 1) > 0x10)
      {
        if ((unsigned int)exp < 0xFFFFFFF6)
        {
          f.f = v4;
          f.ok = 0;
        }
        else
        {
          if ((unsigned int)-exp >= strconv_float32pow10.len)
            runtime_panicindex();
          f.f = v4 / strconv_float32pow10.array[-exp];
          f.ok = 1;
        }
      }
      else
      {
        if (exp > 10)
        {
          if ((unsigned int)(exp - 10) >= strconv_float32pow10.len)
            runtime_panicindex();
          v4 = v4 * strconv_float32pow10.array[exp - 10];
          v3 = 10;
        }
        if (v4 > 10000000.0 || v4 < -10000000.0)
        {
          f.f = v4;
          f.ok = 0;
        }
        else
        {
          if (v3 >= strconv_float32pow10.len)
            runtime_panicindex();
          f.f = v4 * strconv_float32pow10.array[v3];
          f.ok = 1;
        }
      }
    }
    else
    {
      f.f = v4;
      f.ok = 1;
    }
  }
  return f;
}

//----- (08096010) --------------------------------------------------------
// strconv.atof32
retval_8096010 __golang strconv_atof32(string s)
{
  runtime_itab_0 *v1;                       // eax
  strconv_NumError_1 *v2;                   // ecx
  strconv_NumError_1 *p_strconv_NumError_1; // eax
  void *v4;                                 // ecx
  strconv_NumError_1 *v5;                   // eax
  void *v6;                                 // ecx
  __int32 v7;                               // eax
  bool v8;                                  // cl
  bool trunc;                               // dl
  unsigned int mantissa;                    // ebp
  unsigned int mantissa_high;               // esi
  strconv_NumError_1 *v12;                  // eax
  runtime_itab_0 *v13;                      // ecx
  void *data;                               // ecx
  retval_8094DD0 exp10;                     // [esp+8h] [ebp-390h]
  retval_8095730 exp10a;                    // [esp+8h] [ebp-390h]
  retval_80952F0 exp10b;                    // [esp+8h] [ebp-390h]
  retval_8098D70 exp10c;                    // [esp+8h] [ebp-390h]
  retval_8095DC0 v19;                       // [esp+10h] [ebp-388h]
  bool neg;                                 // [esp+1Fh] [ebp-379h]
  uint64 mantissa_lo;                       // [esp+28h] [ebp-370h]
  __int32 exp;                              // [esp+34h] [ebp-364h]
  float32 v23;                              // [esp+48h] [ebp-350h]
  strconv_extFloat_0 v24;                   // [esp+50h] [ebp-348h] BYREF
  strconv_decimal_0 d;                      // [esp+60h] [ebp-338h] BYREF
  strconv_NumError_1 *v26;                  // [esp+38Ch] [ebp-Ch]
  strconv_NumError_1 *v27;                  // [esp+390h] [ebp-8h]
  strconv_NumError_1 *v28;                  // [esp+394h] [ebp-4h]
  retval_8096010 f;                         // [esp+3A4h] [ebp+Ch]

  exp10 = strconv_special(s);
  if (exp10.ok)
  {
    v23 = exp10.f;
    f.f = v23;
    f.err.tab = 0;
    f.err.data = 0;
  }
  else
  {
    if (!strconv_optimize)
      goto LABEL_3;
    exp10b = strconv_readFloat(s);
    v7 = exp10b.exp;
    v8 = exp10b.neg;
    trunc = exp10b.trunc;
    mantissa_high = HIDWORD(exp10b.mantissa);
    mantissa = exp10b.mantissa;
    if (!exp10b.ok)
      goto LABEL_3;
    if (!exp10b.trunc)
    {
      exp = exp10b.exp;
      neg = exp10b.neg;
      mantissa_lo = exp10b.mantissa;
      v19 = strconv_atof32exact(exp10b.mantissa, exp10b.exp, exp10b.neg);
      if (v19.ok)
      {
        f.f = v19.f;
        f.err.tab = 0;
        f.err.data = 0;
        return f;
      }
      v7 = exp;
      v8 = neg;
      trunc = 0;
      mantissa_high = HIDWORD(mantissa_lo);
      mantissa = mantissa_lo;
    }
    memset(&v24, 0, 13);
    if (strconv__ptr_extFloat_AssignDecimal(
            &v24,
            __PAIR64__(mantissa_high, mantissa),
            v7,
            v8,
            trunc,
            &strconv_float32info))
    {
      exp10c = strconv__ptr_extFloat_floatBits(&v24, &strconv_float32info);
      if (exp10c.overflow)
      {
        v12 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
        v28 = v12;
        v12->Func.len = 10;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)v12, (uintptr) "ParseFloat");
          v12 = v28;
        }
        else
        {
          v12->Func.ptr = "ParseFloat";
        }
        v12->Num.len = s.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v12->Num, (uintptr)s.str);
          v12 = v28;
        }
        else
        {
          v12->Num.ptr = (char *)s.str;
        }
        data = strconv_ErrRange.data;
        v12->Err.tab = strconv_ErrRange.tab;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v12->Err.data, (uintptr)data);
          v12 = v28;
        }
        else
        {
          v12->Err.data = data;
        }
        v13 = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
      }
      else
      {
        v12 = 0;
        v13 = 0;
      }
      f.f = *(float *)&exp10c.bits;
      f.err.tab = v13;
      f.err.data = v12;
    }
    else
    {
    LABEL_3:
      memset(&d, 0, sizeof(d));
      if (strconv__ptr_decimal_set((_ptr_strconv_decimal)&d, (string_0)s))
      {
        exp10a = strconv__ptr_decimal_floatBits(&d, &strconv_float32info);
        if (exp10a.overflow)
        {
          p_strconv_NumError_1 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
          v27 = p_strconv_NumError_1;
          p_strconv_NumError_1->Func.len = 10;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
          {
            runtime_writebarrierptr((uintptr *)p_strconv_NumError_1, (uintptr) "ParseFloat");
            p_strconv_NumError_1 = v27;
          }
          else
          {
            p_strconv_NumError_1->Func.ptr = "ParseFloat";
          }
          p_strconv_NumError_1->Num.len = s.len;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
          {
            runtime_writebarrierptr((uintptr *)&p_strconv_NumError_1->Num, (uintptr)s.str);
            p_strconv_NumError_1 = v27;
          }
          else
          {
            p_strconv_NumError_1->Num.ptr = (char *)s.str;
          }
          v4 = strconv_ErrRange.data;
          p_strconv_NumError_1->Err.tab = strconv_ErrRange.tab;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
            runtime_writebarrierptr((uintptr *)&p_strconv_NumError_1->Err.data, (uintptr)v4);
          else
            p_strconv_NumError_1->Err.data = v4;
          v1 = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
          v2 = v27;
        }
        else
        {
          v1 = 0;
          v2 = 0;
        }
        f.f = *(float *)&exp10a.b;
        f.err.tab = v1;
        f.err.data = v2;
      }
      else
      {
        v5 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
        v26 = v5;
        v5->Func.len = 10;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)v5, (uintptr) "ParseFloat");
          v5 = v26;
        }
        else
        {
          v5->Func.ptr = "ParseFloat";
        }
        v5->Num.len = s.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v5->Num, (uintptr)s.str);
          v5 = v26;
        }
        else
        {
          v5->Num.ptr = (char *)s.str;
        }
        v6 = strconv_ErrSyntax.data;
        v5->Err.tab = strconv_ErrSyntax.tab;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v5->Err.data, (uintptr)v6);
          v5 = v26;
        }
        else
        {
          v5->Err.data = v6;
        }
        f.f = 0.0;
        f.err.tab = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
        f.err.data = v5;
      }
    }
  }
  return f;
}
// 8096010: could not find valid save-restore pair for esi
// 810FB30: using guessed type runtime__type_0 *go_itab__ptr_strconv_NumError_comma_error[2];

//----- (08096560) --------------------------------------------------------
// strconv.atof64
retval_8096560 __golang strconv_atof64(string s)
{
  runtime_itab_0 *v1;                       // eax
  strconv_NumError_1 *v2;                   // ecx
  strconv_NumError_1 *p_strconv_NumError_1; // eax
  void *v4;                                 // ecx
  strconv_NumError_1 *v5;                   // eax
  void *v6;                                 // ecx
  __int32 v7;                               // eax
  bool v8;                                  // cl
  bool trunc;                               // dl
  unsigned int mantissa;                    // ebp
  unsigned int mantissa_high;               // esi
  strconv_NumError_1 *v12;                  // eax
  runtime_itab_0 *v13;                      // ecx
  void *data;                               // ecx
  retval_8094DD0 exp10;                     // [esp+8h] [ebp-39Ch]
  retval_8095730 exp10a;                    // [esp+8h] [ebp-39Ch]
  retval_80952F0 exp10b;                    // [esp+8h] [ebp-39Ch]
  retval_8098D70 exp10c;                    // [esp+8h] [ebp-39Ch]
  retval_8095BA0 flt;                       // [esp+10h] [ebp-394h]
  bool neg;                                 // [esp+1Fh] [ebp-385h]
  uint64 mantissa_lo;                       // [esp+20h] [ebp-384h]
  __int32 exp;                              // [esp+28h] [ebp-37Ch]
  strconv_extFloat_0 v23;                   // [esp+5Ch] [ebp-348h] BYREF
  strconv_decimal_0 d;                      // [esp+6Ch] [ebp-338h] BYREF
  strconv_NumError_1 *v25;                  // [esp+398h] [ebp-Ch]
  strconv_NumError_1 *v26;                  // [esp+39Ch] [ebp-8h]
  strconv_NumError_1 *v27;                  // [esp+3A0h] [ebp-4h]
  retval_8096560 f;                         // [esp+3B0h] [ebp+Ch]

  exp10 = strconv_special(s);
  if (exp10.ok)
  {
    f.f = exp10.f;
    f.err.tab = 0;
    f.err.data = 0;
  }
  else
  {
    if (!strconv_optimize)
      goto LABEL_3;
    exp10b = strconv_readFloat(s);
    v7 = exp10b.exp;
    v8 = exp10b.neg;
    trunc = exp10b.trunc;
    mantissa_high = HIDWORD(exp10b.mantissa);
    mantissa = exp10b.mantissa;
    if (!exp10b.ok)
      goto LABEL_3;
    if (!exp10b.trunc)
    {
      exp = exp10b.exp;
      neg = exp10b.neg;
      mantissa_lo = exp10b.mantissa;
      flt = strconv_atof64exact(exp10b.mantissa, exp10b.exp, exp10b.neg);
      if (flt.ok)
      {
        f.f = flt.f;
        f.err.tab = 0;
        f.err.data = 0;
        return f;
      }
      v7 = exp;
      v8 = neg;
      trunc = 0;
      mantissa_high = HIDWORD(mantissa_lo);
      mantissa = mantissa_lo;
    }
    memset(&v23, 0, 13);
    if (strconv__ptr_extFloat_AssignDecimal(
            &v23,
            __PAIR64__(mantissa_high, mantissa),
            v7,
            v8,
            trunc,
            &strconv_float64info))
    {
      exp10c = strconv__ptr_extFloat_floatBits(&v23, &strconv_float64info);
      if (exp10c.overflow)
      {
        v12 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
        v27 = v12;
        v12->Func.len = 10;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)v12, (uintptr) "ParseFloat");
          v12 = v27;
        }
        else
        {
          v12->Func.ptr = "ParseFloat";
        }
        v12->Num.len = s.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v12->Num, (uintptr)s.str);
          v12 = v27;
        }
        else
        {
          v12->Num.ptr = (char *)s.str;
        }
        data = strconv_ErrRange.data;
        v12->Err.tab = strconv_ErrRange.tab;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v12->Err.data, (uintptr)data);
          v12 = v27;
        }
        else
        {
          v12->Err.data = data;
        }
        v13 = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
      }
      else
      {
        v12 = 0;
        v13 = 0;
      }
      f.f = *(double *)&exp10c.bits;
      f.err.tab = v13;
      f.err.data = v12;
    }
    else
    {
    LABEL_3:
      memset(&d, 0, sizeof(d));
      if (strconv__ptr_decimal_set((_ptr_strconv_decimal)&d, (string_0)s))
      {
        exp10a = strconv__ptr_decimal_floatBits(&d, &strconv_float64info);
        if (exp10a.overflow)
        {
          p_strconv_NumError_1 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
          v26 = p_strconv_NumError_1;
          p_strconv_NumError_1->Func.len = 10;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
          {
            runtime_writebarrierptr((uintptr *)p_strconv_NumError_1, (uintptr) "ParseFloat");
            p_strconv_NumError_1 = v26;
          }
          else
          {
            p_strconv_NumError_1->Func.ptr = "ParseFloat";
          }
          p_strconv_NumError_1->Num.len = s.len;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
          {
            runtime_writebarrierptr((uintptr *)&p_strconv_NumError_1->Num, (uintptr)s.str);
            p_strconv_NumError_1 = v26;
          }
          else
          {
            p_strconv_NumError_1->Num.ptr = (char *)s.str;
          }
          v4 = strconv_ErrRange.data;
          p_strconv_NumError_1->Err.tab = strconv_ErrRange.tab;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
            runtime_writebarrierptr((uintptr *)&p_strconv_NumError_1->Err.data, (uintptr)v4);
          else
            p_strconv_NumError_1->Err.data = v4;
          v1 = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
          v2 = v26;
        }
        else
        {
          v1 = 0;
          v2 = 0;
        }
        f.f = *(double *)&exp10a.b;
        f.err.tab = v1;
        f.err.data = v2;
      }
      else
      {
        v5 = (strconv_NumError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_strconv_NumError_1);
        v25 = v5;
        v5->Func.len = 10;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)v5, (uintptr) "ParseFloat");
          v5 = v25;
        }
        else
        {
          v5->Func.ptr = "ParseFloat";
        }
        v5->Num.len = s.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v5->Num, (uintptr)s.str);
          v5 = v25;
        }
        else
        {
          v5->Num.ptr = (char *)s.str;
        }
        v6 = strconv_ErrSyntax.data;
        v5->Err.tab = strconv_ErrSyntax.tab;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)&v5->Err.data, (uintptr)v6);
          v5 = v25;
        }
        else
        {
          v5->Err.data = v6;
        }
        f.f = 0.0;
        f.err.tab = (runtime_itab_0 *)go_itab__ptr_strconv_NumError_comma_error;
        f.err.data = v5;
      }
    }
  }
  return f;
}
// 8096560: could not find valid save-restore pair for esi
// 810FB30: using guessed type runtime__type_0 *go_itab__ptr_strconv_NumError_comma_error[2];

//----- (0809B140) --------------------------------------------------------
// strconv.AppendFloat
_slice_uint8 __golang strconv_AppendFloat(_slice_uint8 dst, float64 f, uint8 fmt, __int32 prec, __int32 bitSize)
{
  return strconv_genericFtoa(dst, f, fmt, prec, bitSize);
}

//----- (0809B1C0) --------------------------------------------------------
// strconv.genericFtoa
_slice_uint8 __golang strconv_genericFtoa(_slice_uint8 dst, float64 val, uint8 fmt, __int32 prec, __int32 bitSize)
{
  float v5;                    // edx
  uint32 v6;                   // eax
  strconv_floatInfo *v7;       // ecx
  strconv_floatInfo_0 *flt;    // esi
  unsigned __int64 v9;         // kr00_8
  int v10;                     // edi
  int v11;                     // ecx
  uint64 v12;                  // rax
  char *v13;                   // eax
  int v14;                     // ecx
  unsigned __int32 v15;        // ebx
  unsigned __int32 v16;        // ebp
  uint8 *array;                // esi
  int v18;                     // ecx
  __int32 v19;                 // ecx
  uint8 v20;                   // bl
  unsigned int v21;            // ebp
  __int32 v22;                 // ecx
  unsigned int v23;            // edx
  unsigned int v24;            // edi
  bool v25;                    // dl
  __int32 v26;                 // ebp
  char v27;                    // al
  bool v28;                    // zf
  __int32 nd;                  // edx
  interface_ et;               // [esp+0h] [ebp-134h]
  bool old_8;                  // [esp+Ch] [ebp-128h]
  _BYTE cap[40];               // [esp+10h] [ebp-124h]
  runtime_slice_0 cap_4;       // [esp+14h] [ebp-120h]
  bool neg;                    // [esp+3Eh] [ebp-F6h]
  int mant_lo;                 // [esp+44h] [ebp-F0h]
  uint64 mant_loa;             // [esp+44h] [ebp-F0h]
  __int32 exp;                 // [esp+50h] [ebp-E4h]
  uint32 bits_lo;              // [esp+54h] [ebp-E0h]
  uint32 bits_hi;              // [esp+58h] [ebp-DCh]
  __int32 v40;                 // [esp+60h] [ebp-D4h]
  __int32 v41;                 // [esp+60h] [ebp-D4h]
  unsigned int expbits;        // [esp+74h] [ebp-C0h]
  int v43;                     // [esp+7Ch] [ebp-B8h]
  unsigned int mantbits;       // [esp+84h] [ebp-B0h]
  float v46;                   // [esp+90h] [ebp-A4h]
  strconv_extFloat_0 upper;    // [esp+98h] [ebp-9Ch] BYREF
  strconv_extFloat_0 lower;    // [esp+A8h] [ebp-8Ch] BYREF
  strconv_extFloat_0 f;        // [esp+B8h] [ebp-7Ch] BYREF
  strconv_extFloat_0 v50;      // [esp+C8h] [ebp-6Ch] BYREF
  uint8 buf_0[24];             // [esp+D8h] [ebp-5Ch] BYREF
  uint8 buf[32];               // [esp+F0h] [ebp-44h] BYREF
  uint8 *s_ptr;                // [esp+110h] [ebp-24h]
  strconv_floatInfo_0 *v54;    // [esp+114h] [ebp-20h]
  strconv_decimalSlice_0 digs; // [esp+11Ch] [ebp-18h] BYREF
  __int32 preca;               // [esp+150h] [ebp+1Ch]
  _slice_uint8 _r5;            // [esp+158h] [ebp+24h]

  if (bitSize == 32)
  {
    v46 = val;
    v5 = v46;
    v6 = 0;
    v7 = &strconv_float32info;
  }
  else
  {
    if (bitSize != 64)
    {
      et._type = (runtime__type_0 *)&RTYPE_string_0;
      et.data = &strconv_statictmp_5;
      runtime_gopanic(et);
      BUG();
    }
    v6 = HIDWORD(val);
    v5 = *(float *)&val;
    v7 = &strconv_float64info;
  }
  bits_lo = LODWORD(v5);
  bits_hi = v6;
  mantbits = v7->mantbits;
  flt = v7;
  v43 = v7->mantbits < 0x20 ? 1 << v7->mantbits : 0;
  expbits = v7->expbits;
  neg = ((v6 >> (mantbits + expbits)) & (((unsigned __int64)(expbits + mantbits) - 32) >> 32)) != 0 || ((32 - (expbits + mantbits) < 0x20 ? v6 << (32 - (expbits + mantbits)) : 0) | (mantbits + expbits < 0x20 ? LODWORD(v5) >> (mantbits + expbits) : 0) | (expbits + mantbits - 32 < 0x20 ? v6 >> (expbits + mantbits - 32) : 0)) != 0;
  v10 = (v7->mantbits - 32 < 0x20 ? v6 >> (mantbits - 32) : 0) | (32 - v7->mantbits < 0x20 ? v6 << (32 - mantbits) : 0) | (mantbits < 0x20 ? LODWORD(v5) >> mantbits : 0);
  mant_lo = LODWORD(v5) & (v43 - 1);
  LODWORD(v12) = v10 & (expbits < 0x20 ? (1 << expbits) - 1 : -1);
  v11 = expbits < 0x20 ? (1 << expbits) - 1 : -1;
  HIDWORD(v12) = bits_hi & ((__PAIR64__(
                                 (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20
                                                                                          ? 1u >> (32 - mantbits)
                                                                                          : 0),
                                 v43) -
                             1) >>
                            32);
  if ((_DWORD)v12 != v11)
  {
    if ((v11 & v10) != 0)
    {
      HIDWORD(v12) |= (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20
                                                                               ? 1u >> (32 - mantbits)
                                                                               : 0);
      v18 = v10 & (expbits < 0x20 ? (1 << expbits) - 1 : -1);
      LODWORD(v12) = v43 | mant_lo;
    }
    else
    {
      v18 = v12 + 1;
      LODWORD(v12) = mant_lo;
    }
    v19 = flt->bias + v18;
    v20 = fmt;
    if (fmt == 98)
      return strconv_fmtB(dst, neg, v12, v19, flt);
    if (!strconv_optimize)
      return strconv_bigFtoa(dst, prec, fmt, neg, v12, v19, flt);
    v54 = flt;
    mant_loa = v12;
    exp = v19;
    v21 = v12;
    ((void (*)(void))loc_8090B1A)();
    v22 = prec;
    v24 = v23;
    v25 = prec < 0;
    if (prec >= 0)
    {
      if (fmt != 102)
      {
        if (fmt > 0x47u)
        {
          if (fmt == 101)
            goto LABEL_23;
          if (fmt == 103)
          {
            v28 = prec == 0;
            goto LABEL_32;
          }
        }
        else
        {
          if (fmt == 69)
          {
          LABEL_23:
            v26 = prec + 1;
            goto LABEL_24;
          }
          if (fmt == 71)
          {
            v28 = prec == 0;
          LABEL_32:
            if (v28)
              v22 = 1;
            v26 = v22;
            goto LABEL_24;
          }
        }
        v26 = prec;
      LABEL_24:
        if (v26 <= 15)
        {
          v41 = v22;
          ((void (*)(void))loc_8090B1A)();
          digs.d.array = buf_0;
          digs.d.len = 24;
          digs.d.cap = 24;
          f.exp = 0;
          f.neg = 0;
          f.mant = mant_loa;
          f.exp = exp - flt->mantbits;
          f.neg = neg;
          v27 = strconv__ptr_extFloat_FixedDecimal(&f, &digs, v26);
          v22 = v41;
          v25 = prec < 0;
          v20 = fmt;
          flt = v54;
          v24 = HIDWORD(mant_loa);
        }
        else
        {
          v27 = 0;
        }
        goto LABEL_26;
      }
      v27 = 0;
    LABEL_26:
      if (!v27)
        return strconv_bigFtoa(dst, v22, v20, neg, __PAIR64__(v24, mant_loa), exp, flt);
      preca = v22;
      old_8 = v25;
      ((void (*)(void))loc_8090FF4)();
      return strconv_formatDigits(dst, old_8, neg, *(strconv_decimalSlice_0 *)cap, preca, v20);
    }
    memset(&v50, 0, 13);
    *(retval_8099170 *)&cap[8] = strconv__ptr_extFloat_AssignComputeBounds(&v50, __PAIR64__(v24, v21), exp, neg, flt);
    lower = *(strconv_extFloat_0 *)&cap[8];
    upper = *(strconv_extFloat_0 *)&cap[24];
    ((void (*)(void))loc_8090B18)();
    digs.d.array = buf;
    digs.d.len = 32;
    digs.d.cap = 32;
    cap[0] = strconv__ptr_extFloat_ShortestDecimal(&v50, &digs, &lower, &upper);
    v27 = cap[0];
    if (!cap[0])
      return strconv_bigFtoa(dst, prec, fmt, neg, mant_loa, exp, v54);
    if (fmt > 0x47u)
    {
      switch (fmt)
      {
      case 'e':
      LABEL_43:
        nd = digs.nd - 1;
        if (digs.nd - 1 <= 0)
          nd = 0;
        goto LABEL_45;
      case 'f':
        nd = digs.nd - digs.dp;
        if (digs.nd - digs.dp <= 0)
          nd = 0;
        goto LABEL_45;
      case 'g':
        goto LABEL_47;
      }
    }
    else
    {
      if (fmt == 69)
        goto LABEL_43;
      if (fmt == 71)
      {
      LABEL_47:
        nd = digs.nd;
      LABEL_45:
        v20 = fmt;
        flt = v54;
        v24 = HIDWORD(mant_loa);
        v22 = nd;
        v25 = prec < 0;
        goto LABEL_26;
      }
    }
    nd = prec;
    goto LABEL_45;
  }
  v9 = __PAIR64__(
           (mantbits - 32 < 0x20 ? 1 << (mantbits - 32) : 0) | (32 - mantbits < 0x20 ? 1u >> (32 - mantbits) : 0),
           v43) -
       1;
  if (((unsigned int)v9 & bits_lo) != 0 || (HIDWORD(v9) & bits_hi) != 0)
  {
    v13 = "NaN";
    v14 = 3;
  }
  else
  {
    if (neg)
      v13 = "-Inf";
    else
      v13 = "+Inf";
    v14 = 4;
  }
  v15 = dst.len + v14;
  v40 = dst.len + v14;
  v16 = dst.cap;
  if ((unsigned int)(dst.len + v14) > dst.cap)
  {
    s_ptr = (uint8 *)v13;
    cap_4 = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst, dst.len + v14);
    v16 = cap_4.cap;
    array = (uint8 *)cap_4.array;
    v15 = v40;
  }
  else
  {
    array = dst.array;
  }
  if (v15 > v16)
    runtime_panicslice();
  runtime_memmove();
  _r5.array = array;
  _r5.len = v40;
  _r5.cap = v16;
  return _r5;
}
// 809B4ED: variable 'v23' is possibly undefined
// 809B580: variable 'cap' is possibly undefined

//----- (0809FD20) --------------------------------------------------------
// type..eq.[11]float32
bool __golang type__eq__11_float32(float32 (*p)[11], float32 (*q)[11])
{
  int i; // edx

  for (i = 0; i < 11; ++i)
  {
    if ((*p)[i] != (*q)[i])
      return 0;
  }
  return 1;
}

//----- (0809FDE0) --------------------------------------------------------
// type..eq.[23]float64
bool __golang type__eq__23_float64(float64 (*p)[23], float64 (*q)[23])
{
  int i; // edx

  for (i = 0; i < 23; ++i)
  {
    if ((*p)[i] != (*q)[i])
      return 0;
  }
  return 1;
}

//----- (080A1EA0) --------------------------------------------------------
// sync.init.0
void __golang sync_init_0()
{
  sync_runtime_registerPoolCleanup(f);
}

//----- (080AA2D0) --------------------------------------------------------
// type..hash.time.zone
uintptr __golang type__hash_time_zone(time_zone_0 *p, uintptr h)
{
  uintptr s; // [esp+8h] [ebp-8h]

  s = runtime_strhash(p, h);
  return runtime_memhash(&p->offset, s, 5u);
}

//----- (080BAD20) --------------------------------------------------------
// reflect.Value.Complex
complex128 __golang reflect_Value_Complex(reflect_Value_0 v)
{
  int v1;                                       // eax
  reflect_ValueError_1 *p_reflect_ValueError_1; // eax
  interface_ typ;                               // [esp+0h] [ebp-10h]
  reflect_ValueError_1 *v4;                     // [esp+Ch] [ebp-4h]
  complex128 _r0;                               // [esp+20h] [ebp+10h]

  v1 = v.flag & 0x1F;
  if (v1 == 15)
  {
    _r0.real = *(float *)v.ptr;
    _r0.imag = *((float *)v.ptr + 1);
  }
  else
  {
    if (v1 != 16)
    {
      p_reflect_ValueError_1 = (reflect_ValueError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_reflect_ValueError_1);
      v4 = p_reflect_ValueError_1;
      p_reflect_ValueError_1->Method.len = 21;
      if (*(_DWORD *)&runtime_writeBarrier.enabled)
        runtime_writebarrierptr((uintptr *)p_reflect_ValueError_1, (uintptr) "reflect.Value.Complex");
      else
        p_reflect_ValueError_1->Method.ptr = "reflect.Value.Complex";
      v4->Kind = v.flag & 0x1F;
      typ._type = (runtime__type_0 *)&RTYPE__ptr_reflect_ValueError;
      typ.data = v4;
      runtime_gopanic(typ);
      BUG();
    }
    _r0.real = *(double *)v.ptr;
    _r0.imag = *((double *)v.ptr + 1);
  }
  return _r0;
}

//----- (080BB0B0) --------------------------------------------------------
// reflect.Value.Float
float64 __golang reflect_Value_Float(reflect_Value_0 v)
{
  int v1;                                       // eax
  reflect_ValueError_1 *p_reflect_ValueError_1; // eax
  interface_ typ;                               // [esp+0h] [ebp-10h]
  reflect_ValueError_1 *v4;                     // [esp+Ch] [ebp-4h]

  v1 = v.flag & 0x1F;
  if (v1 == 13)
    return *(float *)v.ptr;
  if (v1 != 14)
  {
    p_reflect_ValueError_1 = (reflect_ValueError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_reflect_ValueError_1);
    v4 = p_reflect_ValueError_1;
    p_reflect_ValueError_1->Method.len = 19;
    if (*(_DWORD *)&runtime_writeBarrier.enabled)
      runtime_writebarrierptr((uintptr *)p_reflect_ValueError_1, (uintptr) "reflect.Value.Float");
    else
      p_reflect_ValueError_1->Method.ptr = "reflect.Value.Float";
    v4->Kind = v.flag & 0x1F;
    typ._type = (runtime__type_0 *)&RTYPE__ptr_reflect_ValueError;
    typ.data = v4;
    runtime_gopanic(typ);
    BUG();
  }
  return *(double *)v.ptr;
}

//----- (080BC300) --------------------------------------------------------
// reflect.Value.SetComplex
void __golang reflect_Value_SetComplex(reflect_Value_0 v, complex128 x)
{
  int v2;                                       // eax
  reflect_ValueError_1 *p_reflect_ValueError_1; // eax
  interface_ v4;                                // [esp+0h] [ebp-18h]
  float real;                                   // [esp+Ch] [ebp-Ch]
  float imag;                                   // [esp+Ch] [ebp-Ch]
  reflect_ValueError_1 *v7;                     // [esp+14h] [ebp-4h]

  reflect_flag_mustBeAssignable(v.flag);
  v2 = v.flag & 0x1F;
  if (v2 == 15)
  {
    real = x.real;
    *(float *)v.ptr = real;
    imag = x.imag;
    *((float *)v.ptr + 1) = imag;
  }
  else
  {
    if (v2 != 16)
    {
      p_reflect_ValueError_1 = (reflect_ValueError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_reflect_ValueError_1);
      v7 = p_reflect_ValueError_1;
      p_reflect_ValueError_1->Method.len = 24;
      if (*(_DWORD *)&runtime_writeBarrier.enabled)
        runtime_writebarrierptr((uintptr *)p_reflect_ValueError_1, (uintptr) "reflect.Value.SetComplex");
      else
        p_reflect_ValueError_1->Method.ptr = "reflect.Value.SetComplex";
      v7->Kind = v.flag & 0x1F;
      v4._type = (runtime__type_0 *)&RTYPE__ptr_reflect_ValueError;
      v4.data = v7;
      runtime_gopanic(v4);
      BUG();
    }
    *(complex128 *)v.ptr = x;
  }
}

//----- (080BC400) --------------------------------------------------------
// reflect.Value.SetFloat
void __golang reflect_Value_SetFloat(reflect_Value_0 v, float64 x)
{
  int v2;                                       // eax
  reflect_ValueError_1 *p_reflect_ValueError_1; // eax
  interface_ v4;                                // [esp+0h] [ebp-18h]
  float v5;                                     // [esp+Ch] [ebp-Ch]
  reflect_ValueError_1 *v6;                     // [esp+14h] [ebp-4h]

  reflect_flag_mustBeAssignable(v.flag);
  v2 = v.flag & 0x1F;
  if (v2 == 13)
  {
    v5 = x;
    *(float *)v.ptr = v5;
  }
  else
  {
    if (v2 != 14)
    {
      p_reflect_ValueError_1 = (reflect_ValueError_1 *)runtime_newobject((runtime__type_0 *)&RTYPE_reflect_ValueError_1);
      v6 = p_reflect_ValueError_1;
      p_reflect_ValueError_1->Method.len = 22;
      if (*(_DWORD *)&runtime_writeBarrier.enabled)
        runtime_writebarrierptr((uintptr *)p_reflect_ValueError_1, (uintptr) "reflect.Value.SetFloat");
      else
        p_reflect_ValueError_1->Method.ptr = "reflect.Value.SetFloat";
      v6->Kind = v.flag & 0x1F;
      v4._type = (runtime__type_0 *)&RTYPE__ptr_reflect_ValueError;
      v4.data = v6;
      runtime_gopanic(v4);
      BUG();
    }
    *(float64 *)v.ptr = x;
  }
}

//----- (080BD9C0) --------------------------------------------------------
// reflect.makeFloat
reflect_Value_0 __golang reflect_makeFloat(reflect_flag f, float64 v, reflect_Type_0 t)
{
  runtime__type_0 *v3;  // [esp+4h] [ebp-10h]
  uintptr v4;           // [esp+8h] [ebp-Ch]
  runtime__type_0 *typ; // [esp+10h] [ebp-4h]
  reflect_Value_0 _r3;  // [esp+2Ch] [ebp+18h]

  typ = (runtime__type_0 *)(*(int(__golang **)(void *))t.tab[6]._)(t.data);
  v3 = (runtime__type_0 *)reflect_unsafe_New(typ);
  if (typ->size == 4)
  {
    *(float *)&v4 = v;
    v3->size = v4;
  }
  else if (typ->size == 8)
  {
    *(float64 *)&v3->size = v;
  }
  _r3.typ = (reflect_rtype *)typ;
  _r3.ptr = v3;
  _r3.flag = f | typ->kind & 0x1F | 0x80;
  return _r3;
}

//----- (080BDA60) --------------------------------------------------------
// reflect.makeComplex
reflect_Value_0 __golang reflect_makeComplex(reflect_flag f, complex128 v, reflect_Type_0 t)
{
  float *v3;            // [esp+4h] [ebp-10h]
  float real;           // [esp+8h] [ebp-Ch]
  float imag;           // [esp+8h] [ebp-Ch]
  runtime__type_0 *typ; // [esp+10h] [ebp-4h]
  reflect_Value_0 _r3;  // [esp+34h] [ebp+20h]

  typ = (runtime__type_0 *)(*(int(__golang **)(void *))t.tab[6]._)(t.data);
  v3 = (float *)reflect_unsafe_New(typ);
  if (typ->size == 8)
  {
    real = v.real;
    *v3 = real;
    imag = v.imag;
    v3[1] = imag;
  }
  else if (typ->size == 16)
  {
    *(complex128 *)v3 = v;
  }
  _r3.typ = (reflect_rtype *)typ;
  _r3.ptr = v3;
  _r3.flag = f | typ->kind & 0x1F | 0x80;
  return _r3;
}

//----- (080BDEB0) --------------------------------------------------------
// reflect.cvtFloatInt
reflect_Value_0 __golang reflect_cvtFloatInt(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2;         // ecx
  long double v3; // [esp+8h] [ebp-1Ch]
  reflect_flag f; // [esp+20h] [ebp-4h]

  if ((v.flag & 0x60) != 0)
    v2 = 32;
  else
    v2 = 0;
  f = v2;
  *(double *)((char *)&v3 + 4) = reflect_Value_Float(v);
  *(_QWORD *)&v3 = runtime_float64toint64(*(float64 *)((char *)&v3 + 4));
  return reflect_makeInt(f, *(uint64 *)&v3, t);
}

//----- (080BDF60) --------------------------------------------------------
// reflect.cvtFloatUint
reflect_Value_0 __golang reflect_cvtFloatUint(reflect_Value_0 v, reflect_Type_0 t)
{
  int v2;         // ecx
  long double v3; // [esp+8h] [ebp-1Ch]
  reflect_flag f; // [esp+20h] [ebp-4h]

  if ((v.flag & 0x60) != 0)
    v2 = 32;
  else
    v2 = 0;
  f = v2;
  *(double *)((char *)&v3 + 4) = reflect_Value_Float(v);
  *(_QWORD *)&v3 = runtime_float64touint64(*(float64 *)((char *)&v3 + 4));
  return reflect_makeInt(f, *(uint64 *)&v3, t);
}

//----- (080BF440) --------------------------------------------------------
// reflect.(*structType).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_structType_uncommon(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_uncommon(&_this->rtype);
}

//----- (080BF470) --------------------------------------------------------
// reflect.(*structType).String
string_0 __golang reflect__ptr_structType_String(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_String(&_this->rtype);
}

//----- (080BF4B0) --------------------------------------------------------
// reflect.(*structType).Size
uintptr_0 __golang reflect__ptr_structType_Size(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Size(&_this->rtype);
}

//----- (080BF4E0) --------------------------------------------------------
// reflect.(*structType).Bits
signed __int32 __golang reflect__ptr_structType_Bits(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Bits(&_this->rtype);
}

//----- (080BF510) --------------------------------------------------------
// reflect.(*structType).Align
signed __int32 __golang reflect__ptr_structType_Align(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Align(&_this->rtype);
}

//----- (080BF540) --------------------------------------------------------
// reflect.(*structType).FieldAlign
signed __int32 __golang reflect__ptr_structType_FieldAlign(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->rtype);
}

//----- (080BF570) --------------------------------------------------------
// reflect.(*structType).Kind
reflect_Kind_0 __golang reflect__ptr_structType_Kind(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Kind(&_this->rtype);
}

//----- (080BF5A0) --------------------------------------------------------
// reflect.(*structType).common
_ptr_reflect_rtype __golang reflect__ptr_structType_common(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_common(&_this->rtype);
}

//----- (080BF5D0) --------------------------------------------------------
// reflect.(*structType).NumMethod
signed __int32 __golang reflect__ptr_structType_NumMethod(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->rtype);
}

//----- (080BF680) --------------------------------------------------------
// reflect.(*structType).PkgPath
string_0 __golang reflect__ptr_structType_PkgPath(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->rtype);
}

//----- (080BF6C0) --------------------------------------------------------
// reflect.(*structType).Name
string_0 __golang reflect__ptr_structType_Name(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Name(&_this->rtype);
}

//----- (080BF700) --------------------------------------------------------
// reflect.(*structType).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_structType_ChanDir(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->rtype);
}

//----- (080BF730) --------------------------------------------------------
// reflect.(*structType).IsVariadic
bool __golang reflect__ptr_structType_IsVariadic(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->rtype);
}

//----- (080BF760) --------------------------------------------------------
// reflect.(*structType).Elem
reflect_Type_1 __golang reflect__ptr_structType_Elem(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Elem(&_this->rtype);
}

//----- (080BF7A0) --------------------------------------------------------
// reflect.(*structType).In
reflect_Type_1 __golang reflect__ptr_structType_In(_ptr_reflect_structType _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->rtype, i);
}

//----- (080BF7E0) --------------------------------------------------------
// reflect.(*structType).Key
reflect_Type_1 __golang reflect__ptr_structType_Key(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Key(&_this->rtype);
}

//----- (080BF820) --------------------------------------------------------
// reflect.(*structType).Len
signed __int32 __golang reflect__ptr_structType_Len(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Len(&_this->rtype);
}

//----- (080BF850) --------------------------------------------------------
// reflect.(*structType).NumField
signed __int32 __golang reflect__ptr_structType_NumField(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_NumField(&_this->rtype);
}

//----- (080BF880) --------------------------------------------------------
// reflect.(*structType).NumIn
signed __int32 __golang reflect__ptr_structType_NumIn(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_NumIn(&_this->rtype);
}

//----- (080BF8B0) --------------------------------------------------------
// reflect.(*structType).NumOut
signed __int32 __golang reflect__ptr_structType_NumOut(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_NumOut(&_this->rtype);
}

//----- (080BF8E0) --------------------------------------------------------
// reflect.(*structType).Out
reflect_Type_1 __golang reflect__ptr_structType_Out(_ptr_reflect_structType _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->rtype, i);
}

//----- (080BF920) --------------------------------------------------------
// reflect.(*structType).Implements
bool __golang reflect__ptr_structType_Implements(_ptr_reflect_structType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->rtype, u);
}

//----- (080BF980) --------------------------------------------------------
// reflect.(*structType).ConvertibleTo
bool __golang reflect__ptr_structType_ConvertibleTo(_ptr_reflect_structType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->rtype, u);
}

//----- (080BF9B0) --------------------------------------------------------
// reflect.(*structType).Comparable
bool __golang reflect__ptr_structType_Comparable(_ptr_reflect_structType _this)
{
  return reflect__ptr_rtype_Comparable(&_this->rtype);
}

//----- (080BF9E0) --------------------------------------------------------
// reflect.(*funcType).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcType_uncommon(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_uncommon(&_this->rtype);
}

//----- (080BFA10) --------------------------------------------------------
// reflect.(*funcType).String
string_0 __golang reflect__ptr_funcType_String(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_String(&_this->rtype);
}

//----- (080BFA50) --------------------------------------------------------
// reflect.(*funcType).Size
uintptr_0 __golang reflect__ptr_funcType_Size(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Size(&_this->rtype);
}

//----- (080BFA80) --------------------------------------------------------
// reflect.(*funcType).Bits
signed __int32 __golang reflect__ptr_funcType_Bits(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Bits(&_this->rtype);
}

//----- (080BFAB0) --------------------------------------------------------
// reflect.(*funcType).Align
signed __int32 __golang reflect__ptr_funcType_Align(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Align(&_this->rtype);
}

//----- (080BFAE0) --------------------------------------------------------
// reflect.(*funcType).FieldAlign
signed __int32 __golang reflect__ptr_funcType_FieldAlign(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->rtype);
}

//----- (080BFB10) --------------------------------------------------------
// reflect.(*funcType).Kind
reflect_Kind_0 __golang reflect__ptr_funcType_Kind(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Kind(&_this->rtype);
}

//----- (080BFB40) --------------------------------------------------------
// reflect.(*funcType).common
_ptr_reflect_rtype __golang reflect__ptr_funcType_common(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_common(&_this->rtype);
}

//----- (080BFB70) --------------------------------------------------------
// reflect.(*funcType).NumMethod
signed __int32 __golang reflect__ptr_funcType_NumMethod(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->rtype);
}

//----- (080BFC20) --------------------------------------------------------
// reflect.(*funcType).PkgPath
string_0 __golang reflect__ptr_funcType_PkgPath(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->rtype);
}

//----- (080BFC60) --------------------------------------------------------
// reflect.(*funcType).Name
string_0 __golang reflect__ptr_funcType_Name(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Name(&_this->rtype);
}

//----- (080BFCA0) --------------------------------------------------------
// reflect.(*funcType).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcType_ChanDir(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->rtype);
}

//----- (080BFCD0) --------------------------------------------------------
// reflect.(*funcType).IsVariadic
bool __golang reflect__ptr_funcType_IsVariadic(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->rtype);
}

//----- (080BFD00) --------------------------------------------------------
// reflect.(*funcType).Elem
reflect_Type_1 __golang reflect__ptr_funcType_Elem(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Elem(&_this->rtype);
}

//----- (080BFE40) --------------------------------------------------------
// reflect.(*funcType).In
reflect_Type_1 __golang reflect__ptr_funcType_In(_ptr_reflect_funcType _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->rtype, i);
}

//----- (080BFE80) --------------------------------------------------------
// reflect.(*funcType).Key
reflect_Type_1 __golang reflect__ptr_funcType_Key(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Key(&_this->rtype);
}

//----- (080BFEC0) --------------------------------------------------------
// reflect.(*funcType).Len
signed __int32 __golang reflect__ptr_funcType_Len(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Len(&_this->rtype);
}

//----- (080BFEF0) --------------------------------------------------------
// reflect.(*funcType).NumField
signed __int32 __golang reflect__ptr_funcType_NumField(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_NumField(&_this->rtype);
}

//----- (080BFF20) --------------------------------------------------------
// reflect.(*funcType).NumIn
signed __int32 __golang reflect__ptr_funcType_NumIn(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_NumIn(&_this->rtype);
}

//----- (080BFF50) --------------------------------------------------------
// reflect.(*funcType).NumOut
signed __int32 __golang reflect__ptr_funcType_NumOut(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_NumOut(&_this->rtype);
}

//----- (080BFF80) --------------------------------------------------------
// reflect.(*funcType).Out
reflect_Type_1 __golang reflect__ptr_funcType_Out(_ptr_reflect_funcType _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->rtype, i);
}

//----- (080BFFC0) --------------------------------------------------------
// reflect.(*funcType).Implements
bool __golang reflect__ptr_funcType_Implements(_ptr_reflect_funcType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->rtype, u);
}

//----- (080C0020) --------------------------------------------------------
// reflect.(*funcType).ConvertibleTo
bool __golang reflect__ptr_funcType_ConvertibleTo(_ptr_reflect_funcType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->rtype, u);
}

//----- (080C0050) --------------------------------------------------------
// reflect.(*funcType).Comparable
bool __golang reflect__ptr_funcType_Comparable(_ptr_reflect_funcType _this)
{
  return reflect__ptr_rtype_Comparable(&_this->rtype);
}

//----- (080C0080) --------------------------------------------------------
// reflect.(*funcTypeFixed128).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed128_uncommon(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C00B0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).String
string_0 __golang reflect__ptr_funcTypeFixed128_String(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C00F0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed128_Size(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C0120) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed128_Bits(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C0150) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Align
signed __int32 __golang reflect__ptr_funcTypeFixed128_Align(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C0180) --------------------------------------------------------
// reflect.(*funcTypeFixed128).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed128_FieldAlign(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C01B0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed128_Kind(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C01E0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed128_common(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C0210) --------------------------------------------------------
// reflect.(*funcTypeFixed128).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumMethod(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C02C0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed128_PkgPath(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C0300) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Name
string_0 __golang reflect__ptr_funcTypeFixed128_Name(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C0340) --------------------------------------------------------
// reflect.(*funcTypeFixed128).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed128_ChanDir(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C0370) --------------------------------------------------------
// reflect.(*funcTypeFixed128).IsVariadic
bool __golang reflect__ptr_funcTypeFixed128_IsVariadic(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C03A0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Elem(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C04E0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_In(_ptr_reflect_funcTypeFixed128 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C0520) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Key(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C0560) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Len
signed __int32 __golang reflect__ptr_funcTypeFixed128_Len(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C0590) --------------------------------------------------------
// reflect.(*funcTypeFixed128).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumField(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C05C0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumIn(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C05F0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed128_NumOut(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C0620) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed128_Out(_ptr_reflect_funcTypeFixed128 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C0660) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Implements
bool __golang reflect__ptr_funcTypeFixed128_Implements(_ptr_reflect_funcTypeFixed128 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C06C0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed128_ConvertibleTo(_ptr_reflect_funcTypeFixed128 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C06F0) --------------------------------------------------------
// reflect.(*funcTypeFixed128).Comparable
bool __golang reflect__ptr_funcTypeFixed128_Comparable(_ptr_reflect_funcTypeFixed128 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C0720) --------------------------------------------------------
// reflect.(*funcTypeFixed16).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed16_uncommon(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C0750) --------------------------------------------------------
// reflect.(*funcTypeFixed16).String
string_0 __golang reflect__ptr_funcTypeFixed16_String(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C0790) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed16_Size(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C07C0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed16_Bits(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C07F0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Align
signed __int32 __golang reflect__ptr_funcTypeFixed16_Align(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C0820) --------------------------------------------------------
// reflect.(*funcTypeFixed16).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed16_FieldAlign(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C0850) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed16_Kind(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C0880) --------------------------------------------------------
// reflect.(*funcTypeFixed16).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed16_common(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C08B0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumMethod(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C0960) --------------------------------------------------------
// reflect.(*funcTypeFixed16).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed16_PkgPath(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C09A0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Name
string_0 __golang reflect__ptr_funcTypeFixed16_Name(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C09E0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed16_ChanDir(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C0A10) --------------------------------------------------------
// reflect.(*funcTypeFixed16).IsVariadic
bool __golang reflect__ptr_funcTypeFixed16_IsVariadic(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C0A40) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Elem(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C0B80) --------------------------------------------------------
// reflect.(*funcTypeFixed16).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_In(_ptr_reflect_funcTypeFixed16 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C0BC0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Key(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C0C00) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Len
signed __int32 __golang reflect__ptr_funcTypeFixed16_Len(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C0C30) --------------------------------------------------------
// reflect.(*funcTypeFixed16).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumField(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C0C60) --------------------------------------------------------
// reflect.(*funcTypeFixed16).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumIn(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C0C90) --------------------------------------------------------
// reflect.(*funcTypeFixed16).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed16_NumOut(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C0CC0) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed16_Out(_ptr_reflect_funcTypeFixed16 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C0D00) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Implements
bool __golang reflect__ptr_funcTypeFixed16_Implements(_ptr_reflect_funcTypeFixed16 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C0D60) --------------------------------------------------------
// reflect.(*funcTypeFixed16).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed16_ConvertibleTo(_ptr_reflect_funcTypeFixed16 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C0D90) --------------------------------------------------------
// reflect.(*funcTypeFixed16).Comparable
bool __golang reflect__ptr_funcTypeFixed16_Comparable(_ptr_reflect_funcTypeFixed16 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C0DC0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed32_uncommon(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C0DF0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).String
string_0 __golang reflect__ptr_funcTypeFixed32_String(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C0E30) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed32_Size(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C0E60) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed32_Bits(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C0E90) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Align
signed __int32 __golang reflect__ptr_funcTypeFixed32_Align(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C0EC0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed32_FieldAlign(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C0EF0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed32_Kind(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C0F20) --------------------------------------------------------
// reflect.(*funcTypeFixed32).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed32_common(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C0F50) --------------------------------------------------------
// reflect.(*funcTypeFixed32).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumMethod(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C1000) --------------------------------------------------------
// reflect.(*funcTypeFixed32).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed32_PkgPath(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C1040) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Name
string_0 __golang reflect__ptr_funcTypeFixed32_Name(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C1080) --------------------------------------------------------
// reflect.(*funcTypeFixed32).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed32_ChanDir(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C10B0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).IsVariadic
bool __golang reflect__ptr_funcTypeFixed32_IsVariadic(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C10E0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Elem(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C1220) --------------------------------------------------------
// reflect.(*funcTypeFixed32).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_In(_ptr_reflect_funcTypeFixed32 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C1260) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Key(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C12A0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Len
signed __int32 __golang reflect__ptr_funcTypeFixed32_Len(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C12D0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumField(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C1300) --------------------------------------------------------
// reflect.(*funcTypeFixed32).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumIn(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C1330) --------------------------------------------------------
// reflect.(*funcTypeFixed32).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed32_NumOut(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C1360) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed32_Out(_ptr_reflect_funcTypeFixed32 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C13A0) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Implements
bool __golang reflect__ptr_funcTypeFixed32_Implements(_ptr_reflect_funcTypeFixed32 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C1400) --------------------------------------------------------
// reflect.(*funcTypeFixed32).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed32_ConvertibleTo(_ptr_reflect_funcTypeFixed32 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C1430) --------------------------------------------------------
// reflect.(*funcTypeFixed32).Comparable
bool __golang reflect__ptr_funcTypeFixed32_Comparable(_ptr_reflect_funcTypeFixed32 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C1460) --------------------------------------------------------
// reflect.(*funcTypeFixed4).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed4_uncommon(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C1490) --------------------------------------------------------
// reflect.(*funcTypeFixed4).String
string_0 __golang reflect__ptr_funcTypeFixed4_String(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C14D0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed4_Size(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C1500) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed4_Bits(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C1530) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Align
signed __int32 __golang reflect__ptr_funcTypeFixed4_Align(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C1560) --------------------------------------------------------
// reflect.(*funcTypeFixed4).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed4_FieldAlign(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C1590) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed4_Kind(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C15C0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed4_common(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C15F0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumMethod(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C16A0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed4_PkgPath(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C16E0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Name
string_0 __golang reflect__ptr_funcTypeFixed4_Name(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C1720) --------------------------------------------------------
// reflect.(*funcTypeFixed4).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed4_ChanDir(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C1750) --------------------------------------------------------
// reflect.(*funcTypeFixed4).IsVariadic
bool __golang reflect__ptr_funcTypeFixed4_IsVariadic(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C1780) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Elem(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C18C0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_In(_ptr_reflect_funcTypeFixed4 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C1900) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Key(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C1940) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Len
signed __int32 __golang reflect__ptr_funcTypeFixed4_Len(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C1970) --------------------------------------------------------
// reflect.(*funcTypeFixed4).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumField(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C19A0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumIn(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C19D0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed4_NumOut(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C1A00) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed4_Out(_ptr_reflect_funcTypeFixed4 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C1A40) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Implements
bool __golang reflect__ptr_funcTypeFixed4_Implements(_ptr_reflect_funcTypeFixed4 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C1AA0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed4_ConvertibleTo(_ptr_reflect_funcTypeFixed4 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C1AD0) --------------------------------------------------------
// reflect.(*funcTypeFixed4).Comparable
bool __golang reflect__ptr_funcTypeFixed4_Comparable(_ptr_reflect_funcTypeFixed4 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C1B00) --------------------------------------------------------
// reflect.(*funcTypeFixed64).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed64_uncommon(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C1B30) --------------------------------------------------------
// reflect.(*funcTypeFixed64).String
string_0 __golang reflect__ptr_funcTypeFixed64_String(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C1B70) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed64_Size(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C1BA0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed64_Bits(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C1BD0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Align
signed __int32 __golang reflect__ptr_funcTypeFixed64_Align(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C1C00) --------------------------------------------------------
// reflect.(*funcTypeFixed64).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed64_FieldAlign(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C1C30) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed64_Kind(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C1C60) --------------------------------------------------------
// reflect.(*funcTypeFixed64).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed64_common(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C1C90) --------------------------------------------------------
// reflect.(*funcTypeFixed64).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumMethod(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C1D40) --------------------------------------------------------
// reflect.(*funcTypeFixed64).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed64_PkgPath(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C1D80) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Name
string_0 __golang reflect__ptr_funcTypeFixed64_Name(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C1DC0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed64_ChanDir(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C1DF0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).IsVariadic
bool __golang reflect__ptr_funcTypeFixed64_IsVariadic(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C1E20) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Elem(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C1F60) --------------------------------------------------------
// reflect.(*funcTypeFixed64).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_In(_ptr_reflect_funcTypeFixed64 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C1FA0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Key(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C1FE0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Len
signed __int32 __golang reflect__ptr_funcTypeFixed64_Len(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C2010) --------------------------------------------------------
// reflect.(*funcTypeFixed64).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumField(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C2040) --------------------------------------------------------
// reflect.(*funcTypeFixed64).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumIn(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C2070) --------------------------------------------------------
// reflect.(*funcTypeFixed64).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed64_NumOut(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C20A0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed64_Out(_ptr_reflect_funcTypeFixed64 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C20E0) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Implements
bool __golang reflect__ptr_funcTypeFixed64_Implements(_ptr_reflect_funcTypeFixed64 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C2140) --------------------------------------------------------
// reflect.(*funcTypeFixed64).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed64_ConvertibleTo(_ptr_reflect_funcTypeFixed64 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C2170) --------------------------------------------------------
// reflect.(*funcTypeFixed64).Comparable
bool __golang reflect__ptr_funcTypeFixed64_Comparable(_ptr_reflect_funcTypeFixed64 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C21A0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_funcTypeFixed8_uncommon(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_uncommon(&_this->funcType.rtype);
}

//----- (080C21D0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).String
string_0 __golang reflect__ptr_funcTypeFixed8_String(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_String(&_this->funcType.rtype);
}

//----- (080C2210) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Size
uintptr_0 __golang reflect__ptr_funcTypeFixed8_Size(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Size(&_this->funcType.rtype);
}

//----- (080C2240) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Bits
signed __int32 __golang reflect__ptr_funcTypeFixed8_Bits(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Bits(&_this->funcType.rtype);
}

//----- (080C2270) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Align
signed __int32 __golang reflect__ptr_funcTypeFixed8_Align(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Align(&_this->funcType.rtype);
}

//----- (080C22A0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).FieldAlign
signed __int32 __golang reflect__ptr_funcTypeFixed8_FieldAlign(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->funcType.rtype);
}

//----- (080C22D0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Kind
reflect_Kind_0 __golang reflect__ptr_funcTypeFixed8_Kind(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Kind(&_this->funcType.rtype);
}

//----- (080C2300) --------------------------------------------------------
// reflect.(*funcTypeFixed8).common
_ptr_reflect_rtype __golang reflect__ptr_funcTypeFixed8_common(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_common(&_this->funcType.rtype);
}

//----- (080C2330) --------------------------------------------------------
// reflect.(*funcTypeFixed8).NumMethod
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumMethod(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->funcType.rtype);
}

//----- (080C23E0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).PkgPath
string_0 __golang reflect__ptr_funcTypeFixed8_PkgPath(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->funcType.rtype);
}

//----- (080C2420) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Name
string_0 __golang reflect__ptr_funcTypeFixed8_Name(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Name(&_this->funcType.rtype);
}

//----- (080C2460) --------------------------------------------------------
// reflect.(*funcTypeFixed8).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_funcTypeFixed8_ChanDir(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->funcType.rtype);
}

//----- (080C2490) --------------------------------------------------------
// reflect.(*funcTypeFixed8).IsVariadic
bool __golang reflect__ptr_funcTypeFixed8_IsVariadic(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->funcType.rtype);
}

//----- (080C24C0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Elem
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Elem(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Elem(&_this->funcType.rtype);
}

//----- (080C2600) --------------------------------------------------------
// reflect.(*funcTypeFixed8).In
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_In(_ptr_reflect_funcTypeFixed8 _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->funcType.rtype, i);
}

//----- (080C2640) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Key
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Key(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Key(&_this->funcType.rtype);
}

//----- (080C2680) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Len
signed __int32 __golang reflect__ptr_funcTypeFixed8_Len(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Len(&_this->funcType.rtype);
}

//----- (080C26B0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).NumField
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumField(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_NumField(&_this->funcType.rtype);
}

//----- (080C26E0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).NumIn
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumIn(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_NumIn(&_this->funcType.rtype);
}

//----- (080C2710) --------------------------------------------------------
// reflect.(*funcTypeFixed8).NumOut
signed __int32 __golang reflect__ptr_funcTypeFixed8_NumOut(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_NumOut(&_this->funcType.rtype);
}

//----- (080C2740) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Out
reflect_Type_1 __golang reflect__ptr_funcTypeFixed8_Out(_ptr_reflect_funcTypeFixed8 _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->funcType.rtype, i);
}

//----- (080C2780) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Implements
bool __golang reflect__ptr_funcTypeFixed8_Implements(_ptr_reflect_funcTypeFixed8 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->funcType.rtype, u);
}

//----- (080C27E0) --------------------------------------------------------
// reflect.(*funcTypeFixed8).ConvertibleTo
bool __golang reflect__ptr_funcTypeFixed8_ConvertibleTo(_ptr_reflect_funcTypeFixed8 _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->funcType.rtype, u);
}

//----- (080C2810) --------------------------------------------------------
// reflect.(*funcTypeFixed8).Comparable
bool __golang reflect__ptr_funcTypeFixed8_Comparable(_ptr_reflect_funcTypeFixed8 _this)
{
  return reflect__ptr_rtype_Comparable(&_this->funcType.rtype);
}

//----- (080C2840) --------------------------------------------------------
// reflect.(*interfaceType).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_interfaceType_uncommon(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_uncommon(&_this->rtype);
}

//----- (080C2870) --------------------------------------------------------
// reflect.(*interfaceType).String
string_0 __golang reflect__ptr_interfaceType_String(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_String(&_this->rtype);
}

//----- (080C28B0) --------------------------------------------------------
// reflect.(*interfaceType).Size
uintptr_0 __golang reflect__ptr_interfaceType_Size(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Size(&_this->rtype);
}

//----- (080C28E0) --------------------------------------------------------
// reflect.(*interfaceType).Bits
signed __int32 __golang reflect__ptr_interfaceType_Bits(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Bits(&_this->rtype);
}

//----- (080C2910) --------------------------------------------------------
// reflect.(*interfaceType).Align
signed __int32 __golang reflect__ptr_interfaceType_Align(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Align(&_this->rtype);
}

//----- (080C2940) --------------------------------------------------------
// reflect.(*interfaceType).FieldAlign
signed __int32 __golang reflect__ptr_interfaceType_FieldAlign(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->rtype);
}

//----- (080C2970) --------------------------------------------------------
// reflect.(*interfaceType).Kind
reflect_Kind_0 __golang reflect__ptr_interfaceType_Kind(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Kind(&_this->rtype);
}

//----- (080C29A0) --------------------------------------------------------
// reflect.(*interfaceType).common
_ptr_reflect_rtype __golang reflect__ptr_interfaceType_common(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_common(&_this->rtype);
}

//----- (080C29D0) --------------------------------------------------------
// reflect.(*interfaceType).PkgPath
string_0 __golang reflect__ptr_interfaceType_PkgPath(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->rtype);
}

//----- (080C2A10) --------------------------------------------------------
// reflect.(*interfaceType).Name
string_0 __golang reflect__ptr_interfaceType_Name(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Name(&_this->rtype);
}

//----- (080C2A50) --------------------------------------------------------
// reflect.(*interfaceType).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_interfaceType_ChanDir(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->rtype);
}

//----- (080C2A80) --------------------------------------------------------
// reflect.(*interfaceType).IsVariadic
bool __golang reflect__ptr_interfaceType_IsVariadic(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->rtype);
}

//----- (080C2AB0) --------------------------------------------------------
// reflect.(*interfaceType).Elem
reflect_Type_1 __golang reflect__ptr_interfaceType_Elem(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Elem(&_this->rtype);
}

//----- (080C2BF0) --------------------------------------------------------
// reflect.(*interfaceType).In
reflect_Type_1 __golang reflect__ptr_interfaceType_In(_ptr_reflect_interfaceType _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->rtype, i);
}

//----- (080C2C30) --------------------------------------------------------
// reflect.(*interfaceType).Key
reflect_Type_1 __golang reflect__ptr_interfaceType_Key(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Key(&_this->rtype);
}

//----- (080C2C70) --------------------------------------------------------
// reflect.(*interfaceType).Len
signed __int32 __golang reflect__ptr_interfaceType_Len(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Len(&_this->rtype);
}

//----- (080C2CA0) --------------------------------------------------------
// reflect.(*interfaceType).NumField
signed __int32 __golang reflect__ptr_interfaceType_NumField(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_NumField(&_this->rtype);
}

//----- (080C2CD0) --------------------------------------------------------
// reflect.(*interfaceType).NumIn
signed __int32 __golang reflect__ptr_interfaceType_NumIn(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_NumIn(&_this->rtype);
}

//----- (080C2D00) --------------------------------------------------------
// reflect.(*interfaceType).NumOut
signed __int32 __golang reflect__ptr_interfaceType_NumOut(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_NumOut(&_this->rtype);
}

//----- (080C2D30) --------------------------------------------------------
// reflect.(*interfaceType).Out
reflect_Type_1 __golang reflect__ptr_interfaceType_Out(_ptr_reflect_interfaceType _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->rtype, i);
}

//----- (080C2D70) --------------------------------------------------------
// reflect.(*interfaceType).Implements
bool __golang reflect__ptr_interfaceType_Implements(_ptr_reflect_interfaceType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->rtype, u);
}

//----- (080C2DD0) --------------------------------------------------------
// reflect.(*interfaceType).ConvertibleTo
bool __golang reflect__ptr_interfaceType_ConvertibleTo(_ptr_reflect_interfaceType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->rtype, u);
}

//----- (080C2E00) --------------------------------------------------------
// reflect.(*interfaceType).Comparable
bool __golang reflect__ptr_interfaceType_Comparable(_ptr_reflect_interfaceType _this)
{
  return reflect__ptr_rtype_Comparable(&_this->rtype);
}

//----- (080C2F20) --------------------------------------------------------
// reflect.(*ptrType).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_ptrType_uncommon(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_uncommon(&_this->rtype);
}

//----- (080C2F50) --------------------------------------------------------
// reflect.(*ptrType).String
string_0 __golang reflect__ptr_ptrType_String(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_String(&_this->rtype);
}

//----- (080C2F90) --------------------------------------------------------
// reflect.(*ptrType).Size
uintptr_0 __golang reflect__ptr_ptrType_Size(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Size(&_this->rtype);
}

//----- (080C2FC0) --------------------------------------------------------
// reflect.(*ptrType).Bits
signed __int32 __golang reflect__ptr_ptrType_Bits(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Bits(&_this->rtype);
}

//----- (080C2FF0) --------------------------------------------------------
// reflect.(*ptrType).Align
signed __int32 __golang reflect__ptr_ptrType_Align(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Align(&_this->rtype);
}

//----- (080C3020) --------------------------------------------------------
// reflect.(*ptrType).FieldAlign
signed __int32 __golang reflect__ptr_ptrType_FieldAlign(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->rtype);
}

//----- (080C3050) --------------------------------------------------------
// reflect.(*ptrType).Kind
reflect_Kind_0 __golang reflect__ptr_ptrType_Kind(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Kind(&_this->rtype);
}

//----- (080C3080) --------------------------------------------------------
// reflect.(*ptrType).common
_ptr_reflect_rtype __golang reflect__ptr_ptrType_common(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_common(&_this->rtype);
}

//----- (080C30B0) --------------------------------------------------------
// reflect.(*ptrType).NumMethod
signed __int32 __golang reflect__ptr_ptrType_NumMethod(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->rtype);
}

//----- (080C3160) --------------------------------------------------------
// reflect.(*ptrType).PkgPath
string_0 __golang reflect__ptr_ptrType_PkgPath(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->rtype);
}

//----- (080C31A0) --------------------------------------------------------
// reflect.(*ptrType).Name
string_0 __golang reflect__ptr_ptrType_Name(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Name(&_this->rtype);
}

//----- (080C31E0) --------------------------------------------------------
// reflect.(*ptrType).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_ptrType_ChanDir(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->rtype);
}

//----- (080C3210) --------------------------------------------------------
// reflect.(*ptrType).IsVariadic
bool __golang reflect__ptr_ptrType_IsVariadic(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->rtype);
}

//----- (080C3240) --------------------------------------------------------
// reflect.(*ptrType).Elem
reflect_Type_1 __golang reflect__ptr_ptrType_Elem(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Elem(&_this->rtype);
}

//----- (080C3380) --------------------------------------------------------
// reflect.(*ptrType).In
reflect_Type_1 __golang reflect__ptr_ptrType_In(_ptr_reflect_ptrType _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->rtype, i);
}

//----- (080C33C0) --------------------------------------------------------
// reflect.(*ptrType).Key
reflect_Type_1 __golang reflect__ptr_ptrType_Key(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Key(&_this->rtype);
}

//----- (080C3400) --------------------------------------------------------
// reflect.(*ptrType).Len
signed __int32 __golang reflect__ptr_ptrType_Len(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Len(&_this->rtype);
}

//----- (080C3430) --------------------------------------------------------
// reflect.(*ptrType).NumField
signed __int32 __golang reflect__ptr_ptrType_NumField(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_NumField(&_this->rtype);
}

//----- (080C3460) --------------------------------------------------------
// reflect.(*ptrType).NumIn
signed __int32 __golang reflect__ptr_ptrType_NumIn(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_NumIn(&_this->rtype);
}

//----- (080C3490) --------------------------------------------------------
// reflect.(*ptrType).NumOut
signed __int32 __golang reflect__ptr_ptrType_NumOut(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_NumOut(&_this->rtype);
}

//----- (080C34C0) --------------------------------------------------------
// reflect.(*ptrType).Out
reflect_Type_1 __golang reflect__ptr_ptrType_Out(_ptr_reflect_ptrType _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->rtype, i);
}

//----- (080C3500) --------------------------------------------------------
// reflect.(*ptrType).Implements
bool __golang reflect__ptr_ptrType_Implements(_ptr_reflect_ptrType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->rtype, u);
}

//----- (080C3560) --------------------------------------------------------
// reflect.(*ptrType).ConvertibleTo
bool __golang reflect__ptr_ptrType_ConvertibleTo(_ptr_reflect_ptrType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->rtype, u);
}

//----- (080C3590) --------------------------------------------------------
// reflect.(*ptrType).Comparable
bool __golang reflect__ptr_ptrType_Comparable(_ptr_reflect_ptrType _this)
{
  return reflect__ptr_rtype_Comparable(&_this->rtype);
}

//----- (080C35C0) --------------------------------------------------------
// reflect.(*sliceType).uncommon
_ptr_reflect_uncommonType __golang reflect__ptr_sliceType_uncommon(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_uncommon(&_this->rtype);
}

//----- (080C35F0) --------------------------------------------------------
// reflect.(*sliceType).String
string_0 __golang reflect__ptr_sliceType_String(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_String(&_this->rtype);
}

//----- (080C3630) --------------------------------------------------------
// reflect.(*sliceType).Size
uintptr_0 __golang reflect__ptr_sliceType_Size(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Size(&_this->rtype);
}

//----- (080C3660) --------------------------------------------------------
// reflect.(*sliceType).Bits
signed __int32 __golang reflect__ptr_sliceType_Bits(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Bits(&_this->rtype);
}

//----- (080C3690) --------------------------------------------------------
// reflect.(*sliceType).Align
signed __int32 __golang reflect__ptr_sliceType_Align(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Align(&_this->rtype);
}

//----- (080C36C0) --------------------------------------------------------
// reflect.(*sliceType).FieldAlign
signed __int32 __golang reflect__ptr_sliceType_FieldAlign(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_FieldAlign(&_this->rtype);
}

//----- (080C36F0) --------------------------------------------------------
// reflect.(*sliceType).Kind
reflect_Kind_0 __golang reflect__ptr_sliceType_Kind(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Kind(&_this->rtype);
}

//----- (080C3720) --------------------------------------------------------
// reflect.(*sliceType).common
_ptr_reflect_rtype __golang reflect__ptr_sliceType_common(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_common(&_this->rtype);
}

//----- (080C3750) --------------------------------------------------------
// reflect.(*sliceType).NumMethod
signed __int32 __golang reflect__ptr_sliceType_NumMethod(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_NumMethod(&_this->rtype);
}

//----- (080C3800) --------------------------------------------------------
// reflect.(*sliceType).PkgPath
string_0 __golang reflect__ptr_sliceType_PkgPath(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_PkgPath(&_this->rtype);
}

//----- (080C3840) --------------------------------------------------------
// reflect.(*sliceType).Name
string_0 __golang reflect__ptr_sliceType_Name(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Name(&_this->rtype);
}

//----- (080C3880) --------------------------------------------------------
// reflect.(*sliceType).ChanDir
reflect_ChanDir_0 __golang reflect__ptr_sliceType_ChanDir(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_ChanDir(&_this->rtype);
}

//----- (080C38B0) --------------------------------------------------------
// reflect.(*sliceType).IsVariadic
bool __golang reflect__ptr_sliceType_IsVariadic(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_IsVariadic(&_this->rtype);
}

//----- (080C38E0) --------------------------------------------------------
// reflect.(*sliceType).Elem
reflect_Type_1 __golang reflect__ptr_sliceType_Elem(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Elem(&_this->rtype);
}

//----- (080C3A20) --------------------------------------------------------
// reflect.(*sliceType).In
reflect_Type_1 __golang reflect__ptr_sliceType_In(_ptr_reflect_sliceType _this, signed __int32 i)
{
  return reflect__ptr_rtype_In(&_this->rtype, i);
}

//----- (080C3A60) --------------------------------------------------------
// reflect.(*sliceType).Key
reflect_Type_1 __golang reflect__ptr_sliceType_Key(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Key(&_this->rtype);
}

//----- (080C3AA0) --------------------------------------------------------
// reflect.(*sliceType).Len
signed __int32 __golang reflect__ptr_sliceType_Len(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Len(&_this->rtype);
}

//----- (080C3AD0) --------------------------------------------------------
// reflect.(*sliceType).NumField
signed __int32 __golang reflect__ptr_sliceType_NumField(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_NumField(&_this->rtype);
}

//----- (080C3B00) --------------------------------------------------------
// reflect.(*sliceType).NumIn
signed __int32 __golang reflect__ptr_sliceType_NumIn(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_NumIn(&_this->rtype);
}

//----- (080C3B30) --------------------------------------------------------
// reflect.(*sliceType).NumOut
signed __int32 __golang reflect__ptr_sliceType_NumOut(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_NumOut(&_this->rtype);
}

//----- (080C3B60) --------------------------------------------------------
// reflect.(*sliceType).Out
reflect_Type_1 __golang reflect__ptr_sliceType_Out(_ptr_reflect_sliceType _this, signed __int32 i)
{
  return reflect__ptr_rtype_Out(&_this->rtype, i);
}

//----- (080C3BA0) --------------------------------------------------------
// reflect.(*sliceType).Implements
bool __golang reflect__ptr_sliceType_Implements(_ptr_reflect_sliceType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_Implements(&_this->rtype, u);
}

//----- (080C3C00) --------------------------------------------------------
// reflect.(*sliceType).ConvertibleTo
bool __golang reflect__ptr_sliceType_ConvertibleTo(_ptr_reflect_sliceType _this, reflect_Type_1 u)
{
  return reflect__ptr_rtype_ConvertibleTo(&_this->rtype, u);
}

//----- (080C3C30) --------------------------------------------------------
// reflect.(*sliceType).Comparable
bool __golang reflect__ptr_sliceType_Comparable(_ptr_reflect_sliceType _this)
{
  return reflect__ptr_rtype_Comparable(&_this->rtype);
}

//----- (080C5880) --------------------------------------------------------
// fmt.(*fmt).fmt_float
void __golang fmt__ptr_fmt_fmt_float(fmt_fmt *f, float64 v, __int32 size, int32 verb, __int32 prec)
{
  __int32 v5;               // ecx
  unsigned __int32 len;     // eax
  uint8 v7;                 // bl
  uint8 *array;             // ebp
  __int32 cap;              // ecx
  uint8 v10;                // bl
  int v11;                  // ebx
  unsigned int v12;         // esi
  int v13;                  // edi
  uint8 v14;                // dl
  int v15;                  // edx
  int v16;                  // edi
  unsigned __int32 v17;     // ebx
  int v18;                  // ecx
  unsigned __int32 v19;     // ebp
  __int32 v20;              // esi
  unsigned int v21;         // esi
  __int32 v22;              // eax
  __int32 v23;              // ecx
  uint8 *v24;               // edx
  fmt_fmt *v25;             // ebx
  uintptr *buf;             // ebp
  uint8 v27;                // si
  __int32 v28;              // edi
  uint8 *v29;               // edx
  signed __int32 v30;       // eax
  uintptr v31;              // edx
  unsigned int v32;         // ebp
  unsigned __int32 v33;     // esi
  uint8 *v34;               // edi
  uintptr *v35;             // ecx
  uint8 *v36;               // eax
  __int32 v37;              // ecx
  uintptr *v38;             // ebx
  __int32 v39;              // esi
  __int32 v40;              // ebx
  __int32 v41;              // ebx
  _slice_uint8 dst;         // [esp+0h] [ebp-94h]
  _slice_uint8 dst_4;       // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4a;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4c;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4d;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4e;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4f;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4b;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4g;      // [esp+4h] [ebp-90h]
  _slice_uint8 dst_4h;      // [esp+4h] [ebp-90h]
  runtime_slice_0 fmta;     // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtb;     // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtd;     // [esp+14h] [ebp-80h]
  runtime_slice_0 fmt;      // [esp+14h] [ebp-80h]
  runtime_slice_0 fmtc;     // [esp+14h] [ebp-80h]
  runtime_slice_0 fmte;     // [esp+14h] [ebp-80h]
  _slice_uint8 appended;    // [esp+20h] [ebp-74h]
  bool oldZero;             // [esp+2Dh] [ebp-67h]
  bool hasDecimalPoint;     // [esp+2Eh] [ebp-66h]
  __int64 tail_len;         // [esp+30h] [ebp-64h]
  __int32 num_len;          // [esp+38h] [ebp-5Ch]
  __int32 num_lena;         // [esp+38h] [ebp-5Ch]
  __int32 num_lenb;         // [esp+38h] [ebp-5Ch]
  unsigned __int32 num_cap; // [esp+3Ch] [ebp-58h]
  __int32 num_capb;         // [esp+3Ch] [ebp-58h]
  __int32 num_capa;         // [esp+3Ch] [ebp-58h]
  __int32 digits;           // [esp+44h] [ebp-50h]
  __int32 digitsa;          // [esp+44h] [ebp-50h]
  unsigned __int32 v70;     // [esp+50h] [ebp-44h]
  __int32 v71;              // [esp+50h] [ebp-44h]
  uint8 tailBuf[5];         // [esp+57h] [ebp-3Dh] BYREF
  fmt_fmt *v73;             // [esp+5Ch] [ebp-38h]
  int v74;                  // [esp+64h] [ebp-30h]
  unsigned __int32 v75;     // [esp+6Ch] [ebp-28h]
  uint8 *tail_ptr;          // [esp+74h] [ebp-20h]
  uint8 *p_ptr;             // [esp+78h] [ebp-1Ch]
  uint8 *num_ptr;           // [esp+7Ch] [ebp-18h]
  uintptr *v79;             // [esp+80h] [ebp-14h]
  uintptr *v80;             // [esp+84h] [ebp-10h]
  uint8 *v81;               // [esp+88h] [ebp-Ch]
  uintptr src;              // [esp+8Ch] [ebp-8h]
  int v83;                  // [esp+90h] [ebp-4h]

  if (f->fmtFlags.precPresent)
    v5 = f->prec;
  else
    v5 = prec;
  digits = v5;
  dst.array = f->intbuf;
  *(_QWORD *)&dst.len = 0x4400000001LL;
  appended = strconv_AppendFloat(dst, v, verb, v5, size);
  len = appended.len;
  if (appended.len <= 1u)
    runtime_panicindex();
  v7 = appended.array[1];
  array = appended.array + 1;
  if (v7 == 45 || v7 == 43)
  {
    len = appended.len - 1;
    cap = appended.cap - 1;
  }
  else
  {
    *appended.array = 43;
    array = appended.array;
    cap = appended.cap;
  }
  if (f->fmtFlags.space)
  {
    if (!len)
      runtime_panicindex();
    if (*array == 43 && !f->fmtFlags.plus)
      *array = 32;
  }
  if (len <= 1)
    runtime_panicindex();
  v10 = array[1];
  if (v10 == 73 || v10 == 78)
  {
    oldZero = f->fmtFlags.zero;
    f->fmtFlags.zero = 0;
    if (array[1] == 78 && !f->fmtFlags.space && !f->fmtFlags.plus)
    {
      --len;
      --cap;
      ++array;
    }
    dst_4h.array = array;
    *(_QWORD *)&dst_4h.len = __PAIR64__(cap, len);
    fmt__ptr_fmt_pad(f, dst_4h);
    f->fmtFlags.zero = oldZero;
  }
  else
  {
    if (f->fmtFlags.sharp)
    {
      if (verb == 98)
      {
        v24 = array;
        v40 = len;
        v22 = cap;
        v23 = v40;
      }
      else
      {
        if (verb == 71 || verb == 103 || verb == 118)
        {
          v11 = digits;
          if (digits == -1)
            v11 = 6;
        }
        else
        {
          v11 = 0;
        }
        num_ptr = array;
        num_cap = cap;
        memset(tailBuf, 0, sizeof(tailBuf));
        v12 = 1;
        v13 = 0;
        v75 = len;
        tail_ptr = tailBuf;
        v74 = cap;
        tail_len = 0x500000000LL;
        v73 = f;
        while (1)
        {
          digitsa = v11;
          if ((int)v12 >= (int)len)
            break;
          if (v12 >= len)
            runtime_panicindex();
          v14 = array[v12];
          if (v14 == 46)
          {
            v15 = 1;
            v16 = HIDWORD(tail_len);
          }
          else if (v14 == 69 || v14 == 101)
          {
            hasDecimalPoint = v13;
            v17 = len - v12 + tail_len;
            v70 = v17;
            v18 = (int)&array[v12 & ((int)(v12 - cap) >> 31)];
            v19 = HIDWORD(tail_len);
            if (v17 > HIDWORD(tail_len))
            {
              v83 = v18;
              dst_4.array = tail_ptr;
              *(_QWORD *)&dst_4.len = tail_len;
              fmta = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst_4, v17);
              v19 = fmta.cap;
              tail_ptr = (uint8 *)fmta.array;
            }
            if (v17 > v19)
              runtime_panicslice();
            HIDWORD(tail_len) = v19;
            runtime_memmove();
            len = v12;
            cap = num_cap;
            if (v12 > num_cap)
              runtime_panicslice();
            array = num_ptr;
            v11 = digitsa;
            v16 = HIDWORD(tail_len);
            LODWORD(tail_len) = v70;
            v15 = hasDecimalPoint;
          }
          else
          {
            --v11;
            v15 = v13;
            v16 = HIDWORD(tail_len);
          }
          ++v12;
          HIDWORD(tail_len) = v16;
          v13 = v15;
        }
        if (!(_BYTE)v13)
        {
          v39 = len + 1;
          if ((int)(len + 1) > cap)
          {
            num_lenb = len;
            dst_4g.array = array;
            *(_QWORD *)&dst_4g.len = __PAIR64__(cap, len);
            fmte = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst_4g, len + 1);
            array = (uint8 *)fmte.array;
            cap = fmte.cap;
            v39 = fmte.len + 1;
            len = num_lenb;
          }
          array[len] = 46;
          len = v39;
        }
        while (1)
        {
          num_len = len;
          if (v11 <= 0)
            break;
          v20 = len + 1;
          if ((int)(len + 1) > cap)
          {
            dst_4a.array = array;
            *(_QWORD *)&dst_4a.len = __PAIR64__(cap, len);
            fmtb = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst_4a, len + 1);
            array = (uint8 *)fmtb.array;
            cap = fmtb.cap;
            v20 = fmtb.len + 1;
            len = num_len;
          }
          array[len] = 48;
          --v11;
          len = v20;
        }
        v21 = tail_len + len;
        v71 = tail_len + len;
        if ((unsigned int)tail_len + len > cap)
        {
          dst_4b.array = array;
          *(_QWORD *)&dst_4b.len = __PAIR64__(cap, len);
          fmtc = runtime_growslice(
              (runtime__type_0 *)&RTYPE_uint8_0,
              (runtime_slice_0)dst_4b,
              (unsigned int)tail_len + len);
          array = (uint8 *)fmtc.array;
          cap = fmtc.cap;
          v21 = v71;
        }
        if (v21 > cap)
          runtime_panicslice();
        num_ptr = array;
        num_capb = cap;
        runtime_memmove();
        v22 = num_capb;
        v23 = v71;
        v24 = num_ptr;
      }
    }
    else
    {
      v24 = array;
      v41 = len;
      v22 = cap;
      v23 = v41;
    }
    v25 = f;
    if (f->fmtFlags.plus)
      goto LABEL_46;
    if (!v23)
      runtime_panicindex();
    if (*v24 != 43)
    {
    LABEL_46:
      if (f->fmtFlags.zero && f->fmtFlags.widPresent && f->wid > v23)
      {
        buf = (uintptr *)f->buf;
        if (!v23)
          runtime_panicindex();
        num_capa = v22;
        num_lena = v23;
        num_ptr = v24;
        v27 = *v24;
        v28 = buf[1];
        v29 = (uint8 *)*buf;
        v30 = buf[2];
        if (v28 + 1 > v30)
        {
          v80 = buf;
          dst_4d.array = v29;
          *(_QWORD *)&dst_4d.len = __PAIR64__(v30, v28);
          fmt = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst_4d, v28 + 1);
          v36 = (uint8 *)fmt.array;
          v37 = fmt.len;
          v38 = v80;
          v80[2] = fmt.cap;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
          {
            v81 = (uint8 *)fmt.array;
            runtime_writebarrierptr(v38, (uintptr)fmt.array);
            v36 = v81;
            v37 = fmt.len;
            v38 = v80;
          }
          else
          {
            *v38 = (uintptr)fmt.array;
          }
          buf = v38;
          v28 = v37;
          v29 = v36;
          v25 = f;
        }
        buf[1] = v28 + 1;
        v29[v28] = v27;
        fmt__ptr_fmt_writePadding(v25, v25->wid - num_lena);
        v79 = (uintptr *)f->buf;
        v31 = v79[1];
        v32 = num_lena + v31 - 1;
        v33 = v79[2];
        v34 = (uint8 *)*v79;
        if (v32 > v33)
        {
          p_ptr = &num_ptr[((1 - num_capa) >> 31) & 1];
          dst_4c.array = v34;
          *(_QWORD *)&dst_4c.len = __PAIR64__(v33, v31);
          fmtd = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)dst_4c, num_lena + v31 - 1);
          v34 = (uint8 *)fmtd.array;
          v33 = fmtd.cap;
        }
        if (v32 > v33)
          runtime_panicslice();
        src = (uintptr)v34;
        runtime_memmove();
        v35 = v79;
        v79[1] = v32;
        v35[2] = v33;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
          runtime_writebarrierptr(v35, src);
        else
          *v35 = src;
      }
      else
      {
        dst_4e.array = v24;
        *(_QWORD *)&dst_4e.len = __PAIR64__(v22, v23);
        fmt__ptr_fmt_pad(f, dst_4e);
      }
    }
    else
    {
      dst_4f.array = &v24[((1 - v22) >> 31) & 1];
      dst_4f.len = v23 - 1;
      dst_4f.cap = v22 - 1;
      fmt__ptr_fmt_pad(f, dst_4f);
    }
  }
}

//----- (080C7630) --------------------------------------------------------
// fmt.(*pp).fmtFloat
void __golang fmt__ptr_pp_fmtFloat(fmt_pp *p, float64 v, __int32 size, int32 verb)
{
  if (verb > 71)
  {
    if (verb > 102)
    {
      if (verb == 103)
        goto LABEL_6;
      if (verb == 118)
      {
        fmt__ptr_fmt_fmt_float(&p->fmt, v, size, 103, -1);
        return;
      }
    }
    else
    {
      if (verb == 98)
        goto LABEL_6;
      if ((unsigned int)(verb - 101) <= 1)
        goto LABEL_3;
    }
  LABEL_7:
    fmt__ptr_pp_badVerb(p, verb);
    return;
  }
  if (verb == 69)
  {
  LABEL_3:
    fmt__ptr_fmt_fmt_float(&p->fmt, v, size, verb, 6);
    return;
  }
  if (verb != 70)
  {
    if (verb == 71)
    {
    LABEL_6:
      fmt__ptr_fmt_fmt_float(&p->fmt, v, size, verb, -1);
      return;
    }
    goto LABEL_7;
  }
  fmt__ptr_fmt_fmt_float(&p->fmt, v, size, 102, 6);
}

//----- (080C7790) --------------------------------------------------------
// fmt.(*pp).fmtComplex
void __golang fmt__ptr_pp_fmtComplex(fmt_pp *p, complex128 v, __int32 size, int32 verb)
{
  int32 v4;             // eax
  fmt_pp *v5;           // ecx
  uint8 *array;         // ebx
  __int32 len;          // ebp
  __int32 cap;          // esi
  fmt_pp *v9;           // eax
  unsigned __int64 v10; // rcx
  unsigned __int32 v11; // edx
  uint8 *v12;           // ebp
  uint8 *v13;           // eax
  __int32 v14;          // ecx
  runtime_slice_0 v15;  // [esp+4h] [ebp-2Ch]
  runtime_slice_0 srca; // [esp+14h] [ebp-1Ch]
  runtime_slice_0 src;  // [esp+14h] [ebp-1Ch]
  bool oldPlus;         // [esp+23h] [ebp-Dh]
  __int32 v19;          // [esp+24h] [ebp-Ch]
  __int32 v20;          // [esp+28h] [ebp-8h]

  v4 = verb;
  if (verb > 98)
  {
    if ((unsigned int)(verb - 101) > 2 && verb != 118)
      goto LABEL_16;
  }
  else if ((unsigned int)(verb - 69) > 2 && verb != 98)
  {
  LABEL_16:
    fmt__ptr_pp_badVerb(p, verb);
    return;
  }
  v5 = p;
  oldPlus = p->fmt.fmtFlags.plus;
  array = p->buf.array;
  len = p->buf.len;
  cap = p->buf.cap;
  if (len + 1 > cap)
  {
    v15.array = p->buf.array;
    *(_QWORD *)&v15.len = __PAIR64__(cap, len);
    src = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, v15, len + 1);
    v13 = (uint8 *)src.array;
    v14 = src.len;
    p->buf.cap = src.cap;
    if (*(_DWORD *)&runtime_writeBarrier.enabled)
    {
      runtime_writebarrierptr((uintptr *)p, (uintptr)src.array);
      v13 = (uint8 *)src.array;
      v14 = src.len;
    }
    else
    {
      p->buf.array = (uint8 *)src.array;
    }
    len = v14;
    array = v13;
    v4 = verb;
    v5 = p;
  }
  v5->buf.len = len + 1;
  array[len] = 40;
  fmt__ptr_pp_fmtFloat(v5, v.real, size / 2, v4);
  p->fmt.fmtFlags.plus = 1;
  fmt__ptr_pp_fmtFloat(p, v.imag, size / 2, verb);
  v9 = p;
  v10 = *(_QWORD *)&p->buf.len;
  v11 = v10 + 2;
  v12 = p->buf.array;
  if ((unsigned int)(v10 + 2) > HIDWORD(v10))
  {
    v20 = v10 + 2;
    v19 = p->buf.len;
    srca = runtime_growslice((runtime__type_0 *)&RTYPE_uint8_0, (runtime_slice_0)p->buf, (int)v10 + 2);
    v12 = (uint8 *)srca.array;
    v9 = p;
    v10 = __PAIR64__(srca.cap, v19);
    v11 = v20;
  }
  if (v11 > HIDWORD(v10))
    runtime_panicslice();
  *(_WORD *)&v12[v10] = *(_WORD *)"i)";
  v9->buf.len = v11;
  v9->buf.cap = HIDWORD(v10);
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    runtime_writebarrierptr((uintptr *)v9, (uintptr)v12);
    v9 = p;
  }
  else
  {
    v9->buf.array = v12;
  }
  v9->fmt.fmtFlags.plus = oldPlus;
}

//----- (080C8F50) --------------------------------------------------------
// fmt.(*pp).printArg
// local variable allocation has failed, the output may be wrong!
void __golang fmt__ptr_pp_printArg(fmt_pp *p, interface_ arg, int32 verb)
{
  interface_ v3;           // rax
  fmt_pp *v4;              // ecx
  int32 v5;                // ebp
  unsigned int hash;       // esi
  char v7;                 // bl
  bool v8;                 // zf
  uint8 *v9;               // edi
  unsigned int v10;        // ebx
  unsigned int v11;        // ebp
  bool v12;                // zf
  unsigned int v13;        // ebx
  reflect_rtype *v14;      // ebp
  unsigned int v15;        // esi
  fmt_pp *v16;             // edx
  unsigned __int8 v17;     // bl
  bool v18;                // zf
  unsigned int v19;        // ebx
  unsigned int v20;        // edi
  unsigned int v21;        // ebx
  unsigned int v22;        // edi
  bool v23;                // zf
  bool v24;                // zf
  int v25;                 // ebx
  unsigned int v26;        // ebx
  char v27;                // bl
  bool v28;                // zf
  bool v29;                // zf
  unsigned int v30;        // ebx
  unsigned int v31;        // esi
  __int16 v32;             // bx
  unsigned __int16 v33;    // bx
  reflect_Value_1 v34;     // [esp+0h] [ebp-74h]
  string_0 v35;            // [esp+4h] [ebp-70h]
  reflect_Value_0 v36;     // [esp+4h] [ebp-70h]
  reflect_Value_0 v37;     // [esp+4h] [ebp-70h]
  _slice_uint8 v38;        // [esp+4h] [ebp-70h]
  complex128 v39;          // [esp+4h] [ebp-70h]
  complex128 v40;          // [esp+4h] [ebp-70h]
  reflect_Value_0 v41;     // [esp+4h] [ebp-70h]
  string_0 v42;            // [esp+4h] [ebp-70h]
  interface__1 size;       // [esp+Ch] [ebp-68h]
  string depth;            // [esp+14h] [ebp-60h]
  float f_real;            // [esp+20h] [ebp-54h]
  float f_imag;            // [esp+24h] [ebp-50h]
  float f_0;               // [esp+28h] [ebp-4Ch]
  double f_real_0;         // [esp+34h] [ebp-40h]
  double f_imag_0;         // [esp+3Ch] [ebp-38h]
  double f;                // [esp+44h] [ebp-30h]
  reflect_Value_1 v_2_typ; // [esp+5Ch] [ebp-18h]

  v3._type = arg._type;
  v4 = p;
  p->arg._type = arg._type;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, (uintptr)arg.data);
    v3 = arg;
    v4 = p;
  }
  else
  {
    v3.data = arg.data;
    p->arg.data = arg.data;
  }
  v4->value.flag = 0;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    v_2_typ.flag = (reflect_flag_0)&v4->value.ptr;
    runtime_writebarrierptr((uintptr *)&v4->value, 0);
    runtime_writebarrierptr((uintptr *)v_2_typ.flag, 0);
    v3 = arg;
    v4 = p;
  }
  else
  {
    v4->value.typ = 0;
    v4->value.ptr = 0;
  }
  if (!v3._type)
  {
    if (verb == 84 || verb == 118)
    {
      v42.ptr = "<nil>";
      v42.len = 5;
      fmt__ptr_fmt_padString((_ptr_fmt_fmt)&v4->fmt, v42);
    }
    else
    {
      fmt__ptr_pp_badVerb(v4, verb);
    }
    return;
  }
  v5 = verb;
  if (verb == 84)
  {
    v35.ptr = (char *)((int(__golang *)(runtime__type_0 *))go_itab__ptr_reflect_rtype_comma_reflect_Type[32])(v3._type);
    fmt__ptr_fmt_fmt_s((_ptr_fmt_fmt)&p->fmt, v35);
    return;
  }
  if (verb == 112)
  {
    v41 = reflect_ValueOf(v3);
    fmt__ptr_pp_fmtPointer(p, v41, 112);
    return;
  }
  hash = v3._type->hash;
  if (hash > 0xB0C23ED3)
  {
    if (hash <= 0xD04AE83D)
    {
      if (hash <= 0xBBAD4102)
      {
        if (hash == -1290120083)
        {
          if (&RTYPE_complex128_0 == (RTYPE *)v3._type)
          {
            f_real_0 = *(double *)v3.data;
            f_imag_0 = *((double *)v3.data + 1);
          }
          else
          {
            f_real_0 = 0.0;
            f_imag_0 = 0.0;
          }
          if (&RTYPE_complex128_0 == (RTYPE *)v3._type)
          {
            v40.real = f_real_0;
            v40.imag = f_imag_0;
            fmt__ptr_pp_fmtComplex(v4, v40, 128, verb);
            return;
          }
          v24 = 0;
        }
        else
        {
          v24 = hash == -1146273534;
        }
        if (!v24)
          goto LABEL_21;
        v25 = &RTYPE_int32_0 == (RTYPE *)v3._type ? *(_DWORD *)v3.data : 0;
        if (&RTYPE_int32_0 != (RTYPE *)v3._type)
          goto LABEL_21;
      LABEL_98:
        fmt__ptr_pp_fmtInteger(v4, v25, 1, verb);
        return;
      }
      if (hash != -1119168622 || (&RTYPE_uintptr_0 != (RTYPE *)v3._type ? (v26 = 0) : (v26 = *(_DWORD *)v3.data),
                                  &RTYPE_uintptr_0 != (RTYPE *)v3._type))
      {
        if (hash == -871972825)
        {
          if (&RTYPE_int8_0 == (RTYPE *)v3._type)
            v27 = *(_BYTE *)v3.data;
          else
            v27 = 0;
          if (&RTYPE_int8_0 == (RTYPE *)v3._type)
          {
            fmt__ptr_pp_fmtInteger(v4, v27, 1, verb);
            return;
          }
          v28 = 0;
        }
        else
        {
          v28 = hash == -800397251;
        }
        if (!v28)
          goto LABEL_21;
        v26 = &RTYPE_uint32_0 == v3._type ? *(_DWORD *)v3.data : 0;
        if (&RTYPE_uint32_0 != v3._type)
          goto LABEL_21;
      }
    LABEL_116:
      fmt__ptr_pp_fmtInteger(v4, v26, 0, verb);
      return;
    }
    if (hash > 0xE0FF5CB4)
    {
      if (hash == -321552178)
      {
        v32 = &RTYPE_int16_0 == (RTYPE *)v3._type ? *(_WORD *)v3.data : 0;
        if (&RTYPE_int16_0 == (RTYPE *)v3._type)
        {
          fmt__ptr_pp_fmtInteger(v4, v32, 1, verb);
          return;
        }
      }
      if (hash == -269349216)
      {
        v33 = &RTYPE_uint16_0 == (RTYPE *)v3._type ? *(_WORD *)v3.data : 0;
        if (&RTYPE_uint16_0 == (RTYPE *)v3._type)
        {
          fmt__ptr_pp_fmtInteger(v4, v33, 0, verb);
          return;
        }
      }
      if (hash != -145526278)
        goto LABEL_21;
      v25 = &RTYPE_int == v3._type ? *(_DWORD *)v3.data : 0;
      if (&RTYPE_int != v3._type)
        goto LABEL_21;
      goto LABEL_98;
    }
    if (hash == -709331182)
    {
      if (&RTYPE_uint_0 == (RTYPE *)v3._type)
        v26 = *(_DWORD *)v3.data;
      else
        v26 = 0;
      if (&RTYPE_uint_0 == (RTYPE *)v3._type)
        goto LABEL_116;
      v29 = 0;
    }
    else
    {
      v29 = hash == -520135500;
    }
    if (v29)
    {
      if (&RTYPE_string_0 == (const interface_ *)v3._type)
      {
        v30 = *((_DWORD *)v3.data + 1);
        v31 = *(_DWORD *)v3.data;
      }
      else
      {
        v31 = 0;
        v30 = 0;
      }
      if (&RTYPE_string_0 == (const interface_ *)v3._type)
      {
        fmt__ptr_pp_fmtString(v4, (string)__PAIR64__(v30, v31), verb);
        return;
      }
    }
    goto LABEL_21;
  }
  if (hash > 0x500C1ABC)
  {
    if (hash > 0x7925028C)
    {
      if (hash == -2043572946)
      {
        if (&RTYPE_uint64_0 == (RTYPE *)v3._type)
        {
          v19 = *((_DWORD *)v3.data + 1);
          v20 = *(_DWORD *)v3.data;
        }
        else
        {
          v19 = 0;
          v20 = 0;
        }
        if (&RTYPE_uint64_0 == (RTYPE *)v3._type)
        {
          fmt__ptr_pp_fmtInteger(v4, __PAIR64__(v19, v20), 0, verb);
          return;
        }
      }
      if (hash == -1774216193)
      {
        if (&RTYPE_int64_0 == (RTYPE *)v3._type)
        {
          v21 = *(_DWORD *)v3.data;
          v22 = *((_DWORD *)v3.data + 1);
        }
        else
        {
          v21 = 0;
          v22 = 0;
        }
        if (&RTYPE_int64_0 == (RTYPE *)v3._type)
        {
          fmt__ptr_pp_fmtInteger(v4, __PAIR64__(v22, v21), 1, verb);
          return;
        }
        v23 = 0;
      }
      else
      {
        v23 = hash == -1329447213;
      }
      if (v23)
      {
        f_0 = &RTYPE_float32_0 == (RTYPE *)v3._type ? *(float *)v3.data : 0.0;
        if (&RTYPE_float32_0 == (RTYPE *)v3._type)
        {
          fmt__ptr_pp_fmtFloat(v4, f_0, 32, verb);
          return;
        }
      }
    }
    else
    {
      if (hash == 1715356255)
      {
        if (&RTYPE_uint8_0 == v3._type)
          v17 = *(_BYTE *)v3.data;
        else
          v17 = 0;
        if (&RTYPE_uint8_0 == v3._type)
        {
          fmt__ptr_pp_fmtInteger(v4, v17, 0, verb);
          return;
        }
        v18 = 0;
      }
      else
      {
        v18 = hash == 2032468620;
      }
      if (v18)
      {
        if (&RTYPE_complex64_0 == (RTYPE *)v3._type)
        {
          f_real = *(float *)v3.data;
          f_imag = *((float *)v3.data + 1);
        }
        else
        {
          f_real = 0.0;
          f_imag = 0.0;
        }
        if (&RTYPE_complex64_0 == (RTYPE *)v3._type)
        {
          v39.real = f_real;
          v39.imag = f_imag;
          fmt__ptr_pp_fmtComplex(v4, v39, 64, verb);
          return;
        }
      }
    }
    goto LABEL_21;
  }
  if (hash <= 0x2EA27FFB)
  {
    if (hash == 335480517)
    {
      if (&RTYPE_bool == (RTYPE *)v3._type)
        v7 = *(_BYTE *)v3.data;
      else
        v7 = 0;
      if (&RTYPE_bool == (RTYPE *)v3._type)
      {
        fmt__ptr_pp_fmtBool(v4, v7, verb);
        return;
      }
      v8 = 0;
    }
    else
    {
      v8 = hash == 782401531;
    }
    if (v8)
    {
      f = &RTYPE_float64_0 == (RTYPE *)v3._type ? *(double *)v3.data : 0.0;
      if (&RTYPE_float64_0 == (RTYPE *)v3._type)
      {
        fmt__ptr_pp_fmtFloat(v4, f, 64, verb);
        return;
      }
    }
    goto LABEL_21;
  }
  if (hash == 942571231)
  {
    if (&RTYPE__slice_uint8_0 == v3._type)
    {
      v9 = *(uint8 **)v3.data;
      v10 = *((_DWORD *)v3.data + 2);
      v11 = *((_DWORD *)v3.data + 1);
    }
    else
    {
      v10 = 0;
      v11 = 0;
      v9 = 0;
    }
    if (&RTYPE__slice_uint8_0 == v3._type)
    {
      v38.array = v9;
      *(_QWORD *)&v38.len = __PAIR64__(v10, v11);
      depth.str = (uint8 *)"[]byte";
      depth.len = 6;
      fmt__ptr_pp_fmtBytes(v4, v38, verb, depth);
      return;
    }
    v12 = 0;
  }
  else
  {
    v12 = hash == 1342970556;
  }
  if (!v12 || (&RTYPE_reflect_Value_1 != v3._type
                   ? (v15 = 0, v13 = 0, v14 = 0)
                   : (reflect_rtype *)(v13 = *((_DWORD *)v3.data + 1),
                                       v14 = *(reflect_rtype **)v3.data,
                                       v15 = *((_DWORD *)v3.data + 2)),
               &RTYPE_reflect_Value_1 != v3._type))
  {
    v5 = verb;
  LABEL_21:
    if (!fmt__ptr_pp_handleMethods((_ptr_fmt_pp)v4, v5))
    {
      v36 = reflect_ValueOf(arg);
      fmt__ptr_pp_printValue(p, v36, verb, 0);
    }
    return;
  }
  if (!v15)
  {
  LABEL_38:
    v37.typ = v14;
    *(_QWORD *)&v37.ptr = __PAIR64__(v15, v13);
    fmt__ptr_pp_printValue(v4, v37, verb, 0);
    return;
  }
  *(_QWORD *)&v_2_typ.typ = __PAIR64__(v13, (unsigned int)v14);
  v34.typ = (_ptr_reflect_rtype)v14;
  *(_QWORD *)&v34.ptr = __PAIR64__(v15, v13);
  if (!reflect_Value_CanInterface(v34))
  {
    v4 = p;
    goto LABEL_38;
  }
  size = reflect_Value_Interface(v_2_typ);
  v16 = p;
  p->arg._type = (runtime__type_0 *)size.tab;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    runtime_writebarrierptr((uintptr *)&p->arg.data, (uintptr)size.data);
    v16 = p;
  }
  else
  {
    p->arg.data = size.data;
  }
  if (!fmt__ptr_pp_handleMethods((_ptr_fmt_pp)v16, verb))
  {
    v4 = p;
    goto LABEL_38;
  }
}
// 80C8FDE: conditional instruction was optimized away because eax.4!=0
// 80C9015: conditional instruction was optimized away because eax.4!=0
// 80C90BB: failed to expand linear variable ^8.12
// 80C987B: failed to expand linear variable ^8.12
// 80E7C40: using guessed type RTYPE RTYPE_bool;
// 80E7CC0: using guessed type RTYPE RTYPE_complex128_0;
// 80E7D00: using guessed type RTYPE RTYPE_complex64_0;
// 80E7D40: using guessed type RTYPE RTYPE_float32_0;
// 80E7D80: using guessed type RTYPE RTYPE_float64_0;
// 80E8140: using guessed type RTYPE RTYPE_int16_0;
// 80E8180: using guessed type RTYPE RTYPE_int32_0;
// 80E81C0: using guessed type RTYPE RTYPE_int64_0;
// 80E8200: using guessed type RTYPE RTYPE_int8_0;
// 80E8840: using guessed type RTYPE RTYPE_uint_0;
// 80E8880: using guessed type RTYPE RTYPE_uint16_0;
// 80E8900: using guessed type RTYPE RTYPE_uint64_0;
// 80E8980: using guessed type RTYPE RTYPE_uintptr_0;
// 810FF80: using guessed type runtime__type_0 *go_itab__ptr_reflect_rtype_comma_reflect_Type[2];

//----- (080CDAF0) --------------------------------------------------------
// fmt.(*ss).error
void __golang __noreturn fmt__ptr_ss_error(fmt_ss *s, error_0 err)
{
  runtime_eface_0 e; // [esp+8h] [ebp-10h]
  error_0 elem;      // [esp+10h] [ebp-8h] BYREF

  elem = err;
  e = runtime_convT2E((runtime__type_0 *)&RTYPE_fmt_scanError_1, &elem);
  runtime_gopanic(e);
  BUG();
}

//----- (080CFB90) --------------------------------------------------------
// fmt.(*ss).convertFloat
float64 __golang fmt__ptr_ss_convertFloat(fmt_ss *s, string str, __int32 n)
{
  error_0 v3;          // rcx
  __int32 v4;          // eax
  runtime_itab_0 *tab; // edx
  string v6;           // [esp+0h] [ebp-3Ch]
  retval_8097DF0 r;    // [esp+8h] [ebp-34h]
  __int32 v8;          // [esp+Ch] [ebp-30h]
  retval_8096AC0 v9;   // [esp+Ch] [ebp-30h]
  retval_8096AC0 v10;  // [esp+Ch] [ebp-30h]
  __int32 p;           // [esp+1Ch] [ebp-20h]

  v8 = fmt_indexRune(str, 112);
  if (v8 < 0)
  {
    v10 = strconv_ParseFloat(str, n);
    if (v10._r3.tab)
      fmt__ptr_ss_error(s, v10._r3);
    return v10._r2;
  }
  else
  {
    if ((unsigned int)v8 > str.len)
      runtime_panicslice();
    p = v8;
    v9 = strconv_ParseFloat((string)__PAIR64__(v8, (unsigned int)str.str), n);
    v3.tab = v9._r3.tab;
    if (v9._r3.tab)
    {
      v3.data = v9._r3.data;
      if (go_itab__ptr_strconv_NumError_comma_error == (runtime__type_0 **)v9._r3.tab)
      {
        *((_DWORD *)v9._r3.data + 3) = str.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)v9._r3.data + 2, (uintptr)str.str);
          v3.tab = v9._r3.tab;
        }
        else
        {
          *((_DWORD *)v9._r3.data + 2) = str.str;
        }
      }
      fmt__ptr_ss_error(s, v3);
    }
    v4 = p + 1;
    if ((unsigned int)(p + 1) > str.len)
      runtime_panicslice();
    v6.str = &str.str[((v4 - str.len) >> 31) & v4];
    v6.len = str.len - v4;
    r = strconv_Atoi(v6);
    tab = r._r2.tab;
    if (r._r2.tab)
    {
      if (go_itab__ptr_strconv_NumError_comma_error == (runtime__type_0 **)r._r2.tab)
      {
        *((_DWORD *)r._r2.data + 3) = str.len;
        if (*(_DWORD *)&runtime_writeBarrier.enabled)
        {
          runtime_writebarrierptr((uintptr *)r._r2.data + 2, (uintptr)str.str);
          tab = r._r2.tab;
        }
        else
        {
          *((_DWORD *)r._r2.data + 2) = str.str;
        }
      }
      fmt__ptr_ss_error(s, (error_0)__PAIR64__((unsigned int)r._r2.data, (unsigned int)tab));
    }
    math_Ldexp();
    return *(double *)&r._r2;
  }
}
// 810FB30: using guessed type runtime__type_0 *go_itab__ptr_strconv_NumError_comma_error[2];

//----- (080CFDF0) --------------------------------------------------------
// fmt.(*ss).scanComplex
complex128 __golang fmt__ptr_ss_scanComplex(fmt_ss *s, int32 verb, __int32 n)
{
  retval_80CF980 v3; // [esp+4h] [ebp-2Ch]
  string okVerbs;    // [esp+8h] [ebp-28h]
  string typ;        // [esp+10h] [ebp-20h]
  uint8 *simag_ptr;  // [esp+2Ch] [ebp-4h]
  complex128 _r2;    // [esp+40h] [ebp+10h]

  okVerbs.str = (uint8 *)"beEfFgGv";
  okVerbs.len = 8;
  typ.str = (uint8 *)"complex";
  typ.len = 7;
  if (fmt__ptr_ss_okVerb(s, verb, okVerbs, typ))
  {
    fmt__ptr_ss_SkipSpace((_ptr_fmt_ss)s);
    fmt__ptr_ss_notEOF((_ptr_fmt_ss)s);
    v3 = fmt__ptr_ss_complexTokens(s);
    simag_ptr = v3.imag.str;
    _r2.real = fmt__ptr_ss_convertFloat(s, v3.real, n / 2);
    _r2.imag = fmt__ptr_ss_convertFloat(s, (string)__PAIR64__(v3.imag.len, (unsigned int)simag_ptr), n / 2);
  }
  else
  {
    _r2.real = 0.0;
    _r2.imag = 0.0;
  }
  return _r2;
}

/*
160999960
175999960
4294967296
*/

//----- (080D0570) --------------------------------------------------------
// fmt.(*ss).scanOne
// local variable allocation has failed, the output may be wrong!
// positive sp value has been detected, the output may be wrong!
void __golang fmt__ptr_ss_scanOne(fmt_ss *s, int32 verb, interface_ arg)
{
  unsigned int hash;     // ecx
  _DWORD *v4;            // edx
  bool v5;               // zf
  _DWORD *v6;            // ecx
  unsigned int v7;       // eax
  string v8;             // kr00_8
  __int32 i;             // eax
  unsigned int v10;      // eax
  int v11;               // ecx
  int v12;               // eax
  unsigned int v13;      // ecx
  unsigned int v14;      // eax
  int v15;               // ecx
  _QWORD *v16;           // edx
  bool v17;              // zf
  float *v18;            // ecx
  complex128 *v19;       // edx
  bool v20;              // zf
  _DWORD *v21;           // ecx
  int64 *v22;            // edx
  uintptr *v23;          // edx
  bool v24;              // zf
  _BYTE *v25;            // ecx
  uintptr *v26;          // edx
  bool v27;              // zf
  _BYTE *v28;            // edx
  bool v29;              // zf
  float *v30;            // ecx
  bool v31;              // zf
  _BYTE *v32;            // ecx
  _WORD *v33;            // edx
  float64 *v34;          // edx
  _WORD *v35;            // ecx
  void *v36;             // eax
  void *data;            // ecx
  int v38;               // [esp-A4h] [ebp-14Ch]
  int v39;               // [esp-A4h] [ebp-14Ch]
  string v40[2];         // [esp-A4h] [ebp-14Ch]
  string v41[2];         // [esp-A4h] [ebp-14Ch]
  __int32 v42;           // [esp-A4h] [ebp-14Ch]
  string_0 v43;          // [esp-A4h] [ebp-14Ch]
  __int32 v44;           // [esp-A4h] [ebp-14Ch]
  __int32 v45;           // [esp-A4h] [ebp-14Ch]
  __int32 v46;           // [esp-A4h] [ebp-14Ch]
  int v47;               // [esp-A4h] [ebp-14Ch]
  string v48[2];         // [esp-A4h] [ebp-14Ch]
  string_0 v49;          // [esp-A4h] [ebp-14Ch]
  string_0 v50;          // [esp-A4h] [ebp-14Ch]
  reflect_Value_1 v51;   // [esp-A0h] [ebp-148h]
  int v52;               // [esp-A0h] [ebp-148h]
  unsigned int v53;      // [esp-A0h] [ebp-148h]
  unsigned int v54;      // [esp-A0h] [ebp-148h]
  string v55;            // [esp-A0h] [ebp-148h]
  bool v56;              // [esp-A0h] [ebp-148h]
  unsigned int v57;      // [esp-A0h] [ebp-148h]
  string v58;            // [esp-A0h] [ebp-148h]
  string v59;            // [esp-A0h] [ebp-148h]
  string v60;            // [esp-A0h] [ebp-148h]
  string v61;            // [esp-A0h] [ebp-148h]
  retval_8052920 v62;    // [esp-9Ch] [ebp-144h]
  reflect_Value_0 v63;   // [esp-9Ch] [ebp-144h]
  reflect_Value_0 Slice; // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v65;    // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v66;    // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v67;    // [esp-9Ch] [ebp-144h]
  complex128 v68;        // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v69;    // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v70;    // [esp-9Ch] [ebp-144h]
  uint64 v71;            // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v72;    // [esp-9Ch] [ebp-144h]
  int64 v73;             // [esp-9Ch] [ebp-144h]
  reflect_Type_1 v74;    // [esp-9Ch] [ebp-144h]
  _slice_uint8 v75;      // [esp-9Ch] [ebp-144h]
  complex128 v76;        // [esp-9Ch] [ebp-144h]
  reflect_Value_0 v77;   // [esp-98h] [ebp-140h]
  float64 v78;           // [esp-98h] [ebp-140h]
  string v79;            // [esp-98h] [ebp-140h]
  string v80;            // [esp-98h] [ebp-140h]
  string v81;            // [esp-94h] [ebp-13Ch]
  string v82;            // [esp-94h] [ebp-13Ch]
  string v83;            // [esp-94h] [ebp-13Ch]
  unsigned __int32 v84;  // [esp-88h] [ebp-130h]
  size_t len;            // [esp-84h] [ebp-12Ch]
  float v86;             // [esp-78h] [ebp-120h]
  float real;            // [esp-78h] [ebp-120h]
  float imag;            // [esp-78h] [ebp-120h]
  float *v89;            // [esp-68h] [ebp-110h]
  uintptr *v90;          // [esp-54h] [ebp-FCh]
  uintptr *v91;          // [esp-50h] [ebp-F8h]
  float64 *v92;          // [esp-4Ch] [ebp-F4h]
  float *v93;            // [esp-48h] [ebp-F0h]
  reflect_Type_1 v94;    // [esp-28h] [ebp-D0h]
  char *ptr;             // [esp-14h] [ebp-BCh]
  _BYTE v96[20];         // [esp-10h] [ebp-B8h] OVERLAPPED
  fmt_ss *e;             // [esp+4h] [ebp-A4h]
  int32 e_4;             // [esp+8h] [ebp-A0h]
  interface_ v99;        // [esp+Ch] [ebp-9Ch]

  e->buf.len = 0;
  v62 = runtime_assertE2I2((runtime_interfacetype_0 *)&RTYPE_fmt_Scanner, v99);
  if (v62.b)
  {
    v62.r.data = (void *)((int(__golang *)(void *, RTYPE **))v62.r.tab->fun[0])(
        v62.r.data,
        &go_itab__ptr_fmt_ss_comma_fmt_ScanState);
    v36 = *(void **)&v62.b;
    data = v62.r.data;
    if (v62.r.data)
    {
      if (v62.r.data == io_EOF.tab)
      {
        if (runtime_ifaceeq((runtime_itab_0 *)v62.r.data, *(void **)&v62.b, io_EOF.data))
        {
          data = io_ErrUnexpectedEOF.tab;
          v36 = io_ErrUnexpectedEOF.data;
        }
        else
        {
          v36 = *(void **)&v62.b;
          data = v62.r.data;
        }
      }
      fmt__ptr_ss_error(e, (error_0)__PAIR64__((unsigned int)v36, (unsigned int)data));
    }
  }
  else
  {
    if (!v99._type)
      goto LABEL_15;
    hash = v99._type->hash;
    if (hash <= 0x5FCADFEF)
    {
      if (hash <= 0x1FFEE651)
      {
        if (hash <= 0x10DBF978)
        {
          if (hash != 13003987)
          {
            v5 = hash == 282851704;
            goto LABEL_11;
          }
          if (&RTYPE__ptr_uint32 == (RTYPE *)v99._type)
            v4 = v99.data;
          else
            v4 = 0;
          if (&RTYPE__ptr_uint32 != (RTYPE *)v99._type)
          {
            v5 = 0;
          LABEL_11:
            if (v5)
            {
              v6 = &RTYPE__ptr_uint == (RTYPE *)v99._type ? v99.data : 0;
              if (&RTYPE__ptr_uint == (RTYPE *)v99._type)
              {
                *v6 = fmt__ptr_ss_scanUint(e, e_4, 32);
                return;
              }
            }
            goto LABEL_15;
          }
        LABEL_43:
          *v4 = fmt__ptr_ss_scanUint(e, e_4, 32);
          return;
        }
        if (hash == 506426616)
        {
          if (&RTYPE__ptr_uint64 == (RTYPE *)v99._type)
            v16 = v99.data;
          else
            v16 = 0;
          if (&RTYPE__ptr_uint64 == (RTYPE *)v99._type)
          {
            *v16 = fmt__ptr_ss_scanUint(e, e_4, 64);
            return;
          }
          v17 = 0;
        }
        else
        {
          v17 = hash == 536798801;
        }
        if (v17)
        {
          v18 = &RTYPE__ptr_float32 == (RTYPE *)v99._type ? (float *)v99.data : 0;
          if (&RTYPE__ptr_float32 == (RTYPE *)v99._type)
          {
            v93 = v18;
            v58.str = (uint8 *)"beEfFgGv";
            v58.len = 8;
            v79.str = (uint8 *)"float32";
            v79.len = 7;
            if (fmt__ptr_ss_okVerb(e, e_4, v58, v79))
            {
              fmt__ptr_ss_SkipSpace((_ptr_fmt_ss)e);
              fmt__ptr_ss_notEOF((_ptr_fmt_ss)e);
              v49 = fmt__ptr_ss_floatToken((_ptr_fmt_ss)e);
              v86 = fmt__ptr_ss_convertFloat(e, (string)v49, 32);
              *v93 = v86;
            }
            return;
          }
        }
        goto LABEL_15;
      }
      if (hash > 0x2522EBE7)
      {
        if (hash == 649594647)
        {
          v22 = &RTYPE__ptr_int64 == (RTYPE *)v99._type ? (int64 *)v99.data : 0;
          if (&RTYPE__ptr_int64 == (RTYPE *)v99._type)
          {
            *v22 = fmt__ptr_ss_scanInt(e, e_4, 64);
            return;
          }
        }
        if (hash == 1511480045)
        {
          if (&RTYPE__ptr_string == (RTYPE *)v99._type)
            v23 = (uintptr *)v99.data;
          else
            v23 = 0;
          if (&RTYPE__ptr_string == (RTYPE *)v99._type)
          {
            v91 = v23;
            v59 = fmt__ptr_ss_convertString(e, e_4);
            v91[1] = v59.len;
            if (*(_DWORD *)&runtime_writeBarrier.enabled)
              runtime_writebarrierptr(v91, (uintptr)v59.str);
            else
              *v91 = (uintptr)v59.str;
            return;
          }
          v24 = 0;
        }
        else
        {
          v24 = hash == 1607131119;
        }
        if (v24)
        {
          v25 = &RTYPE__ptr_int8 == (RTYPE *)v99._type ? v99.data : 0;
          if (&RTYPE__ptr_int8 == (RTYPE *)v99._type)
          {
            *v25 = fmt__ptr_ss_scanInt(e, e_4, 8);
            return;
          }
        }
        goto LABEL_15;
      }
      if (hash == 597961687)
      {
        if (&RTYPE__ptr_complex128 == (RTYPE *)v99._type)
          v19 = (complex128 *)v99.data;
        else
          v19 = 0;
        if (&RTYPE__ptr_complex128 == (RTYPE *)v99._type)
        {
          *v19 = fmt__ptr_ss_scanComplex(e, e_4, 128);
          return;
        }
        v20 = 0;
      }
      else
      {
        v20 = hash == 623045607;
      }
      if (!v20)
        goto LABEL_15;
      v21 = &RTYPE__ptr_int == (RTYPE *)v99._type ? v99.data : 0;
      if (&RTYPE__ptr_int != (RTYPE *)v99._type)
        goto LABEL_15;
      goto LABEL_71;
    }
    if (hash <= 0x7AC16A11)
    {
      if (hash > 0x6B581726)
      {
        if (hash == 1846407377)
        {
          if (&RTYPE__ptr_bool == (RTYPE *)v99._type)
            v28 = v99.data;
          else
            v28 = 0;
          if (&RTYPE__ptr_bool == (RTYPE *)v99._type)
          {
            *v28 = fmt__ptr_ss_scanBool((_ptr_fmt_ss)e, e_4);
            return;
          }
          v29 = 0;
        }
        else
        {
          v29 = hash == 2059495953;
        }
        if (v29)
        {
          v30 = &RTYPE__ptr_complex64 == (RTYPE *)v99._type ? (float *)v99.data : 0;
          if (&RTYPE__ptr_complex64 == (RTYPE *)v99._type)
          {
            v89 = v30;
            v76 = fmt__ptr_ss_scanComplex(e, e_4, 64);
            real = v76.real;
            *v89 = real;
            imag = v76.imag;
            v89[1] = imag;
            return;
          }
        }
        goto LABEL_15;
      }
      if (hash == 1775275685)
      {
        if (&RTYPE__ptr__slice_uint8 == (RTYPE *)v99._type)
          v26 = (uintptr *)v99.data;
        else
          v26 = 0;
        if (&RTYPE__ptr__slice_uint8 == (RTYPE *)v99._type)
        {
          v90 = v26;
          v60 = fmt__ptr_ss_convertString(e, e_4);
          v75 = runtime_stringtoslicebyte(0, v60);
          v90[1] = v75.len;
          v90[2] = v75.cap;
          if (*(_DWORD *)&runtime_writeBarrier.enabled)
            runtime_writebarrierptr(v90, (uintptr)v75.array);
          else
            *v90 = (uintptr)v75.array;
          return;
        }
        v27 = 0;
      }
      else
      {
        v27 = hash == 1800935206;
      }
      if (!v27 || (&RTYPE__ptr_int32 != (RTYPE *)v99._type ? (v21 = 0) : (v21 = v99.data),
                   &RTYPE__ptr_int32 != (RTYPE *)v99._type))
      {
      LABEL_15:
        v51 = (reflect_Value_1)reflect_ValueOf(v99);
        if ((v51.flag & 0x1F) != 22)
        {
          v74 = reflect_Value_Type(v51);
          v47 = (*((int(__golang **)(void *))v74.tab + 32))(v74.data);
          v14 = v57;
          v15 = v47;
          v48[0].str = (uint8 *)"type not a pointer: ";
          v48[0].len = 20;
          v48[1] = (string)__PAIR64__(v14, v15);
          v83 = runtime_concatstring2(0, *(string(*)[2]) & v48[0].str);
          fmt__ptr_ss_errorString((_ptr_fmt_ss)e, (string_0)v83);
        }
        *(_DWORD *)&v96[12] = v51.ptr;
        *(_DWORD *)&v96[8] = v51.typ;
        v63 = reflect_Value_Elem((reflect_Value_0)v51);
        *(_QWORD *)v96 = *(_QWORD *)&v63.typ;
        v7 = v63.flag & 0x1F;
        if (v7 <= 0xC)
        {
          if (v7 == 1)
          {
            v56 = fmt__ptr_ss_scanBool((_ptr_fmt_ss)e, e_4);
            reflect_Value_SetBool(*(reflect_Value_0 *)v96, v56);
            return;
          }
          if (v7 - 2 <= 4)
          {
            v72 = reflect_Value_Type((reflect_Value_1)v63);
            v46 = (*((int(__golang **)(void *))v72.tab + 6))(v72.data);
            v73 = fmt__ptr_ss_scanInt(e, e_4, v46);
            reflect_Value_SetInt(*(reflect_Value_0 *)v96, v73);
            return;
          }
          if (v7 - 7 <= 5)
          {
            v70 = reflect_Value_Type((reflect_Value_1)v63);
            v45 = (*((int(__golang **)(void *))v70.tab + 6))(v70.data);
            v71 = fmt__ptr_ss_scanUint(e, e_4, v45);
            reflect_Value_SetUint(*(reflect_Value_0 *)v96, v71);
            return;
          }
        }
        else if (v7 <= 0x10)
        {
          if (v7 - 13 <= 1)
          {
            fmt__ptr_ss_SkipSpace((_ptr_fmt_ss)e);
            fmt__ptr_ss_notEOF((_ptr_fmt_ss)e);
            v43 = fmt__ptr_ss_floatToken((_ptr_fmt_ss)e);
            len = v43.len;
            ptr = v43.ptr;
            v69 = reflect_Value_Type(*(reflect_Value_1 *)v96);
            v44 = (*((int(__golang **)(void *))v69.tab + 6))(v69.data);
            v78 = fmt__ptr_ss_convertFloat(e, (string)__PAIR64__(len, (unsigned int)ptr), v44);
            reflect_Value_SetFloat(*(reflect_Value_0 *)v96, v78);
            return;
          }
          if (v7 - 15 <= 1)
          {
            v67 = reflect_Value_Type((reflect_Value_1)v63);
            v42 = (*((int(__golang **)(void *))v67.tab + 6))(v67.data);
            v68 = fmt__ptr_ss_scanComplex(e, e_4, v42);
            reflect_Value_SetComplex(*(reflect_Value_0 *)v96, v68);
            return;
          }
        }
        else
        {
          if (v7 == 23)
          {
            v94 = reflect_Value_Type((reflect_Value_1)v63);
            v38 = (*((int(__golang **)(void *))v94.tab + 10))(v94.data);
            if ((*(int(__golang **)(int))(v38 + 80))(v52) != 8)
            {
              v65 = reflect_Value_Type(*(reflect_Value_1 *)&v96[8]);
              v39 = (*((int(__golang **)(void *))v65.tab + 32))(v65.data);
              v10 = v53;
              v11 = v39;
              v40[0].str = (uint8 *)"can't scan type: ";
              v40[0].len = 17;
              v40[1] = (string)__PAIR64__(v10, v11);
              v81 = runtime_concatstring2(0, *(string(*)[2]) & v40[0].str);
              fmt__ptr_ss_errorString((_ptr_fmt_ss)e, (string_0)v81);
            }
            v8 = fmt__ptr_ss_convertString(e, e_4);
            Slice = reflect_MakeSlice((reflect_Type_0)v94, v8.len, v8.len);
            reflect_Value_Set(*(reflect_Value_0 *)v96, Slice);
            for (i = 0; i < v8.len; i = v84 + 1)
            {
              v84 = i;
              v77 = reflect_Value_Index(*(reflect_Value_0 *)v96, i);
              if (v84 >= v8.len)
                runtime_panicindex();
              reflect_Value_SetUint(v77, v8.str[v84]);
            }
            return;
          }
          if (v7 == 24)
          {
            v55 = fmt__ptr_ss_convertString(e, e_4);
            reflect_Value_SetString(*(reflect_Value_1 *)v96, (string_0)v55);
            return;
          }
        }
        v66 = reflect_Value_Type(*(reflect_Value_1 *)&v96[8]);
        v12 = (*((int(__golang **)(void *))v66.tab + 32))(v66.data);
        v13 = v54;
        v41[0].str = (uint8 *)"can't scan type: ";
        v41[0].len = 17;
        v41[1] = (string)__PAIR64__(v13, v12);
        v82 = runtime_concatstring2(0, *(string(*)[2]) & v41[0].str);
        fmt__ptr_ss_errorString((_ptr_fmt_ss)e, (string_0)v82);
      }
    LABEL_71:
      *v21 = fmt__ptr_ss_scanInt(e, e_4, 32);
      return;
    }
    if (hash <= 0x9AD926A8)
    {
      if (hash == -1769224866)
      {
        if (&RTYPE__ptr_uintptr == (RTYPE *)v99._type)
          v4 = v99.data;
        else
          v4 = 0;
        if (&RTYPE__ptr_uintptr == (RTYPE *)v99._type)
          goto LABEL_43;
        v31 = 0;
      }
      else
      {
        v31 = hash == -1697044824;
      }
      if (v31)
      {
        v32 = &RTYPE__ptr_uint8 == (RTYPE *)v99._type ? v99.data : 0;
        if (&RTYPE__ptr_uint8 == (RTYPE *)v99._type)
        {
          *v32 = fmt__ptr_ss_scanUint(e, e_4, 8);
          return;
        }
      }
      goto LABEL_15;
    }
    if (hash == -1603877355)
    {
      v33 = &RTYPE__ptr_int16 == (RTYPE *)v99._type ? v99.data : 0;
      if (&RTYPE__ptr_int16 == (RTYPE *)v99._type)
      {
        *v33 = fmt__ptr_ss_scanInt(e, e_4, 16);
        return;
      }
    }
    if (hash != -1168724717 || (&RTYPE__ptr_float64 != (RTYPE *)v99._type ? (v34 = 0) : (v34 = (float64 *)v99.data),
                                &RTYPE__ptr_float64 != (RTYPE *)v99._type))
    {
      if (hash == -292359122)
      {
        v35 = &RTYPE__ptr_uint16 == (RTYPE *)v99._type ? v99.data : 0;
        if (&RTYPE__ptr_uint16 == (RTYPE *)v99._type)
        {
          *v35 = fmt__ptr_ss_scanUint(e, e_4, 16);
          return;
        }
      }
      goto LABEL_15;
    }
    v92 = v34;
    v61.str = (uint8 *)"beEfFgGv";
    v61.len = 8;
    v80.str = (uint8 *)"float64";
    v80.len = 7;
    if (fmt__ptr_ss_okVerb(e, e_4, v61, v80))
    {
      fmt__ptr_ss_SkipSpace((_ptr_fmt_ss)e);
      fmt__ptr_ss_notEOF((_ptr_fmt_ss)e);
      v50 = fmt__ptr_ss_floatToken((_ptr_fmt_ss)e);
      *v92 = fmt__ptr_ss_convertFloat(e, (string)v50, 64);
    }
  }
}
// 80D0C9A: positive sp value A8 has been found
// 80D0570: could not find valid save-restore pair for ebx
// 80D0772: failed to expand linear variable ^10.12
// 80DE860: using guessed type RTYPE RTYPE__ptr__slice_uint8;
// 80DE8E0: using guessed type RTYPE RTYPE__ptr_bool;
// 80DE960: using guessed type RTYPE RTYPE__ptr_complex128;
// 80DE9A0: using guessed type RTYPE RTYPE__ptr_complex64;
// 80DEA20: using guessed type RTYPE RTYPE__ptr_float32;
// 80DEA60: using guessed type RTYPE RTYPE__ptr_float64;
// 80DED60: using guessed type RTYPE RTYPE__ptr_int;
// 80DEDA0: using guessed type RTYPE RTYPE__ptr_int16;
// 80DEDE0: using guessed type RTYPE RTYPE__ptr_int32;
// 80DEE20: using guessed type RTYPE RTYPE__ptr_int64;
// 80DEE60: using guessed type RTYPE RTYPE__ptr_int8;
// 80E12A0: using guessed type RTYPE RTYPE__ptr_string;
// 80E16A0: using guessed type RTYPE RTYPE__ptr_uint;
// 80E16E0: using guessed type RTYPE RTYPE__ptr_uint16;
// 80E1720: using guessed type RTYPE RTYPE__ptr_uint32;
// 80E1760: using guessed type RTYPE RTYPE__ptr_uint64;
// 80E17A0: using guessed type RTYPE RTYPE__ptr_uint8;
// 80E17E0: using guessed type RTYPE RTYPE__ptr_uintptr;
// 80EAA40: using guessed type RTYPE RTYPE_fmt_Scanner;
// 810FCE0: using guessed type RTYPE *go_itab__ptr_fmt_ss_comma_fmt_ScanState;

//----- (080D1DD0) --------------------------------------------------------
// fmt.glob..func1
interface_ __golang fmt_glob__func1()
{
  interface_ _r0; // [esp+Ch] [ebp+4h]

  _r0._type = (runtime__type_0 *)&RTYPE__ptr_fmt_pp;
  _r0.data = runtime_newobject((runtime__type_0 *)&RTYPE_fmt_pp_1);
  return _r0;
}

//----- (080D1E10) --------------------------------------------------------
// fmt.glob..func2
interface_ __golang fmt_glob__func2()
{
  interface_ _r0; // [esp+Ch] [ebp+4h]

  _r0._type = (runtime__type_0 *)&RTYPE__ptr_fmt_ss;
  _r0.data = runtime_newobject((runtime__type_0 *)&RTYPE_fmt_ss_1);
  return _r0;
}

//----- (080D1E50) --------------------------------------------------------
// fmt.(*ss).Token.func1
void __golang fmt__ptr_ss_Token_func1(error_0 *&err)
{
  runtime_itab_0 *v1; // edx
  uintptr v2;         // ebx
  error_0 *v3;        // eax
  interface_ src;     // [esp+4h] [ebp-8h]

  src = runtime_gorecover((uintptr) && err);
  if (src._type)
  {
    if (src._type == &RTYPE_fmt_scanError_1)
    {
      v1 = *(runtime_itab_0 **)src.data;
      v2 = *((_DWORD *)src.data + 1);
    }
    else
    {
      v2 = 0;
      v1 = 0;
    }
    if (src._type != &RTYPE_fmt_scanError_1)
    {
      runtime_gopanic(src);
      BUG();
    }
    v3 = &err;
    &err->tab = v1;
    if (*(_DWORD *)&runtime_writeBarrier.enabled)
      runtime_writebarrierptr((uintptr *)&v3->data, v2);
    else
      v3->data = (void *)v2;
  }
}

//----- (080D2D70) --------------------------------------------------------
// sort.init
void __golang sort_init()
{
  if (sort_initdone_ <= 1u)
  {
    if (sort_initdone_ == 1)
      runtime_throwinit();
    sort_initdone_ = 1;
    reflect_init();
    sort_initdone_ = 2;
  }
}

//----- (080D2DC0) --------------------------------------------------------
// strings.init
void __golang strings_init()
{
  if (strings_initdone_ <= 1u)
  {
    if (strings_initdone_ == 1)
      runtime_throwinit();
    strings_initdone_ = 1;
    io_init();
    unicode_init();
    strings_initdone_ = 2;
  }
}

//----- (080D32C0) --------------------------------------------------------
// io/ioutil.init
void __golang io_ioutil_init()
{
  if (io_ioutil_initdone_ <= 1u)
  {
    if (io_ioutil_initdone_ == 1)
      runtime_throwinit();
    io_ioutil_initdone_ = 1;
    bytes_init();
    io_init();
    os_init();
    sort_init();
    sync_init();
    path_filepath_init();
    strconv_init();
    time_init();
    io_ioutil_initdone_ = 2;
  }
}

//----- (080D3330) --------------------------------------------------------
// main.main
void __cdecl __noreturn main_main()
{
  main_openShop();
}

//----- (080D3350) --------------------------------------------------------
// main.openShop
void __golang __noreturn main_openShop()
{
  __int32 r5;                      // eax
  __int32 cap;                     // ecx
  __int32 v2;                      // edx
  main_item *v3;                   // ebx
  __int32 len;                     // ebp
  main_item *array;                // esi
  __int32 v6;                      // edi
  _slice_interface_ a;             // [esp+0h] [ebp-78h]
  retval_80D3530 aa;               // [esp+0h] [ebp-78h]
  string ab;                       // [esp+0h] [ebp-78h]
  _slice_interface_ ac;            // [esp+0h] [ebp-78h]
  _slice_interface_ a_8;           // [esp+8h] [ebp-70h]
  _slice_main_item user;           // [esp+Ch] [ebp-6Ch]
  retval_80D3960 v13;              // [esp+1Ch] [ebp-5Ch]

  // wallet here >[4]
  __int32 wallet;                  // [esp+38h] [ebp-40h]
  unsigned __int64 user_inv_len;   // [esp+3Ch] [ebp-3Ch]
  __int32 inventory_len;           // [esp+44h] [ebp-34h]
  unsigned __int64 inventory_lena; // [esp+44h] [ebp-34h]
  __int32 inventory_cap;           // [esp+48h] [ebp-30h]
  int elem;                        // [esp+4Ch] [ebp-2Ch] BYREF
  main_item *user_inv_ptr;         // [esp+50h] [ebp-28h]
  main_item *inventory_ptr;        // [esp+54h] [ebp-24h]
  main_item *inv;                  // [esp+58h] [ebp-20h]
  long double inv_4;               // [esp+5Ch] [ebp-1Ch] BYREF
  _DWORD v24[2];                   // [esp+68h] [ebp-10h] BYREF
  _DWORD v25[2];                   // [esp+70h] [ebp-8h] BYREF

  v25[0] = &RTYPE_string_0;
  v25[1] = &main_statictmp_0;
  a.array = (interface_ *)v25;
  *(_QWORD *)&a.len = 0x100000001LL;
  fmt_Println(a);
  aa = main_stockUp();
  inventory_len = aa._r0.len;
  inventory_ptr = aa._r0.array;
  user_inv_ptr = aa._r1.array;
  inventory_cap = aa._r0.cap;
  v24[0] = &RTYPE_string_0;
  v24[1] = &main_statictmp_1;
  aa._r0.array = (main_item *)v24;
  *(_QWORD *)&aa._r0.len = 0x100000001LL;
  fmt_Println((_slice_interface_)aa._r0);
  r5 = 40;
  cap = aa._r1.cap;
  v2 = inventory_cap;
  v3 = inventory_ptr;
  len = aa._r1.len;
  array = aa._r1.array;
  v6 = inventory_len;
  while (1)
  {
    *(_QWORD *)&inv_4 = (unsigned int)v3;
    user_inv_len = __PAIR64__(cap, len);
    inv = array;
    inventory_lena = __PAIR64__(v2, v6);
    wallet = r5;
    elem = r5;
    HIDWORD(inv_4) = 0;
    *(runtime_eface_0 *)((char *)&inv_4 + 4) = runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &elem);
    ab.str = (uint8 *)"You have %d coins\n";
    ab.len = 18;
    a_8.array = (interface_ *)((char *)&inv_4 + 4);
    *(_QWORD *)&a_8.len = 0x100000001LL;
    fmt_Printf(ab, a_8);
    ac.array = (interface_ *)LODWORD(inv_4);
    *(_QWORD *)&ac.len = inventory_lena;
    user.array = inv;
    *(_QWORD *)&user.len = user_inv_len;
    v13 = main_menu((_slice_main_item)ac, user, wallet);
    r5 = v13._r5;
    v3 = v13._r3.array;
    v6 = v13._r3.len;
    v2 = v13._r3.cap;
    array = v13._r4.array;
    len = v13._r4.len;
    cap = v13._r4.cap;
  }
}

//----- (080D3530) --------------------------------------------------------
// main.stockUp
retval_80D3530 __golang main_stockUp()
{
  main_item *array;          // eax
  __int32 len;               // ecx
  __int32 v2;                // edx
  __int32 v3;                // ebp
  __int32 cap;               // ecx
  int v5;                    // ebp
  __int32 v6;                // ebp
  int v7;                    // ecx
  main_item *v8;             // eax
  __int32 v9;                // ecx
  __int32 v10;               // edx
  int v11;                   // ebx
  __int32 v12;               // ecx
  int v13;                   // ebx
  __int32 v14;               // ebx
  int v15;                   // ecx
  runtime_slice_0 src;       // [esp+4h] [ebp-48h]
  runtime_slice_0 srcc;      // [esp+4h] [ebp-48h]
  runtime_slice_0 srce;      // [esp+4h] [ebp-48h]
  runtime_slice_0 srcd;      // [esp+4h] [ebp-48h]
  runtime_slice_0 srcb;      // [esp+4h] [ebp-48h]
  runtime_slice_0 srca;      // [esp+4h] [ebp-48h]
  runtime_slice_0 old;       // [esp+14h] [ebp-38h]
  runtime_slice_0 olda;      // [esp+14h] [ebp-38h]
  runtime_slice_0 olde;      // [esp+14h] [ebp-38h]
  runtime_slice_0 oldd;      // [esp+14h] [ebp-38h]
  runtime_slice_0 oldc;      // [esp+14h] [ebp-38h]
  runtime_slice_0 oldb;      // [esp+14h] [ebp-38h]
  __int32 user_inv_len;      // [esp+20h] [ebp-2Ch]
  __int32 user_inv_cap;      // [esp+24h] [ebp-28h]
  __int32 user_inv_capa;     // [esp+24h] [ebp-28h]
  __int32 inventory_len;     // [esp+28h] [ebp-24h]
  __int32 inventory_cap;     // [esp+2Ch] [ebp-20h]
  __int32 inventory_capa;    // [esp+2Ch] [ebp-20h]
  main_item *user_inv_ptr;   // [esp+3Ch] [ebp-10h]
  main_item *user_inv_ptra;  // [esp+3Ch] [ebp-10h]
  main_item *inventory_ptr;  // [esp+40h] [ebp-Ch]
  main_item *inventory_ptra; // [esp+40h] [ebp-Ch]
  retval_80D3530 _r0;        // [esp+50h] [ebp+4h]

  src.array = runtime_newobject((runtime__type_0 *)&RTYPE__0_main_item);
  *(_QWORD *)&src.len = 0LL;
  old = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, src, 1);
  array = (main_item *)old.array;
  len = old.len;
  v2 = old.cap;
  *((_DWORD *)old.array + 1) = 13;
  *((_DWORD *)old.array + 2) = 10;
  *((_DWORD *)old.array + 3) = 12;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    runtime_writebarrierptr((uintptr *)old.array, (uintptr) "Quiet Quiches");
    array = (main_item *)old.array;
    len = old.len;
    v2 = old.cap;
  }
  else
  {
    *(_DWORD *)old.array = "Quiet Quiches";
  }
  v3 = len + 1;
  cap = len + 2;
  if (cap > v2)
  {
    srca.array = array;
    *(_QWORD *)&srca.len = __PAIR64__(v2, v3);
    oldb = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, srca, cap);
    array = (main_item *)oldb.array;
    v2 = oldb.cap;
    cap = oldb.len + 1;
  }
  inventory_len = cap;
  v5 = v3;
  array[v5].item_name.len = 13;
  array[v5].price = 15;
  array[v5].count = 8;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    inventory_ptra = array;
    inventory_capa = v2;
    runtime_writebarrierptr((uintptr *)&array[v5], (uintptr) "Average Apple");
    array = inventory_ptra;
    cap = inventory_len;
    v2 = inventory_capa;
  }
  else
  {
    array[v5].item_name.str = (uint8 *)"Average Apple";
  }
  v6 = cap + 1;
  if (cap + 1 > v2)
  {
    srcb.array = array;
    *(_QWORD *)&srcb.len = __PAIR64__(v2, cap);
    oldc = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, srcb, cap + 1);
    array = (main_item *)oldc.array;
    v2 = oldc.cap;
    v6 = oldc.len + 1;
    cap = inventory_len;
  }
  inventory_ptr = array;
  inventory_cap = v2;
  v7 = cap;
  array[v7].item_name.len = 13;
  array[v7].price = 100;
  array[v7].count = 1;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
    runtime_writebarrierptr((uintptr *)&array[v7], (uintptr) "Fruitful Flag");
  else
    array[v7].item_name.str = (uint8 *)"Fruitful Flag";
  srcc.array = runtime_newobject((runtime__type_0 *)&RTYPE__0_main_item);
  *(_QWORD *)&srcc.len = 0LL;
  olda = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, srcc, 1);
  v8 = (main_item *)olda.array;
  v9 = olda.len;
  v10 = olda.cap;
  *((_DWORD *)olda.array + 1) = 13;
  *((_DWORD *)olda.array + 2) = 10;
  *((_DWORD *)olda.array + 3) = 0;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    runtime_writebarrierptr((uintptr *)olda.array, (uintptr) "Quiet Quiches");
    v8 = (main_item *)olda.array;
    v9 = olda.len;
    v10 = olda.cap;
  }
  else
  {
    *(_DWORD *)olda.array = "Quiet Quiches";
  }
  v11 = v9 + 1;
  v12 = v9 + 2;
  if (v12 > v10)
  {
    srcd.array = v8;
    *(_QWORD *)&srcd.len = __PAIR64__(v10, v11);
    oldd = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, srcd, v12);
    v8 = (main_item *)oldd.array;
    v10 = oldd.cap;
    v12 = oldd.len + 1;
  }
  user_inv_len = v12;
  v13 = v11;
  v8[v13].item_name.len = 13;
  v8[v13].price = 15;
  v8[v13].count = 0;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    user_inv_ptra = v8;
    user_inv_capa = v10;
    runtime_writebarrierptr((uintptr *)&v8[v13], (uintptr) "Average Apple");
    v8 = user_inv_ptra;
    v12 = user_inv_len;
    v10 = user_inv_capa;
  }
  else
  {
    v8[v13].item_name.str = (uint8 *)"Average Apple";
  }
  v14 = v12 + 1;
  if (v12 + 1 > v10)
  {
    srce.array = v8;
    *(_QWORD *)&srce.len = __PAIR64__(v10, v12);
    olde = runtime_growslice((runtime__type_0 *)&RTYPE_main_item_1, srce, v12 + 1);
    v8 = (main_item *)olde.array;
    v10 = olde.cap;
    v14 = olde.len + 1;
    v12 = user_inv_len;
  }
  v15 = v12;
  v8[v15].item_name.len = 13;
  v8[v15].price = 100;
  v8[v15].count = 0;
  if (*(_DWORD *)&runtime_writeBarrier.enabled)
  {
    user_inv_ptr = v8;
    user_inv_cap = v10;
    runtime_writebarrierptr((uintptr *)&v8[v15], (uintptr) "Fruitful Flag");
    v8 = user_inv_ptr;
    v10 = user_inv_cap;
  }
  else
  {
    v8[v15].item_name.str = (uint8 *)"Fruitful Flag";
  }
  _r0._r0.array = inventory_ptr;
  _r0._r0.len = v6;
  _r0._r0.cap = inventory_cap;
  _r0._r1.array = v8;
  _r0._r1.len = v14;
  _r0._r1.cap = v10;
  return _r0;
}

//----- (080D3960) --------------------------------------------------------
// main.menu
retval_80D3960 __golang main_menu(_slice_main_item inv, _slice_main_item user, __int32 wallet)
{
  __int32 j;              // eax
  __int32 *v4;            // eax
  __int32 r3;             // ecx
  __int32 cap;            // eax
  __int32 len;            // edx
  main_item *array;       // ebx
  __int32 v9;             // ecx
  __int32 *v10;           // edx
  __int32 v11;            // ebx
  __int32 count;          // edi
  __int32 v13;            // eax
  __int32 v14;            // eax
  __int32 v15;            // ebp
  _slice_interface_ a;    // [esp+0h] [ebp-A0h]
  string aa;              // [esp+0h] [ebp-A0h]
  _slice_interface_ ab;   // [esp+0h] [ebp-A0h]
  _slice_interface_ ac;   // [esp+0h] [ebp-A0h]
  _slice_interface_ ad;   // [esp+0h] [ebp-A0h]
  string ae;              // [esp+0h] [ebp-A0h]
  _slice_interface_ af;   // [esp+0h] [ebp-A0h]
  string ag;              // [esp+0h] [ebp-A0h]
  string ah;              // [esp+0h] [ebp-A0h]
  _slice_interface_ ai;   // [esp+0h] [ebp-A0h]
  _slice_interface_ a_8;  // [esp+8h] [ebp-98h]
  _slice_interface_ a_8a; // [esp+8h] [ebp-98h]
  _slice_interface_ a_8b; // [esp+8h] [ebp-98h]
  _slice_interface_ a_8c; // [esp+8h] [ebp-98h]
  retval_80D3F90 v30;     // [esp+10h] [ebp-90h]
  unsigned __int32 i;     // [esp+20h] [ebp-80h]
  int elem;               // [esp+2Ch] [ebp-74h] BYREF
  __int32 *_num;          // [esp+30h] [ebp-70h]
  __int32 *_choice;       // [esp+34h] [ebp-6Ch]
  _DWORD v35[2];          // [esp+38h] [ebp-68h] BYREF
  runtime_eface_0 v36;    // [esp+40h] [ebp-60h] BYREF
  _DWORD v37[2];          // [esp+48h] [ebp-58h] BYREF
  _DWORD v38[2];          // [esp+50h] [ebp-50h] BYREF
  _DWORD v39[2];          // [esp+58h] [ebp-48h] BYREF
  _DWORD v40[2];          // [esp+60h] [ebp-40h] BYREF
  _DWORD v41[2];          // [esp+68h] [ebp-38h] BYREF
  _DWORD v42[2];          // [esp+70h] [ebp-30h] BYREF
  _DWORD v43[2];          // [esp+78h] [ebp-28h] BYREF
  __int64 v44[4];         // [esp+80h] [ebp-20h] BYREF
  retval_80D3960 _r3;     // [esp+C0h] [ebp+20h]

  v43[0] = &RTYPE_string_0;
  v43[1] = &main_statictmp_2;
  a.array = (interface_ *)v43;
  *(_QWORD *)&a.len = 0x100000001LL;
  fmt_Println(a);
  for (j = 0; j < inv.len; j = i + 1)
  {
    i = j;
    elem = j;
    ((void (*)(void))loc_8090B18)();
    v44[0] = (__int64)runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &elem);
    if (i >= inv.len)
      runtime_panicindex();
    v44[1] = (__int64)runtime_convT2Estring((runtime__type_0 *)&RTYPE_string_0, &inv.array[i]);
    v44[2] = (__int64)runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &inv.array[i].price);
    v44[3] = (__int64)runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &inv.array[i].count);
    aa.str = (uint8 *)"(%d) %s\t%d\t%d\n";
    aa.len = 14;
    a_8.array = (interface_ *)v44;
    *(_QWORD *)&a_8.len = 0x400000004LL;
    fmt_Printf(aa, a_8);
  }
  v42[0] = &RTYPE_string_0;
  v42[1] = &main_statictmp_3;
  ab.array = (interface_ *)v42;
  *(_QWORD *)&ab.len = 0x100000001LL;
  fmt_Println(ab);
  v41[0] = &RTYPE_string_0;
  v41[1] = &main_statictmp_4;
  ac.array = (interface_ *)v41;
  *(_QWORD *)&ac.len = 0x100000001LL;
  fmt_Println(ac);
  v40[0] = &RTYPE_string_0;
  v40[1] = &main_statictmp_5;
  ad.array = (interface_ *)v40;
  *(_QWORD *)&ad.len = 0x100000001LL;
  fmt_Println(ad);
  _choice = (__int32 *)runtime_newobject((runtime__type_0 *)&RTYPE_int);
  v39[0] = &RTYPE__ptr_int;
  v39[1] = _choice;
  ae.str = (uint8 *)"%d";
  ae.len = 2;
  a_8a.array = (interface_ *)v39;
  *(_QWORD *)&a_8a.len = 0x100000001LL;
  fmt_Scanf(ae, a_8a);
  v4 = _choice;
  if ((unsigned int)*_choice > 3)
    os_Exit(0);
  if (*_choice < 3)
  {
    _num = (__int32 *)runtime_newobject((runtime__type_0 *)&RTYPE_int);
    v38[0] = &RTYPE_string_0;
    v38[1] = &main_statictmp_6;
    af.array = (interface_ *)v38;
    *(_QWORD *)&af.len = 0x100000001LL;
    fmt_Println(af);
    v37[0] = &RTYPE__ptr_int;
    v37[1] = _num;
    ag.str = (uint8 *)"%d";
    ag.len = 2;
    a_8b.array = (interface_ *)v37;
    *(_QWORD *)&a_8b.len = 0x100000001LL;
    fmt_Scanf(ag, a_8b);
    v9 = *_num;
    v10 = _choice;
    if ((unsigned int)*_choice >= inv.len)
      runtime_panicindex();
    v11 = *_choice;
    count = inv.array[v11].count;
    if (v9 <= count)
    {
      if (wallet < inv.array[v11].price)
      {
        v35[0] = &RTYPE_string_0;
        v35[1] = &main_statictmp_7;
        ai.array = (interface_ *)v35;
        *(_QWORD *)&ai.len = 0x100000001LL;
        fmt_Println(ai);
        v15 = wallet;
      }
      else
      {
        inv.array[v11].count = count - v9;
        if ((unsigned int)*v10 >= inv.len)
          runtime_panicindex();
        v14 = *v10;
        v15 = wallet - *_num * inv.array[v14].price;
        if ((unsigned int)*v10 >= user.len)
          runtime_panicindex();
        user.array[v14].count += *_num;
        if (inv.len <= 2u)
          runtime_panicindex();
        if (inv.array[2].count != 1)
          main_get_flag();
      }
      v13 = v15;
    }
    else
    {
      v36 = 0LL;
      if ((unsigned int)*_choice >= inv.len)
        runtime_panicindex();
      v36 = runtime_convT2Estring((runtime__type_0 *)&RTYPE_string_0, &inv.array[*_choice]);
      ah.str = (uint8 *)"No more %s\n";
      ah.len = 11;
      a_8c.array = &v36;
      *(_QWORD *)&a_8c.len = 0x100000001LL;
      fmt_Printf(ah, a_8c);
      v13 = wallet;
    }
    r3 = v13;
    v4 = _choice;
  }
  else
  {
    r3 = wallet;
  }
  if (*v4 == 3)
  {
    v30 = main_sell(user, r3);
    cap = v30._r2.cap;
    array = v30._r2.array;
    len = v30._r2.len;
    r3 = v30._r3;
  }
  else
  {
    cap = user.cap;
    len = user.len;
    array = user.array;
  }
  _r3._r3 = inv;
  _r3._r4.array = array;
  _r3._r4.len = len;
  _r3._r4.cap = cap;
  _r3._r5 = r3;
  return _r3;
}
// 80DED60: using guessed type RTYPE RTYPE__ptr_int;

//----- (080D3F90) --------------------------------------------------------
// main.sell
retval_80D3F90 __golang main_sell(_slice_main_item user, __int32 wallet)
{
  __int32 len;            // eax
  int v3;                 // ecx
  __int32 *v4;            // eax
  unsigned __int32 v5;    // ecx
  __int32 *v6;            // edx
  __int32 v7;             // ebx
  __int32 v8;             // ebp
  unsigned __int32 v9;    // ecx
  main_item *array;       // esi
  __int32 count;          // edi
  unsigned __int32 v12;   // eax
  __int32 v13;            // eax
  _slice_interface_ a;    // [esp+0h] [ebp-94h]
  string aa;              // [esp+0h] [ebp-94h]
  _slice_interface_ ab;   // [esp+0h] [ebp-94h]
  string ac;              // [esp+0h] [ebp-94h]
  _slice_interface_ ad;   // [esp+0h] [ebp-94h]
  string ae;              // [esp+0h] [ebp-94h]
  _slice_interface_ af;   // [esp+0h] [ebp-94h]
  _slice_interface_ ag;   // [esp+0h] [ebp-94h]
  _slice_interface_ ah;   // [esp+0h] [ebp-94h]
  _slice_interface_ a_8;  // [esp+8h] [ebp-8Ch]
  _slice_interface_ a_8a; // [esp+8h] [ebp-8Ch]
  _slice_interface_ a_8b; // [esp+8h] [ebp-8Ch]
  unsigned __int32 i;     // [esp+20h] [ebp-74h]
  int elem;               // [esp+28h] [ebp-6Ch] BYREF
  __int32 *_num;          // [esp+2Ch] [ebp-68h]
  __int32 *_choice;       // [esp+30h] [ebp-64h]
  _slice_interface_ v30;  // [esp+34h] [ebp-60h] BYREF
  string *v31;            // [esp+40h] [ebp-54h]
  _slice_interface_ v32;  // [esp+44h] [ebp-50h] BYREF
  __int32 *v33;           // [esp+50h] [ebp-44h]
  _DWORD v34[2];          // [esp+54h] [ebp-40h] BYREF
  _DWORD v35[2];          // [esp+5Ch] [ebp-38h] BYREF
  _DWORD v36[2];          // [esp+64h] [ebp-30h] BYREF
  _DWORD v37[2];          // [esp+6Ch] [ebp-28h] BYREF
  _QWORD v38[4];          // [esp+74h] [ebp-20h] BYREF
  retval_80D3F90 _r2;     // [esp+A8h] [ebp+14h]

  v30.array = (interface_ *)&RTYPE_string_0;
  v30.len = (__int32)&main_statictmp_8;
  a.array = (interface_ *)&v30;
  *(_QWORD *)&a.len = 0x100000001LL;
  fmt_Println(a);
  len = user.len;
  if (user.len < 1)
  {
    v37[0] = &RTYPE_string_0;
    v37[1] = &main_statictmp_9;
    ah.array = (interface_ *)v37;
    *(_QWORD *)&ah.len = 0x100000001LL;
    fmt_Println(ah);
    v8 = user.len;
    array = user.array;
    v13 = wallet;
  }
  else
  {
    v3 = 0;
    while (v3 < len)
    {
      i = v3;
      elem = v3;
      ((void (*)(void))loc_8090B18)();
      v38[0] = runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &elem);
      if (i >= user.len)
        runtime_panicindex();
      v38[1] = runtime_convT2Estring((runtime__type_0 *)&RTYPE_string_0, &user.array[i]);
      v38[2] = runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &user.array[i].price);
      v38[3] = runtime_convT2E32((runtime__type_0 *)&RTYPE_int, &user.array[i].count);
      aa.str = (uint8 *)"(%d) %s\t%d\t%d\n";
      aa.len = 14;
      a_8.array = (interface_ *)v38;
      *(_QWORD *)&a_8.len = 0x400000004LL;
      fmt_Printf(aa, a_8);
      v3 = i + 1;
      len = user.len;
    }
    _choice = (__int32 *)runtime_newobject((runtime__type_0 *)&RTYPE_int);
    _num = (__int32 *)runtime_newobject((runtime__type_0 *)&RTYPE_int);
    v36[0] = &RTYPE_string_0;
    v36[1] = &main_statictmp_10;
    ab.array = (interface_ *)v36;
    *(_QWORD *)&ab.len = 0x100000001LL;
    fmt_Println(ab);
    v35[0] = &RTYPE__ptr_int;
    v35[1] = _choice;
    ac.str = (uint8 *)"%d";
    ac.len = 2;
    a_8a.array = (interface_ *)v35;
    *(_QWORD *)&a_8a.len = 0x100000001LL;
    fmt_Scanf(ac, a_8a);
    v34[0] = &RTYPE_string_0;
    v34[1] = &main_statictmp_11;
    ad.array = (interface_ *)v34;
    *(_QWORD *)&ad.len = 0x100000001LL;
    fmt_Println(ad);
    v32.cap = (__int32)&RTYPE__ptr_int;
    v33 = _num;
    ae.str = (uint8 *)"%d";
    ae.len = 2;
    a_8b.array = (interface_ *)&v32.cap;
    *(_QWORD *)&a_8b.len = 0x100000001LL;
    fmt_Scanf(ae, a_8b);
    v4 = _choice;
    v5 = *_choice;
    if ((unsigned int)*_choice >= 3)
    {
      v30.cap = (__int32)&RTYPE_string_0;
      v31 = &main_statictmp_13;
      ag.array = (interface_ *)&v30.cap;
      *(_QWORD *)&ag.len = 0x100000001LL;
      fmt_Println(ag);
      v8 = user.len;
      array = user.array;
      v13 = wallet;
    }
    else
    {
      v6 = _num;
      v7 = *_num;
      v8 = user.len;
      if (v5 >= user.len)
        runtime_panicindex();
      v9 = v5;
      array = user.array; ̰
      count = user.array[v9].count;
      if (v7 > count)
      {
        v32.array = (interface_ *)&RTYPE_string_0;
        v32.len = (__int32)&main_statictmp_12;
        af.array = (interface_ *)&v32;
        *(_QWORD *)&af.len = 0x100000001LL;
        fmt_Println(af);
        v8 = user.len;
        array = user.array;
        v13 = wallet;
      }
      else
      {
        user.array[v9].count = count - v7;
        v12 = *v4;
        if (v12 >= user.len)
          runtime_panicindex();
        v13 = wallet + *v6 * user.array[v12].price;
      }
    }
  }
  _r2._r2.array = array;
  _r2._r2.len = v8;
  _r2._r2.cap = user.cap;
  _r2._r3 = v13;
  return _r2;
}
// 80DED60: using guessed type RTYPE RTYPE__ptr_int;

//----- (080D4440) --------------------------------------------------------
// main.get_flag
// local variable allocation has failed, the output may be wrong!
void __golang __noreturn main_get_flag()
{
  string filename;      // [esp+0h] [ebp-44h]
  _DWORD *filenamea;    // [esp+0h] [ebp-44h]
  _BYTE filename_4[24]; // [esp+4h] [ebp-40h] OVERLAPPED
  int elem[3];          // [esp+28h] [ebp-1Ch] BYREF
  _DWORD a[2];          // [esp+34h] [ebp-10h] BYREF
  runtime_eface_0 a_8;  // [esp+3Ch] [ebp-8h]

  filename.str = (uint8 *)"flag.txt";
  filename.len = 8;
  *(retval_80D3040 *)&filename_4[4] = io_ioutil_ReadFile(filename);
  main_check(*(error_0 *)&filename_4[16]);
  elem[0] = *(_DWORD *)&filename_4[4];
  elem[1] = *(_DWORD *)&filename_4[8];
  elem[2] = *(_DWORD *)&filename_4[12];
  a_8 = 0LL;
  a[0] = &RTYPE_string_0;
  a[1] = &main_statictmp_14;
  a_8 = runtime_convT2Eslice((runtime__type_0 *)&RTYPE__slice_uint8_0, elem);
  filenamea = a;
  *(_QWORD *)filename_4 = 0x200000002LL;
  fmt_Println(*(_slice_interface_ *)&filename_4[-4]);
  os_Exit(0);
}
// 80D446B: failed to expand linear variable ^4.24

//----- (080D4550) --------------------------------------------------------
// main.check
void __golang main_check(error_0 e)
{
  if (e.tab)
  {
    runtime_gopanic((interface_)__PAIR64__((unsigned int)e.data, e.tab->_type));
    BUG();
  }
}
// 80D4571: conditional instruction was optimized away because %e.4!=0

//----- (080D4590) --------------------------------------------------------
// main.init
void __golang main_init()
{
  if (main_initdone_ <= 1u)
  {
    if (main_initdone_ == 1)
      runtime_throwinit();
    main_initdone_ = 1;
    fmt_init();
    io_ioutil_init();
    os_init();
    main_initdone_ = 2;
  }
}

// nfuncs=1993 queued=372 decompiled=372 lumina nreq=0 worse=0 better=0
// ALL OK, 372 function(s) have been successfully decompiled
