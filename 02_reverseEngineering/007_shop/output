nc mercury.picoctf.net 37799
to disassemble the binary to a assembly code use : objdump -D source > yo.S
In my file called hello.c the above code is what I use. When I compile with gcc and get my hello executable, we will then use objdump to do a quick dump conversion. When using objdump -D hello we get the following output:

objdump output

objdump is very good for quick disassembly of executable portions of a C binary.

use decompiler to get a readable code : https://dogbolt.org/?id=4242ea17-7faf-40ad-92ce-d25d32cd09bd#Hex-Rays=9444
esp is the stack pointer, ebp is/was for a stack frame so that when you entered a function ebp could get a copy of esp at that point, everything on the stack before that happens, return address, passed in parameters, etc and things that are global for that function (local variables) will now be a static distance away from the stack frame pointer for the duration of the function. esp is now free to wander about as the compiler desires and can be used when nesting to other functions (each needs to preserve the ebp naturally).

it is a lazy way to manage the stack. makes compiler debugging a lot easier, makes understanding the code generated by the compiler easier, but burns a register that might have been otherwise general purpose.

use this for learning about the pointers in response to the satck : https://stackoverflow.com/questions/21718397/what-are-the-esp-and-the-ebp-registers

using __int32 [ might be overflow, but constraints are low enough not to trigger the overflow

i might have genrated the decompiled file with no local variable allocaiton 
[ need to keep that in my mind ]

 
LM0008187:045 naveen1.mathur$ gcc -s -o yo.S real_code.c
ld: warning: -s is obsolete
ld: warning: ignoring duplicate libraries: '-lgcc'
ld: Undefined symbols:
  _main, referenced from:
      <initial-undefines>
collect2: error: ld returned 1 exit status

gcc -s -o yo.S code.c

use this to convert assembly to c

After playing around for a bit, I sold a negative number of item.... and ended up with a negative value for money. Through this I realized I should also be able to buy negative numbers of items since the shop probably only checks if there are less than how many items are in their stock. I bought a negative number of items and sure enough, ended up with a large enough sum of coins to buy a flag.




---------------------------------------------------------------------------------------------------------------------------------------
What do you want to sell? 
0
How many?
-99999999 
You have -1190999950 coins
	Item		Price	Count
(0) Quiet Quiches	10	12
(1) Average Apple	15	8
(2) Fruitful Flag	100	1
(3) Sell an Item
(4) Exit
Choose an option: 
3
Your inventory
(0) Quiet Quiches	10	115499999
(1) Average Apple	15	2400000
(2) Fruitful Flag	100	0
What do you want to sell? 
0
How many?
-998998898 
You have 1703912958 coins
	Item		Price	Count
(0) Quiet Quiches	10	12
(1) Average Apple	15	8
(2) Fruitful Flag	100	1
(3) Sell an Item
(4) Exit
Choose an option: 
2
How many do you want to buy?
1
Flag is:  [112 105 99 111 67 84 70 123 98 52 100 95 98 114 111 103 114 97 109 109 101 114 95 53 57 49 97 56 57 53 97 125]
---------------------------------------------------------------------------------------------------------------------------------------


output for the program

just sell negatives and make the __int32 overflow
